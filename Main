-- ================================================================
-- Grow A Garden Clean - Exact SloppyCoding Recreation
-- Created from scratch using Obsidian Library
-- Replicates exact functionality from GrowAGardenSloppyCoding
-- ================================================================

-- ================================================================
-- LIBRARY INITIALIZATION
-- ================================================================
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
Library = loadstring(game:HttpGet(repo .. "Library.lua"))() -- Made global for CRAFTERTAB
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- Global references for easy access
local Options = Library.Options
local Toggles = Library.Toggles

-- Library configuration
Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

-- ================================================================
-- WINDOW CREATION
-- ================================================================
Window = Library:CreateWindow({ -- Made global for CRAFTERTAB
	Title = "REFACTOR",
	Footer = "MADE MY MICHEAL DOXINS",
	Icon = 137010157074208,
	NotifySide = "Right",
	ShowCustomCursor = true,
})

-- ================================================================
-- SERVICES SETUP (Exact from SloppyCoding)
-- ================================================================
local Services = {
    Workspace = game:GetService("Workspace"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    Players = game:GetService("Players"),
    UserInputService = game:GetService("UserInputService"),
    TweenService = game:GetService("TweenService"),
    CollectionService = game:GetService("CollectionService"),
    HttpService = game:GetService("HttpService"),
    RunService = game:GetService("RunService"),
    GuiService = game:GetService("GuiService"),
    TeleportService = game:GetService("TeleportService"),
    Debris = game:GetService("Debris"),
    SoundService = game:GetService("SoundService")
}

local LocalPlayer = Services.Players.LocalPlayer

-- Remote Events (Exact from SloppyCoding)
local Plant_RE = Services.ReplicatedStorage.GameEvents.Plant_RE

-- ================================================================
-- TAB STRUCTURE (Exact from SloppyCoding)
-- ================================================================
Tabs = { -- Made global for CRAFTERTAB
	Main = Window:AddTab("Main", "user"),
	Auto = Window:AddTab("Auto", "zap"),
	Store = Window:AddTab("Store", "shopping-cart"),
	Essential = Window:AddTab("Essential", "star"),
	Event = Window:AddTab("Event", "calendar"),
	["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

-- ================================================================
-- STORE TAB STRUCTURE
-- ================================================================

-- Add variables to track store states
local seedShopOpen = false
local cosmeticShopOpen = false
local gearShopOpen = false
local merchantStoreOpen = false
local summerStoreOpen = false
local daileyQuestsOpen = false

-- Add GuiController reference
local GuiController = require(Services.ReplicatedStorage.Modules.GuiController)
local NPCMod = require(Services.ReplicatedStorage.NPC_MOD)

-- Stores GroupBox (Main Store Menu)
local StoresGroupBox = Tabs.Store:AddLeftGroupbox("Stores")

-- Seed Store Toggle
StoresGroupBox:AddToggle("SeedStoreToggle", {
    Text = "Open/Close Seed Store",
    Tooltip = "Toggle the in-game seed store window",
    Default = false,

    Callback = function(Value)
        print("[cb] Seed Store toggle:", Value)
        seedShopOpen = Value

        if Value then
            -- Open seed store
            if LocalPlayer.PlayerGui:FindFirstChild("Seed_Shop") then
                GuiController:Open(LocalPlayer.PlayerGui.Seed_Shop)
                print("Opened seed store!")
            else
                print("Seed_Shop GUI not found!")
            end
        else
            -- Close seed store
            if LocalPlayer.PlayerGui:FindFirstChild("Seed_Shop") then
                GuiController:Close(LocalPlayer.PlayerGui.Seed_Shop)
                print("Closed seed store!")
            end
        end
    end,
})

-- Cosmetic Store Toggle
StoresGroupBox:AddToggle("CosmeticStoreToggle", {
    Text = "Open/Close Cosmetic Store",
    Tooltip = "Toggle the in-game cosmetic store window",
    Default = false,

    Callback = function(Value)
        print("[cb] Cosmetic Store toggle:", Value)
        cosmeticShopOpen = Value

        if Value then
            -- Open cosmetic store with NPC interaction simulation
            if LocalPlayer.PlayerGui:FindFirstChild("CosmeticShop_UI") then
                -- Start NPC interaction
                NPCMod.Start_Speak(LocalPlayer)

                -- Wait a moment for the interaction to process
                task.wait(0.8)

                -- Open the cosmetic shop
                GuiController:Open(LocalPlayer.PlayerGui.CosmeticShop_UI)
                print("Opened cosmetic store!")

                -- End NPC interaction after a moment
                task.wait(0.6)
                NPCMod.End_Speak(LocalPlayer)
            else
                print("CosmeticShop_UI GUI not found!")
            end
        else
            -- Close cosmetic store
            if LocalPlayer.PlayerGui:FindFirstChild("CosmeticShop_UI") then
                GuiController:Close(LocalPlayer.PlayerGui.CosmeticShop_UI)
                NPCMod.End_Speak(LocalPlayer)
                print("Closed cosmetic store!")
            end
        end
    end,
})

-- Gear Store Toggle
StoresGroupBox:AddToggle("GearStoreToggle", {
    Text = "Open/Close Gear Store",
    Tooltip = "Toggle the in-game gear store window",
    Default = false,

    Callback = function(Value)
        print("[cb] Gear Store toggle:", Value)
        gearShopOpen = Value

        if Value then
            -- Open gear store with NPC interaction simulation
            if LocalPlayer.PlayerGui:FindFirstChild("Gear_Shop") then
                -- Start NPC interaction
                NPCMod.Start_Speak(LocalPlayer)

                -- Wait a moment for the interaction to process
                task.wait(0.5)

                -- Open the gear shop
                GuiController:Open(LocalPlayer.PlayerGui.Gear_Shop)
                print("Opened gear store!")

                -- End NPC interaction after a moment
                task.wait(0.2)
                NPCMod.End_Speak(LocalPlayer)
            else
                print("Gear_Shop GUI not found!")
            end
        else
            -- Close gear store
            if LocalPlayer.PlayerGui:FindFirstChild("Gear_Shop") then
                GuiController:Close(LocalPlayer.PlayerGui.Gear_Shop)
                NPCMod.End_Speak(LocalPlayer)
                print("Closed gear store!")
            end
        end
    end,
})

-- Traveling Merchant Store Toggle
StoresGroupBox:AddToggle("MerchantStoreToggle", {
    Text = "Open Merchant Store",
    Tooltip = "Toggle the traveling merchant store window",
    Default = false,

    Callback = function(Value)
        print("[cb] Merchant Store toggle:", Value)
        merchantStoreOpen = Value

        if Value then
            -- Open merchant store
            if LocalPlayer.PlayerGui:FindFirstChild("TravelingMerchantShop_UI") then
                GuiController:Open(LocalPlayer.PlayerGui.TravelingMerchantShop_UI)
                print("Opened merchant store!")
            else
                print("TravelingMerchantShop_UI not found!")
                Library:Notify("âŒ Merchant Store not available!", 3)
            end
        else
            -- Close merchant store
            if LocalPlayer.PlayerGui:FindFirstChild("TravelingMerchantShop_UI") then
                GuiController:Close(LocalPlayer.PlayerGui.TravelingMerchantShop_UI)
                print("Closed merchant store!")
            end
        end
    end,
})

-- Summer Store Toggle
StoresGroupBox:AddToggle("SummerStoreToggle", {
    Text = "Open Summer Store",
    Tooltip = "Toggle the summer harvest store window",
    Default = false,

    Callback = function(Value)
        print("[cb] Summer Store toggle:", Value)
        summerStoreOpen = Value

        if Value then
            -- Open summer store
            if LocalPlayer.PlayerGui:FindFirstChild("EventShop_UI") then
                GuiController:Open(LocalPlayer.PlayerGui.EventShop_UI)
                print("Opened EventShop_UI!")
                Library:Notify("ðŸª Summer Shop opened!", 2)
            else
                print("EventShop_UI not found!")
                Library:Notify("âŒ Summer Store not available!", 3)
            end
        else
            -- Close summer store
            if LocalPlayer.PlayerGui:FindFirstChild("EventShop_UI") then
                GuiController:Close(LocalPlayer.PlayerGui.EventShop_UI)
                print("Closed EventShop_UI!")
                Library:Notify("ðŸª Summer Shop closed!", 2)
            end
        end
    end,
})

-- Daily Quests Toggle
StoresGroupBox:AddToggle("DaileyQuestsToggle", {
    Text = "Open/Close Daily Quests",
    Tooltip = "Toggle the daily quests window",
    Default = false,

    Callback = function(Value)
        print("[cb] Daily Quests toggle:", Value)
        daileyQuestsOpen = Value

        if Value then
            -- Open daily quests with proper initialization
            if LocalPlayer.PlayerGui:FindFirstChild("DailyQuests_UI") then
                local questUI = LocalPlayer.PlayerGui.DailyQuests_UI
                GuiController:Open(questUI)

                -- Initialize quests if needed
                local success, result = pcall(function()
                    local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
                    local DataService = require(Services.ReplicatedStorage.Modules.DataService)
                    local data = DataService:GetData()

                    if data and data.DailyQuests and data.DailyQuests.ContainerId then
                        local container = QuestsController:GetContainerFromId(data.DailyQuests.ContainerId)
                        if container then
                            QuestsController:DisplayContainer(container)
                        end
                    end
                end)

                print("Opened daily quests!")
            else
                print("DailyQuests_UI GUI not found!")
            end
        else
            -- Close daily quests
            if LocalPlayer.PlayerGui:FindFirstChild("DailyQuests_UI") then
                GuiController:Close(LocalPlayer.PlayerGui.DailyQuests_UI)
                print("Closed daily quests!")
            end
        end
    end,
})

-- SeedStore GroupBox
local SeedStoreGroupBox = Tabs.Store:AddLeftGroupbox("Seed Store")

-- Add seed store functionality
SeedStoreGroupBox:AddDropdown("StoreItems", {
    Values = {
        -- ONLY seeds that are actually available in the shop (DisplayInShop = true)
        "Apple",
        "Avocado",
        "Bamboo",
        "Banana",
        "Beanstalk",
        "Bell Pepper",
        "Blueberry",
        "Cacao",
        "Cactus",
        "Carrot",
        "Cauliflower",
        "Coconut",
        "Corn",
        "Daffodil",
        "Dragon Fruit",
        "Ember Lily",
        "Feijoa",
        "Grape",
        "Green Apple",
        "Kiwi",
        "Loquat",
        "Mango",
        "Mushroom",
        "Orange Tulip",
        "Pepper",
        "Pineapple",
        "Prickly Pear",
        "Pumpkin",
        "Strawberry",
        "Sugar Apple",
        "Tomato",
        "Watermelon",
    },
    Default = 1,
    Multi = true, -- Allows multiple selections

    Text = "Select Items to Purchase",
    Tooltip = "Choose multiple items from the store",

    Callback = function(Value)
        print("[cb] Store items selection changed:")
        for item, selected in next, Options.StoreItems.Value do
            print(item, selected)
        end
    end,
})

SeedStoreGroupBox:AddToggle("AutoPurchase", {
    Text = "Auto Purchase Selected Items",
    Tooltip = "Automatically purchase the selected items",
    Default = false,

    Callback = function(Value)
        print("[cb] Auto Purchase toggled:", Value)
        if Value then
            -- Start auto buying loop
            task.spawn(function()
                while Toggles.AutoPurchase.Value do
                    -- Auto buy selected items continuously
                    for item, selected in next, Options.StoreItems.Value do
                        if selected then
                            -- Use the BuySeedStock remote event
                            local BuySeedStock = Services.ReplicatedStorage.GameEvents:FindFirstChild("BuySeedStock")
                            if BuySeedStock then
                                BuySeedStock:FireServer(item)
                                print("Auto purchased:", item)
                            else
                                print("BuySeedStock remote not found!")
                            end
                        end
                    end
                    task.wait(0.1) -- Wait 0.1 seconds between purchases
                end
            end)
        end
    end,
})

-- GearStore GroupBox
local GearStoreGroupBox = Tabs.Store:AddRightGroupbox("Gear Store")

-- Add gear store functionality
GearStoreGroupBox:AddDropdown("GearItems", {
    Values = {
        -- ONLY gear that is actually available in the shop (DisplayInShop = true)
        "Advanced Sprinkler",
        "Basic Sprinkler",
        "Cleaning Spray",
        "Favorite Tool",
        "Friendship Pot",
        "Godly Sprinkler",
        "Harvest Tool",
        "Lightning Rod",
        "Master Sprinkler",
        "Recall Wrench",
        "Tanning Mirror",
        "Trowel",
        "Watering Can",
    },
    Default = 1,
    Multi = true, -- Allows multiple selections

    Text = "Select Gear to Purchase",
    Tooltip = "Choose multiple gear items from the store",

    Callback = function(Value)
        print("[cb] Gear items selection changed:")
        for item, selected in next, Options.GearItems.Value do
            print(item, selected)
        end
    end,
})

GearStoreGroupBox:AddToggle("AutoPurchaseGear", {
    Text = "Auto Purchase Selected Gear",
    Tooltip = "Automatically purchase the selected gear items",
    Default = false,

    Callback = function(Value)
        print("[cb] Auto Purchase Gear toggled:", Value)
        if Value then
            -- Start auto buying gear loop
            task.spawn(function()
                while Toggles.AutoPurchaseGear.Value do
                    -- Auto buy selected gear items continuously
                    for item, selected in next, Options.GearItems.Value do
                        if selected then
                            -- Use the BuyGearStock remote event
                            local BuyGearStock = Services.ReplicatedStorage.GameEvents:FindFirstChild("BuyGearStock")
                            if BuyGearStock then
                                BuyGearStock:FireServer(item)
                                print("Auto purchased gear:", item)
                            else
                                print("BuyGearStock remote not found!")
                            end
                        end
                    end
                    task.wait(0.1) -- Wait 0.1 seconds between purchases
                end
            end)
        end
    end,
})

-- CosmeticStore GroupBox
local CosmeticStoreGroupBox = Tabs.Store:AddLeftGroupbox("Cosmetic Store")

-- Add cosmetic store functionality
CosmeticStoreGroupBox:AddDropdown("CosmeticItems", {
    Values = {
        -- Cosmetic Crates available in shop (from CosmeticCrateShopData)
        "Sign Crate",
        "Beach Crate",
        "Common Gnome Crate",
        "Fun Crate",
        "Summer Fun Crate",
        "Farmers Gnome Crate",
        "Classic Gnome Crate",
        "Statue Crate",
        -- High-value Individual Cosmetic Items available in shop (from CosmeticItemShopData)
        "Blue Well",
        "Brown Well",
        "Red Well",
        "Green Tractor",
        "Red Tractor",
        "Frog Fountain",
        "Ring Walkway",
        "Viney Ring Walkway",
        "Large Wood Arbour",
        "Round Metal Arbour",
        "Tiki Bar",
        "Market Cart",
    },
    Default = 1,
    Multi = true, -- Allows multiple selections

    Text = "Select Cosmetics to Purchase",
    Tooltip = "Choose multiple cosmetic items from the store",

    Callback = function(Value)
        print("[cb] Cosmetic items selection changed:")
        for item, selected in next, Options.CosmeticItems.Value do
            print(item, selected)
        end
    end,
})

CosmeticStoreGroupBox:AddToggle("AutoPurchaseCosmetics", {
    Text = "Auto Purchase Selected Cosmetics",
    Tooltip = "Automatically purchase the selected cosmetic items",
    Default = false,

    Callback = function(Value)
        print("[cb] Auto Purchase Cosmetics toggled:", Value)
        if Value then
            -- Start auto buying cosmetics loop
            task.spawn(function()
                while Toggles.AutoPurchaseCosmetics.Value do
                    -- Auto buy selected cosmetic items continuously
                    for item, selected in next, Options.CosmeticItems.Value do
                        if selected then
                            -- Define which items are crates vs individual cosmetic items
                            local cosmeticCrates = {
                                "Sign Crate", "Beach Crate", "Common Gnome Crate", "Fun Crate",
                                "Summer Fun Crate", "Farmers Gnome Crate", "Classic Gnome Crate", "Statue Crate"
                            }

                            -- Check if item is a crate
                            local isCrate = false
                            for _, crateName in ipairs(cosmeticCrates) do
                                if item == crateName then
                                    isCrate = true
                                    break
                                end
                            end

                            -- Purchase accordingly
                            if isCrate then
                                -- Use the BuyCosmeticCrate remote event
                                local BuyCosmeticCrate = Services.ReplicatedStorage.GameEvents:FindFirstChild("BuyCosmeticCrate")
                                if BuyCosmeticCrate then
                                    BuyCosmeticCrate:FireServer(item)
                                else
                                    print("BuyCosmeticCrate remote not found!")
                                end
                            else
                                -- Individual cosmetic item
                                -- Use the BuyCosmeticItem remote event
                                local BuyCosmeticItem = Services.ReplicatedStorage.GameEvents:FindFirstChild("BuyCosmeticItem")
                                if BuyCosmeticItem then
                                    BuyCosmeticItem:FireServer(item)
                                else
                                    print("BuyCosmeticItem remote not found!")
                                end
                            end
                            print("Auto purchased cosmetic:", item)
                        end
                    end
                    task.wait(0.1) -- Wait 0.1 seconds between purchases
                end
            end)
        end
    end,
})

-- DaileyStore GroupBox
local DaileyStoreGroupBox = Tabs.Store:AddRightGroupbox("Daily Store")

-- Add daily store functionality
DaileyStoreGroupBox:AddLabel("Daily Quests and Rewards")

DaileyStoreGroupBox:AddButton("Claim All Daily Rewards", function()
    -- Try to claim all daily rewards
    local success, result = pcall(function()
        local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()

        if data and data.DailyQuests and data.DailyQuests.ContainerId then
            local container = QuestsController:GetContainerFromId(data.DailyQuests.ContainerId)
            if container then
                -- Try to claim all completed quests
                local claimedAny = false
                for _, quest in pairs(container.Quests) do
                    if quest.Completed and not quest.Claimed then
                        QuestsController:ClaimQuest(quest.Id)
                        print("Claimed quest reward:", quest.Name)
                        claimedAny = true
                    end
                end

                if claimedAny then
                    Library:Notify("âœ… Claimed daily quest rewards!", 3)
                else
                    Library:Notify("âŒ No completed quests to claim", 3)
                end

                return true
            end
        end
        return false
    end)

    if not success or not result then
        Library:Notify("âŒ Failed to claim daily rewards", 3)
    end
end)

DaileyStoreGroupBox:AddButton("Open Daily Quests UI", function()
    -- Open the daily quests UI
    if LocalPlayer.PlayerGui:FindFirstChild("DailyQuests_UI") then
        local questUI = LocalPlayer.PlayerGui.DailyQuests_UI
        GuiController:Open(questUI)

        -- Initialize quests if needed
        local success = pcall(function()
            local QuestsController = require(Services.ReplicatedStorage.Modules.QuestsController)
            local DataService = require(Services.ReplicatedStorage.Modules.DataService)
            local data = DataService:GetData()

            if data and data.DailyQuests and data.DailyQuests.ContainerId then
                local container = QuestsController:GetContainerFromId(data.DailyQuests.ContainerId)
                if container then
                    QuestsController:DisplayContainer(container)
                end
            end
        end)

        if success then
            Library:Notify("âœ… Opened daily quests!", 2)
        else
            Library:Notify("âš ï¸ Opened quests UI but failed to initialize", 2)
        end
    else
        Library:Notify("âŒ DailyQuests_UI not found!", 3)
    end
end)

-- ================================================================
-- EGGS GROUPBOX - Auto Buy Pet Eggs System (From Pet Tab)
-- ================================================================

-- Eggs GroupBox  
local EggsGroupBox = Tabs.Store:AddRightGroupbox("Eggs")

-- List of available pet eggs (exactly from GrowAGardenSloppyCoding)
local PetEggTypes = {
	"Common Egg",
	"Uncommon Egg",
	"Rare Egg",
	"Legendary Egg",
	"Mythical Egg",
	"Bug Egg",
	"Common Summer Egg",
	"Rare Summer Egg",
	"Paradise Egg"
}

-- Selected eggs for auto buying
local SelectedPetEggs = {}
local AutoBuyPetEggEnabled = false

-- Track purchased eggs to avoid buying the same egg multiple times
local PurchasedPetEggs = {}

-- Add multi-select dropdown for pet eggs
EggsGroupBox:AddDropdown("PetEggsList", {
	Values = PetEggTypes,
	Default = 1,
	Multi = true, -- Allow multiple selections

	Text = "Select Eggs to Buy",
	Tooltip = "Choose which pet eggs to automatically purchase",

	Callback = function(Value)
		print("[cb] Selected eggs for auto-buy:", Value)
		SelectedPetEggs = Value
	end,
})

-- Add toggle for auto-buying pet eggs
EggsGroupBox:AddToggle("AutoBuyPetEggs", {
	Text = "Auto Buy Pet Eggs",
	Tooltip = "Automatically purchase selected pet eggs when available",
	Default = false,
	Callback = function(Value)
		print("[cb] Auto Buy Pet Eggs toggled:", Value)
		AutoBuyPetEggEnabled = Value

		if Value then
			-- Start auto buying loop
			task.spawn(function()
				while AutoBuyPetEggEnabled and Toggles.AutoBuyPetEggs.Value do
					-- Check if any eggs are selected
					local hasSelectedEggs = false
					for eggName, selected in pairs(SelectedPetEggs) do
						if selected then
							hasSelectedEggs = true
							break
						end
					end

					if hasSelectedEggs then
						-- Try to buy all eggs of each selected type
						local eggTypesBought = {}

						for _, eggName in ipairs(PetEggTypes) do
							-- Check if this egg is selected
							if SelectedPetEggs[eggName] and AutoBuyPetEggEnabled and Toggles.AutoBuyPetEggs.Value then
								print("[DEBUG_LOG] Attempting to buy all eggs of type:", eggName)

								-- Attempt to buy all eggs of this type
								local success = buyPetEgg(eggName)

								if success then
									table.insert(eggTypesBought, eggName)
								end

								-- Wait between different egg types
								task.wait(1)
							end
						end
					end

					-- Wait before checking again
					task.wait(3)
				end
			end)
		end
	end,
})

-- Add button to manually buy selected eggs
EggsGroupBox:AddButton("Buy Selected Eggs Now", function()
	-- Try to buy all eggs of each selected type
	local totalEggsBought = 0
	local eggTypesBought = {}

	for _, eggName in ipairs(PetEggTypes) do
		-- Check if this egg is selected
		if SelectedPetEggs[eggName] then
			print("[DEBUG_LOG] Attempting to buy all eggs of type:", eggName)

			-- Attempt to buy all eggs of this type
			local success = buyPetEgg(eggName)

			if success then
				table.insert(eggTypesBought, eggName)
				totalEggsBought = totalEggsBought + 1
			end

			-- Wait between different egg types
			task.wait(1)
		end
	end

	-- Show a notification with the total number of egg types bought
	if totalEggsBought > 0 then
		local eggTypesText = table.concat(eggTypesBought, ", ")
		Library:Notify("Bought eggs of type(s): " .. eggTypesText, 3)
	else
		Library:Notify("No eggs purchased. Check selection or availability.", 3)
	end
end)

-- Add button to reset purchased eggs tracking
EggsGroupBox:AddButton("Reset Purchased Eggs Tracking", function()
	-- Clear the purchased eggs tracking
	PurchasedPetEggs = {}
	Library:Notify("Reset egg purchase tracking", 2)
end)

-- Function to automatically reset purchased eggs tracking when shop refreshes
local function resetPurchasedEggsOnShopRefresh()
	-- Check if the PetEggShopData module exists
	local success, PetEggShopData = pcall(function()
		return require(Services.ReplicatedStorage.Data.PetEggShopData)
	end)

	if not success or not PetEggShopData then
		print("[DEBUG_LOG] Could not load PetEggShopData module")
		return
	end

	-- Get the refresh time from the module
	local refreshTime = PetEggShopData.RefreshTime or 1800 -- Default to 30 minutes if not specified

	-- Start a loop to check for shop refresh
	task.spawn(function()
		while true do
			task.wait(refreshTime)
			-- Reset the purchased eggs tracking
			PurchasedPetEggs = {}
			print("[DEBUG_LOG] Shop refreshed, reset purchased eggs tracking")
		end
	end)
end

-- Start the auto-reset function
resetPurchasedEggsOnShopRefresh()

-- Function to buy a pet egg (exactly from GrowAGardenSloppyCoding)
function buyPetEgg(eggName)
	print("[DEBUG_LOG] Attempting to buy pet egg:", eggName)

	-- Access the shop data to find all eggs of the selected type
	local DataService = require(Services.ReplicatedStorage.Modules.DataService)
	local shopData = DataService:GetData().PetEggStock.Stocks

	if not shopData then
		print("[DEBUG_LOG] Could not access shop data")
		return false
	end

	-- Track if we bought any eggs
	local boughtAny = false
	local eggsBought = 0

	-- Iterate through all eggs in the shop
	for shopIndex, eggData in pairs(shopData) do
		-- Check if this egg matches the selected type
		if eggData.EggName == eggName then
			print("[DEBUG_LOG] Found egg in shop:", eggName, "at index:", shopIndex)

			-- Check if this specific egg has already been purchased
			if PurchasedPetEggs[shopIndex] then
				print("[DEBUG_LOG] Egg at index", shopIndex, "already purchased in this session")
				-- Continue to the next egg
			else
				-- Find the BuyPetEgg remote event
				local buyPetEgg = Services.ReplicatedStorage.GameEvents:FindFirstChild("BuyPetEgg")

				if buyPetEgg then
					-- Fire the remote event to buy the egg with the shop index
					print("[DEBUG_LOG] Sending buy request for egg at shop index:", shopIndex)

					-- Fire the remote event
					buyPetEgg:FireServer(shopIndex)

					-- Log additional information for debugging
					print("[DEBUG_LOG] Buy request sent for egg:", eggName, "with shop index:", shopIndex)

					-- Mark this specific egg as purchased in this session
					PurchasedPetEggs[shopIndex] = true

					-- Track that we bought at least one egg
					boughtAny = true
					eggsBought = eggsBought + 1

					-- Wait a bit before buying the next egg to avoid rate limiting
					task.wait(0.5)
				else
					-- Try alternative remote event names as fallback
					local alternativeEvents = {
						"BuyPetEggStock",
						"BuyEgg",
						"PurchaseEgg"
					}

					local usedAlternative = false

					for _, eventName in ipairs(alternativeEvents) do
						local event = Services.ReplicatedStorage.GameEvents:FindFirstChild(eventName)
						if event then
							print("[DEBUG_LOG] Using alternative event:", eventName, "for egg at shop index:", shopIndex)

							-- Fire the remote event
							event:FireServer(shopIndex)

							-- Log additional information for debugging
							print("[DEBUG_LOG] Buy request sent using alternative event:", eventName, "for egg:", eggName, "with shop index:", shopIndex)

							-- Mark this specific egg as purchased in this session
							PurchasedPetEggs[shopIndex] = true

							-- Track that we bought at least one egg
							boughtAny = true
							eggsBought = eggsBought + 1

							usedAlternative = true

							-- Wait a bit before buying the next egg to avoid rate limiting
							task.wait(0.5)

							break
						end
					end

					if not usedAlternative then
						print("[DEBUG_LOG] Could not find appropriate remote event to buy pet egg")
					end
				end
			end
		end
	end

	print("[DEBUG_LOG] Bought", eggsBought, "eggs of type:", eggName)

	return boughtAny
end

-- ================================================================
-- STORE TAB TABBOX SYSTEM (Summer Store & Additional Store)
-- ================================================================

-- Right Tabbox for Store Features  
local RightStoreTabBox = Tabs.Store:AddRightTabbox("Store Tabs")

-- Tab 1: Summer Store
local SummerStoreTab = RightStoreTabBox:AddTab("Summer Store")

-- Tab 2: Merchant Store
local MerchantStoreTab = RightStoreTabBox:AddTab("Merchant")

-- Combined merchant items from both Sky and Gnome merchants
local merchantItems = {
    -- Sky Merchant items
    "Night Staff",
    "Star Caller", 
    "Mutation Spray Cloudtouched",
    -- Gnome Merchant items
    "Common Gnome Crate",
    "Farmers Gnome Crate",
    "Classic Gnome Crate", 
    "Iconic Gnome Crate"
}

-- Initialize merchant variables
local merchantSelectedItems = {}
local merchantAutoBuyEnabled = false
local merchantAutoBuyConnection = nil

-- Get the merchant buy remote
local BuyTravelingMerchantShopStock = Services.ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("BuyTravelingMerchantShopStock")

-- Add elements directly to Merchant Store Tab (no groupbox needed in tabbox tabs)
MerchantStoreTab:AddLabel("ðŸª Merchant Store Auto Buy System")
MerchantStoreTab:AddDivider()

-- Dropdown for merchant item selection
MerchantStoreTab:AddDropdown("MerchantItemSelection", {
    Values = merchantItems,
    Default = 1,
    Multi = true, -- Allow multiple selections
    Text = "Select Merchant Items",
    Tooltip = "Choose which merchant store items to auto buy",
    Callback = function(Value)
        print("[cb] Selected merchant items for auto buy changed:")
        merchantSelectedItems = Value
        for item, selected in next, Options.MerchantItemSelection.Value do
            print(item, selected)
        end
    end
})

-- Function to buy merchant items using the provided remote
local function buyMerchantItems()
    if not merchantSelectedItems or not next(merchantSelectedItems) then
        print("âŒ No merchant items selected for purchase")
        return
    end
    
    for itemName, isSelected in pairs(merchantSelectedItems) do
        if isSelected and merchantAutoBuyEnabled then
            local success, err = pcall(function()
                BuyTravelingMerchantShopStock:FireServer(itemName)
            end)
            
            if success then
                print("âœ… Successfully bought:", itemName)
            else
                print("âŒ Failed to buy:", itemName, "Error:", err)
            end
            
            task.wait(0.1) -- Small delay between purchases
        end
    end
end

-- Auto Buy Merchant Items Toggle
MerchantStoreTab:AddToggle("AutoBuyMerchant", {
    Text = "Auto Buy Merchant Items",
    Default = false,
    Tooltip = "Automatically buy selected merchant store items continuously at 0.5s intervals",
    Callback = function(Value)
        merchantAutoBuyEnabled = Value
        if Value then
            -- Check if items are selected
            if not merchantSelectedItems or not next(merchantSelectedItems) then
                Toggles.AutoBuyMerchant:SetValue(false)
                return
            end

            local selectedCount = 0
            for _, selected in pairs(merchantSelectedItems) do
                if selected then selectedCount = selectedCount + 1 end
            end

            Library:Notify("ðŸª Auto Buy Merchant enabled! Will buy " .. selectedCount .. " selected items continuously.", 3)

            -- Start auto buy loop
            task.spawn(function()
                while merchantAutoBuyEnabled do
                    buyMerchantItems()
                    task.wait(0.5) -- Fixed 0.5s interval for merchant
                end
            end)
        else
            Library:Notify("ðŸª Auto Buy Merchant disabled!", 3)
        end
    end
})

-- Manual buy button
MerchantStoreTab:AddButton("ðŸª Buy Selected Items Now", function()
    if not merchantSelectedItems or not next(merchantSelectedItems) then
        return
    end
    buyMerchantItems()
end)

-- Select All Merchant Items button
MerchantStoreTab:AddButton("Select All Merchant Items", function()
    -- Select all items in the dropdown
    local allSelected = {}
    for _, item in pairs(merchantItems) do
        allSelected[item] = true
    end
    
    if Options.MerchantItemSelection then
        Options.MerchantItemSelection:SetValue(allSelected)
    end
    
    Library:Notify("âœ… Selected all merchant store items", 2)
end)

-- Clear All Selections button
MerchantStoreTab:AddButton("Clear All Selections", function()
    if Options.MerchantItemSelection then
        Options.MerchantItemSelection:SetValue({})
    end
    
    Library:Notify("ðŸ—‘ï¸ Cleared all merchant item selections", 2)
end)

-- ================================================================
-- SUMMER STORE SYSTEM
-- ================================================================

-- Global variables for Summer Store
local AutoBuySummerEnabled = false
local SelectedSummerItems = {}

-- All Summer Store items based on the provided remote examples
local AllSummerItems = {
    "Delphinium",
    "Lily of the Valley", 
    "Traveler's Fruit",
    "Mutation Spray Burnt",
    "Oasis Crate",
    "Oasis Egg",
    "Hamster",
    "Summer Seed Pack"
}

-- Add elements directly to Summer Store Tab (no groupbox needed in tabbox tabs)
SummerStoreTab:AddLabel("ðŸ›’ Summer Store Auto Buy System")
SummerStoreTab:AddDivider()

-- Dropdown for summer item selection
SummerStoreTab:AddDropdown("SummerItemSelection", {
    Values = AllSummerItems,
    Default = 1,
    Multi = true, -- Allow multiple selections
    Text = "Select Summer Items",
    Tooltip = "Choose which summer store items to auto buy",
    Callback = function(Value)
        print("[cb] Selected summer items for auto buy changed:")
        SelectedSummerItems = Value
        for item, selected in next, Options.SummerItemSelection.Value do
            print(item, selected)
        end
    end
})

-- Function to buy summer items using the provided remote
local function buySummerItems()
    if not SelectedSummerItems or not next(SelectedSummerItems) then
        print("âŒ No summer items selected for purchase")
        return
    end

    local BuyEventShopStock = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("BuyEventShopStock")
    
    for itemName, isSelected in pairs(SelectedSummerItems) do
        if isSelected and AutoBuySummerEnabled then
            local success, err = pcall(function()
                local args = {itemName}
                BuyEventShopStock:FireServer(unpack(args))
            end)
            
            if success then
                print("âœ… Successfully bought:", itemName)
            else
                print("âŒ Failed to buy:", itemName, "Error:", err)
            end
            
            task.wait(0.5) -- Small delay between purchases
        end
    end
end

-- Auto Buy Summer Items Toggle
SummerStoreTab:AddToggle("AutoBuySummer", {
    Text = "Auto Buy Summer Items",
    Default = false,
    Tooltip = "Automatically buy selected summer store items continuously until disabled",
    Callback = function(Value)
        AutoBuySummerEnabled = Value
        if Value then
            -- Check if items are selected
            if not SelectedSummerItems or not next(SelectedSummerItems) then
                Library:Notify("âš ï¸ Please select summer items first!", 3)
                Toggles.AutoBuySummer:SetValue(false)
                return
            end

            local selectedCount = 0
            for _, selected in pairs(SelectedSummerItems) do
                if selected then selectedCount = selectedCount + 1 end
            end

            Library:Notify("ðŸ›’ Auto Buy Summer enabled! Will buy " .. selectedCount .. " selected items continuously.", 3)

            -- Start auto buy loop
            task.spawn(function()
                while AutoBuySummerEnabled do
                    buySummerItems()
                    local interval = Options.SummerBuyInterval and Options.SummerBuyInterval.Value or 2
                    task.wait(interval) -- Use the slider value for interval
                end
            end)
        else
            Library:Notify("ðŸ›’ Auto Buy Summer disabled!", 3)
        end
    end
})

-- Manual buy button
SummerStoreTab:AddButton("ðŸ›’ Buy Selected Items Now", function()
    if not SelectedSummerItems or not next(SelectedSummerItems) then
        Library:Notify("âš ï¸ Please select summer items first!", 3)
        return
    end
    buySummerItems()
end)

-- Purchase interval slider
SummerStoreTab:AddSlider("SummerBuyInterval", {
    Text = "Buy Interval (seconds)",
    Default = 2,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Tooltip = "How often to attempt purchasing selected items (1-10 seconds)",
    Callback = function(Value)
        print("[cb] Summer buy interval changed to", Value, "seconds")
    end
})

-- Select All Summer Items button
SummerStoreTab:AddButton("Select All Summer Items", function()
    -- Select all items in the dropdown
    local allSelected = {}
    for _, item in pairs(AllSummerItems) do
        allSelected[item] = true
    end
    
    if Options.SummerItemSelection then
        Options.SummerItemSelection:SetValue(allSelected)
    end
    
    Library:Notify("âœ… Selected all summer store items", 2)
end)

-- Clear All Selections button
SummerStoreTab:AddButton("Clear All Selections", function()
    if Options.SummerItemSelection then
        Options.SummerItemSelection:SetValue({})
    end
    
    Library:Notify("ðŸ—‘ï¸ Cleared all summer item selections", 2)
end)

-- ================================================================
-- EVENT TAB STRUCTURE - Collect Summer Plants System
-- ================================================================

-- Collect Summer Plants GroupBox
local CollectSummerPlantsGroupBox = Tabs.Event:AddLeftGroupbox("Collect Summer Plants")

-- Global variables for Summer Plant Collection
local AutoCollectSummerPlantsEnabled = false
local SelectedSummerPlantsToCollect = {}

-- All Summer Plants (based on PlantTraitsData.Summer from the game)
local AllSummerPlants = {
    "Aloe Vera", "Avocado", "Banana", "Bell Pepper", "Blueberry", "Burning Bud",
    "Cantaloupe", "Carrot", "Cauliflower", "Delphinium", "Elephant Ears", "Feijoa",
    "Green Apple", "Guanabana", "Kiwi", "Lily of the Valley", "Loquat", "Parasol Flower",
    "Peace Lily", "Pear", "Pineapple", "Pitcher Plant", "Prickly Pear", "Rafflesia",
    "Rosy Delight", "Strawberry", "Sugar Apple", "Tomato", "Traveler's Fruit",
    "Watermelon", "White Mullberry", "Wild Carrot"
}

-- Function to get player's farm (same as Auto Farm tab)
local function getMyFarmForSummer()
    for _, farm in workspace.Farm:GetChildren() do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data.Owner.Value == LocalPlayer.Name then
                return farm
            end
        end
    end
    return nil
end

-- Function to harvest/collect a plant
local function harvestSummerPlant(plant)
    local success, result = pcall(function()
        -- Find the ProximityPrompt for harvesting
        local prompt = plant:FindFirstChild("ProximityPrompt", true)
        if not prompt then
            print("âŒ No ProximityPrompt found for:", plant.Name)
            return false
        end

        if not prompt.Enabled then
            print("â³ Plant not ready for harvest:", plant.Name)
            return false
        end

        -- Teleport to the plant
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local plantPosition = plant.PrimaryPart and plant.PrimaryPart.Position or plant:GetModelCFrame().Position
            LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(plantPosition + Vector3.new(0, 5, 0))
            task.wait(0.5) -- Wait for teleport
        end

        -- Trigger the harvest
        if prompt and prompt.Enabled then
            print("ðŸŒ± Harvesting:", plant.Name)
            fireproximityprompt(prompt)
            task.wait(0.5)
            return true
        end

        return false
    end)

    if success then
        return result
    else
        print("âŒ Error harvesting plant:", result)
        return false
    end
end

-- Function to find and collect summer plants
local function collectSummerPlants()
    if not AutoCollectSummerPlantsEnabled then
        return
    end

    -- Get player's farm
    local myFarm = getMyFarmForSummer()
    if not myFarm then
        print("âŒ No farm found")
        Library:Notify("âŒ Could not find your farm!", 3)
        return
    end

    local important = myFarm:FindFirstChild("Important")
    local plantsPhysical = important and important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("âŒ No plants found in farm")
        Library:Notify("âŒ No plants found in your farm!", 3)
        return
    end

    print("ðŸŒž Searching for summer plants to collect...")

    local originalPosition = nil
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        originalPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
    end

    local collectedCount = 0
    local totalSummerPlants = 0

    -- Process each plant in the farm
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        if not AutoCollectSummerPlantsEnabled then break end

        -- Check if this is a summer plant we want to collect
        local isSummerPlant = false
        local plantName = plant.Name

        for _, summerPlantName in pairs(AllSummerPlants) do
            if string.find(plantName, summerPlantName) then
                isSummerPlant = true
                break
            end
        end

        if isSummerPlant then
            -- Check if player has selected this plant type or if no specific selection
            local shouldCollect = false
            
            if not next(SelectedSummerPlantsToCollect) then
                -- No specific selection, collect all summer plants
                shouldCollect = true
            else
                -- Check if this plant type is selected
                for selectedPlant, selected in pairs(SelectedSummerPlantsToCollect) do
                    if selected and string.find(plantName, selectedPlant) then
                        shouldCollect = true
                        break
                    end
                end
            end

            if shouldCollect then
                totalSummerPlants = totalSummerPlants + 1
                print("ðŸŒž Found summer plant:", plantName)

                -- Look for fruits/collectibles in this plant
                local fruitsFolder = plant:FindFirstChild("Fruits")
                if fruitsFolder then
                    for _, fruit in pairs(fruitsFolder:GetChildren()) do
                        if not AutoCollectSummerPlantsEnabled then break end

                        local success = harvestSummerPlant(fruit)
                        if success then
                            collectedCount = collectedCount + 1
                            Library:Notify("âœ… Collected " .. fruit.Name, 1)
                        end
                        task.wait(0.3) -- Delay between collections
                    end
                else
                    -- Try to harvest the plant itself if no fruits folder
                    local success = harvestSummerPlant(plant)
                    if success then
                        collectedCount = collectedCount + 1
                        Library:Notify("âœ… Collected " .. plant.Name, 1)
                    end
                    task.wait(0.3)
                end
            end
        end

        task.wait(0.1) -- Small delay between plants
    end

    -- Return to original position
    if originalPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = originalPosition
    end

    if collectedCount > 0 then
        Library:Notify("ðŸŒž Collected " .. collectedCount .. " summer plants/fruits and returned!", 3)
    else
        if totalSummerPlants > 0 then
            Library:Notify("ðŸŒž Found " .. totalSummerPlants .. " summer plants but none were ready to harvest", 3)
        else
            Library:Notify("âŒ No summer plants found in your farm!", 3)
        end
    end
end

-- Summer Plants Selection Dropdown
CollectSummerPlantsGroupBox:AddDropdown("SummerPlantsToCollect", {
    Values = AllSummerPlants,
    Default = 1,
    Multi = true, -- Allow multiple selections
    Text = "Select Summer Plants",
    Tooltip = "Choose which summer plants to automatically collect. Leave empty to collect all summer plants.",
    Callback = function(Value)
        SelectedSummerPlantsToCollect = Value
        print("[cb] Selected summer plants for collection changed:")
        for plant, selected in next, Options.SummerPlantsToCollect.Value do
            print(plant, selected)
        end
    end,
})

-- Auto Collect Summer Plants Toggle
CollectSummerPlantsGroupBox:AddToggle("AutoCollectSummerPlants", {
    Text = "Auto Collect Summer Plants",
    Tooltip = "Automatically teleport to and collect mature summer plants/fruits from your farm",
    Default = false,
    Callback = function(Value)
        print("[cb] Auto Collect Summer Plants toggled:", Value)
        AutoCollectSummerPlantsEnabled = Value
        
        if Value then
            -- Check if any plants are selected
            local selectedCount = 0
            if SelectedSummerPlantsToCollect then
                for _, selected in pairs(SelectedSummerPlantsToCollect) do
                    if selected then selectedCount = selectedCount + 1 end
                end
            end

            if selectedCount > 0 then
                Library:Notify("ðŸŒž Auto Collect Summer Plants enabled! (" .. selectedCount .. " types selected)", 3)
            else
                Library:Notify("ðŸŒž Auto Collect Summer Plants enabled! (All summer plants)", 3)
            end

            -- Start auto collection loop
            task.spawn(function()
                while AutoCollectSummerPlantsEnabled do
                    if AutoCollectSummerPlantsEnabled then
                        collectSummerPlants()
                    end
                    
                    -- Wait between collection cycles
                    for i = 1, 20 do -- 10 seconds total wait
                        if not AutoCollectSummerPlantsEnabled then
                            break
                        end
                        task.wait(0.5)
                    end
                end
                print("Summer plant collection loop ended")
            end)
        else
            Library:Notify("ðŸŒž Auto Collect Summer Plants disabled!", 3)
        end
    end,
})

-- Select All Summer Plants Button
CollectSummerPlantsGroupBox:AddButton("Select All Summer Plants", function()
    -- Select all items in the dropdown
    local allSelected = {}
    for _, plant in pairs(AllSummerPlants) do
        allSelected[plant] = true
    end
    
    if Options.SummerPlantsToCollect then
        Options.SummerPlantsToCollect:SetValue(allSelected)
    end
    
    Library:Notify("âœ… Selected all " .. #AllSummerPlants .. " summer plants", 2)
end)

-- Clear Summer Plants Selection Button
CollectSummerPlantsGroupBox:AddButton("Clear Selection", function()
    if Options.SummerPlantsToCollect then
        Options.SummerPlantsToCollect:SetValue({})
    end
    
    Library:Notify("ðŸ—‘ï¸ Cleared summer plants selection", 2)
end)

-- ================================================================
-- AUTO GIVE SUMMER PLANT GROUPBOX (Right side of Event tab)
-- ================================================================
local AutoGiveSummerPlantGroupBox = Tabs.Event:AddRightGroupbox("Auto Give Summer Plant")

-- Global variables for Auto Give Summer Plant
local AutoGiveSummerPlantEnabled = false
local SelectedSummerFruitsToGive = {}

-- Get the summer harvest remote
local SummerHarvestRemoteEvent = Services.ReplicatedStorage.GameEvents:WaitForChild("SummerHarvestRemoteEvent")

-- All available summer fruits that can be submitted (from AllSummerPlants list)
local SummerFruitsToSubmit = {
    "Aloe Vera", "Avocado", "Banana", "Bell Pepper", "Blueberry", "Burning Bud",
    "Cantaloupe", "Carrot", "Cauliflower", "Delphinium", "Elephant Ears", "Feijoa",
    "Green Apple", "Guanabana", "Kiwi", "Lily of the Valley", "Loquat", "Parasol Flower",
    "Peace Lily", "Pear", "Pineapple", "Pitcher Plant", "Prickly Pear", "Rafflesia",
    "Rosy Delight", "Strawberry", "Sugar Apple", "Tomato", "Traveler's Fruit",
    "Watermelon", "White Mullberry", "Wild Carrot"
}

-- Function to check if Summer Harvest Event is currently active
local function IsSummerHarvestEventActive()
    local success, result = pcall(function()
        local uiFound = false
        local eventsFound = false
        local workspaceFound = false
        local npcFound = false
        local remoteFound = false
        
        -- Method 1: Check for Summer Harvest UI presence and visibility
        local summerUI = LocalPlayer.PlayerGui:FindFirstChild("SummerHarvestEvent_UI")
        if summerUI then
            -- Check if the UI is actually visible and enabled
            if summerUI.Enabled and summerUI.Visible then
                -- Check if the main frame is visible too
                local mainFrame = summerUI:FindFirstChild("MainFrame") or summerUI:FindFirstChild("Frame") or summerUI:FindFirstChild("Background")
                if mainFrame and mainFrame.Visible then
                    print("âœ… Summer Harvest UI found, enabled, and visible")
                    uiFound = true
                else
                    print("âš ï¸ Summer Harvest UI found but main frame is not visible")
                end
            else
                print("âš ï¸ Summer Harvest UI found but not enabled/visible")
            end
        else
            print("âŒ Summer Harvest UI not found")
        end
        
        -- Method 2: Check for active summer harvest event in game data with specific name matching
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()
        
        if data and data.ActiveEvents then
            for eventName, eventData in pairs(data.ActiveEvents) do
                local lowerEventName = string.lower(eventName)
                -- More specific matching for summer harvest event
                if (string.find(lowerEventName, "summer") and string.find(lowerEventName, "harvest")) or
                   lowerEventName == "summerharvest" or
                   lowerEventName == "summer_harvest" or
                   lowerEventName == "summerharvestevent" then
                    print("âœ… Active Summer Harvest event found in data:", eventName)
                    -- Check if event data indicates it's actually active
                    if eventData and eventData.Active ~= false then
                        eventsFound = true
                        break
                    else
                        print("âš ï¸ Summer Harvest event found but marked as inactive")
                    end
                end
            end
            if not eventsFound then
                print("âŒ No specific Summer Harvest event found in ActiveEvents")
            end
        else
            print("âŒ No ActiveEvents data found")
        end
        
        -- Method 3: Check workspace for summer harvest event objects/NPCs (informational only)
        local summerEventObjects = workspace:FindFirstChild("SummerHarvestEvent") or 
                                   workspace:FindFirstChild("SummerEvent") or
                                   workspace:FindFirstChild("SummerHarvest")
        if summerEventObjects then
            print("âœ… Summer Harvest event objects found in workspace")
            workspaceFound = true
        else
            print("âŒ No Summer Harvest event objects found in workspace")
        end
        
        -- Method 4: Check for summer harvest NPC or interaction points (informational only)
        local npcs = workspace:FindFirstChild("NPCS")
        if npcs then
            local summerNPC = npcs:FindFirstChild("Summer Harvest NPC") or 
                              npcs:FindFirstChild("SummerHarvestNPC") or
                              npcs:FindFirstChild("Summer_Harvest_NPC")
            if summerNPC then
                print("âœ… Summer Harvest NPC found")
                npcFound = true
            else
                print("âŒ No Summer Harvest NPC found")
            end
        end
        
        -- Method 5: Check if summer harvest remote exists (informational only)
        local summerRemote = Services.ReplicatedStorage.GameEvents:FindFirstChild("SummerHarvestRemoteEvent")
        if summerRemote then
            print("âœ… Summer Harvest Remote Event exists")
            remoteFound = true
        else
            print("âŒ Summer Harvest Remote Event not found")
        end
        
        -- REFINED LOGIC: Only return true if UI is visible OR ActiveEvents confirms the event
        -- Workspace objects, NPCs, and remotes alone are NOT sufficient evidence
        local isActive = uiFound or eventsFound
        
        print("--- DETECTION SUMMARY ---")
        print("UI Active:", uiFound and "âœ…" or "âŒ")
        print("ActiveEvents Found:", eventsFound and "âœ…" or "âŒ") 
        print("Workspace Objects:", workspaceFound and "âœ…" or "âŒ", "(informational)")
        print("Summer NPCs:", npcFound and "âœ…" or "âŒ", "(informational)")
        print("Remote Exists:", remoteFound and "âœ…" or "âŒ", "(informational)")
        print("FINAL DECISION:", isActive and "ðŸŸ¢ EVENT IS ACTIVE" or "ðŸ”´ EVENT IS INACTIVE")
        print("REASONING: Only UI visibility or confirmed ActiveEvents data can indicate an active event")
        
        return isActive
    end)
    
    if success then
        return result
    else
        print("âŒ Error checking summer harvest event status:", result)
        return false -- If error, assume event is not active
    end
end

-- Function to get player's available summer fruits
local function getPlayerSummerFruits()
    local fruits = {}

    -- Check character inventory
    if LocalPlayer.Character then
        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") and tool:HasTag("FruitTool") then
                -- Check if this fruit is a summer fruit
                for _, summerFruit in pairs(SummerFruitsToSubmit) do
                    if string.find(tool.Name, summerFruit) then
                        table.insert(fruits, tool.Name)
                        break
                    end
                end
            end
        end
    end

    -- Check backpack
    if LocalPlayer.Backpack then
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool:HasTag("FruitTool") then
                -- Check if this fruit is a summer fruit
                for _, summerFruit in pairs(SummerFruitsToSubmit) do
                    if string.find(tool.Name, summerFruit) then
                        table.insert(fruits, tool.Name)
                        break
                    end
                end
            end
        end
    end

    -- Remove duplicates
    local uniqueFruits = {}
    local seen = {}
    for _, fruit in pairs(fruits) do
        if not seen[fruit] then
            seen[fruit] = true
            table.insert(uniqueFruits, fruit)
        end
    end

    return uniqueFruits
end

-- Function to submit summer fruits
local function submitSummerFruits()
    if not AutoGiveSummerPlantEnabled then
        return
    end

    -- Check if summer harvest event is currently active
    if not IsSummerHarvestEventActive() then
        print("âŒ Summer Harvest Event is not active - skipping submission")
        Library:Notify("â¸ï¸ Summer Harvest Event not active - waiting for event to start...", 2)
        return false
    end

    print("=== SUBMITTING SUMMER FRUITS ===")
    print("âœ… Summer Harvest Event is active - proceeding with submission")

    -- Get available summer fruits
    local availableFruits = {}
    for fruitName, selected in pairs(SelectedSummerFruitsToGive) do
        if selected then
            -- Check if player has this fruit in inventory
            local hasFruit = false
            local fruitTool = nil

            -- Check character first
            if LocalPlayer.Character then
                for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
                    if tool:IsA("Tool") and tool:HasTag("FruitTool") and string.find(tool.Name, fruitName) then
                        fruitTool = tool
                        hasFruit = true
                        break
                    end
                end
            end

            -- Check backpack if not found in character
            if not hasFruit and LocalPlayer.Backpack then
                for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                    if tool:IsA("Tool") and tool:HasTag("FruitTool") and string.find(tool.Name, fruitName) then
                        fruitTool = tool
                        hasFruit = true
                        break
                    end
                end
            end

            if hasFruit and fruitTool then
                table.insert(availableFruits, { name = fruitName, tool = fruitTool })
            end
        end
    end

    print("Available summer fruits to submit:", #availableFruits)
    for i, fruit in pairs(availableFruits) do
        print("Fruit #" .. i .. ":", fruit.name)
    end

    if #availableFruits == 0 then
        print("No selected summer fruits available in inventory")
        Library:Notify("âŒ No selected summer fruits found in inventory!", 3)
        return false
    end

    local submittedCount = 0

    -- Submit each fruit type
    for fruitIndex, fruitData in pairs(availableFruits) do
        if not AutoGiveSummerPlantEnabled then
            break
        end

        print("=== SUBMITTING FRUIT #" .. fruitIndex .. ": " .. fruitData.name .. " ===")

        -- Equip the fruit if not already equipped
        if fruitData.tool.Parent ~= LocalPlayer.Character then
            print("Equipping fruit:", fruitData.name)
            LocalPlayer.Character.Humanoid:EquipTool(fruitData.tool)
            task.wait(0.3) -- Wait for equip (reduced from 1 second)
        end

        -- Verify fruit is equipped
        local currentTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
        if not currentTool or not currentTool:HasTag("FruitTool") then
            print("ERROR: Failed to equip fruit", fruitData.name)
            Library:Notify("âŒ Failed to equip " .. fruitData.name, 2)
            continue
        end

        print("Successfully equipped:", currentTool.Name)

        -- Submit the fruit using the remote
        local success, err = pcall(function()
            SummerHarvestRemoteEvent:FireServer("SubmitHeldPlant")
        end)

        if success then
            submittedCount = submittedCount + 1
            print("âœ… Successfully submitted:", fruitData.name)
            Library:Notify("âœ… Submitted " .. fruitData.name, 2)
        else
            print("âŒ Failed to submit:", fruitData.name, "Error:", err)
            Library:Notify("âŒ Failed to submit " .. fruitData.name, 3)
        end

        -- Wait between different fruit submissions
        if AutoGiveSummerPlantEnabled and fruitIndex < #availableFruits then
            task.wait(0.5) -- Reduced from 2 seconds for faster submission
        end
    end

    print("=== SUBMISSION COMPLETE ===")
    print("Submitted", submittedCount, "out of", #availableFruits, "fruits")

    if submittedCount > 0 then
        Library:Notify("ðŸŒž Successfully submitted " .. submittedCount .. " summer fruits!", 3)
    else
        Library:Notify("âŒ No summer fruits were submitted", 3)
    end

    return submittedCount > 0
end

-- Auto submit summer fruits loop
local function autoSubmitSummerFruits()
    if not AutoGiveSummerPlantEnabled then
        return
    end

    task.spawn(function()
        while AutoGiveSummerPlantEnabled do
            -- Check if summer harvest event is active
            if IsSummerHarvestEventActive() then
                -- Event is active, proceed with submission
                submitSummerFruits()
                
                -- Very short wait between cycles when event is active for fast submission
                task.wait(0.5) -- Reduced from 2 seconds to 0.5 seconds
            else
                -- Event is not active, wait longer and check again
                print("â¸ï¸ Summer Harvest Event not active - waiting for event to start...")
                
                -- Wait when event is inactive (check every 5 seconds instead of 10)
                task.wait(5) -- Reduced from 10 seconds to 5 seconds
            end
        end
        print("Auto submit summer fruits loop ended")
    end)
end

-- Summer Fruits Selection Dropdown
AutoGiveSummerPlantGroupBox:AddDropdown("SummerFruitsToGive", {
    Values = SummerFruitsToSubmit,
    Default = 1,
    Multi = true, -- Allow multiple selections
    Text = "Select Summer Fruits",
    Tooltip = "Choose which summer fruits to automatically submit for the summer harvest event",
    Callback = function(Value)
        SelectedSummerFruitsToGive = Value
        print("[cb] Selected summer fruits for submission changed:")
        for fruit, selected in next, Options.SummerFruitsToGive.Value do
            print(fruit, selected)
        end
    end,
})

-- Auto Give Summer Plant Toggle
AutoGiveSummerPlantGroupBox:AddToggle("AutoGiveSummerPlant", {
    Text = "Auto Give Summer Plant",
    Tooltip = "Automatically equip and submit selected summer fruits when the summer harvest event is active",
    Default = false,
    Callback = function(Value)
        print("[cb] Auto Give Summer Plant toggled:", Value)
        AutoGiveSummerPlantEnabled = Value
        
        if Value then
            -- Check if summer harvest event is currently active
            local isEventActive = IsSummerHarvestEventActive()
            
            -- Check if any fruits are selected
            local selectedCount = 0
            if SelectedSummerFruitsToGive then
                for _, selected in pairs(SelectedSummerFruitsToGive) do
                    if selected then selectedCount = selectedCount + 1 end
                end
            end

            if selectedCount > 0 then
                if isEventActive then
                    Library:Notify("ðŸŒž Auto Give Summer Plant enabled! (" .. selectedCount .. " types selected) - Event is ACTIVE!", 3)
                else
                    Library:Notify("ðŸŒž Auto Give Summer Plant enabled! (" .. selectedCount .. " types selected) - Waiting for event to start...", 3)
                end
            else
                if isEventActive then
                    Library:Notify("ðŸŒž Auto Give Summer Plant enabled! (All summer fruits) - Event is ACTIVE!", 3)
                else
                    Library:Notify("ðŸŒž Auto Give Summer Plant enabled! (All summer fruits) - Waiting for event to start...", 3)
                end
            end

            -- Show current event status
            if isEventActive then
                Library:Notify("âœ… Summer Harvest Event is currently ACTIVE - submissions will start immediately!", 2)
            else
                Library:Notify("â¸ï¸ Summer Harvest Event is not active - will auto-start when event begins!", 2)
            end

            -- Start auto submission loop
            autoSubmitSummerFruits()
        else
            Library:Notify("ðŸŒž Auto Give Summer Plant disabled!", 3)
        end
    end,
})

-- Select All Summer Fruits Button
AutoGiveSummerPlantGroupBox:AddButton("Select All Summer Fruits", function()
    -- Select all items in the dropdown
    local allSelected = {}
    for _, fruit in pairs(SummerFruitsToSubmit) do
        allSelected[fruit] = true
    end
    
    if Options.SummerFruitsToGive then
        Options.SummerFruitsToGive:SetValue(allSelected)
    end
    
    Library:Notify("âœ… Selected all " .. #SummerFruitsToSubmit .. " summer fruits", 2)
end)

-- Clear Summer Fruits Selection Button
AutoGiveSummerPlantGroupBox:AddButton("Clear Selection", function()
    if Options.SummerFruitsToGive then
        Options.SummerFruitsToGive:SetValue({})
    end
    
    Library:Notify("ðŸ—‘ï¸ Cleared summer fruits selection", 2)
end)

-- ================================================================
-- ESSENTIAL TAB STRUCTURE (Sell & Future Features)
-- ================================================================

-- Essential Tabbox for Essential Features
local EssentialTabBox = Tabs.Essential:AddLeftTabbox("Essential Features")

-- Tab 1: Sell
local SellTab = EssentialTabBox:AddTab("Sell")

-- Tab 2: Player Tab
local PlayerTab = EssentialTabBox:AddTab("Player")

-- ================================================================
-- AUTO FEED PET GROUPBOX (Right side of Essential tab)
-- ================================================================
local AutoFeedPetGroupBox = Tabs.Essential:AddRightGroupbox("Auto Feed Pet")

-- Global variables for Auto Feed Pet
local AutoFeedPetEnabled = false
local SelectedPlantsToFeed = {}

-- Pet Services
local function getPetServices()
    local success, result = pcall(function()
        if Services.ReplicatedStorage:FindFirstChild("Modules") and Services.ReplicatedStorage.Modules:FindFirstChild("PetServices") then
            local PetServices = Services.ReplicatedStorage.Modules.PetServices
            local ActivePetsService = require(PetServices:FindFirstChild("ActivePetsService"))
            local PetsService = require(PetServices:FindFirstChild("PetsService"))
            return {
                ActivePetsService = ActivePetsService,
                PetsService = PetsService,
            }
        end
        return nil
    end)
    if success then
        return result
    else
        return nil
    end
end

-- Check if a specific pet needs food
local function petNeedsFood(petUUID)
    local success, result = pcall(function()
        -- Get current pet data
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()

        if not data or not data.PetsData then
            print("No PetsData found for hunger check")
            return true -- If we can't check, assume it needs food
        end

        -- Find the pet in inventory data
        local petInventory = data.PetsData.PetInventory
        if not petInventory or not petInventory.Data then
            print("No PetInventory found for hunger check")
            return true
        end

        local petData = petInventory.Data[petUUID]
        if not petData then
            print("Pet data not found for UUID:", petUUID)
            return true
        end

        -- Get pet type data for DefaultHunger
        local PetRegistry = require(Services.ReplicatedStorage.Data.PetRegistry)
        local PetList = PetRegistry.PetList
        local petTypeData = PetList[petData.PetType]

        if not petTypeData then
            print("Pet type data not found for:", petData.PetType)
            return true
        end

        local defaultHunger = petTypeData.DefaultHunger or 100
        local currentHunger = petData.PetData.Hunger or 0
        local hungerPercentage = currentHunger / defaultHunger

        print(
            "Hunger check for",
            petData.PetType,
            "- Current:",
            currentHunger,
            "Max:",
            defaultHunger,
            "Percentage:",
            math.floor(hungerPercentage * 100) .. "%"
        )

        -- Adjust threshold - pets need food if they're below 90% fed
        local needsFood = hungerPercentage < 0.9
        print("Pet needs food:", needsFood, "(threshold: 90%)")

        return needsFood
    end)

    if success then
        return result
    else
        print("Error checking pet hunger:", result)
        return true -- If error checking, assume it needs food
    end
end

-- Get player's active pets using the new ActivePetsService
local function getActivePets()
    local petServices = getPetServices()
    if not petServices then
        return {}
    end

    local success, result = pcall(function()
        local activePets = {}

        -- Get data service for pet data
        local DataService = require(Services.ReplicatedStorage.Modules.DataService)
        local data = DataService:GetData()

        if not data or not data.PetsData then
            print("No PetsData found")
            return {}
        end

        -- Get PetRegistry for pet type data (needed for DefaultHunger)
        local PetRegistry = require(Services.ReplicatedStorage.Data.PetRegistry)
        local PetList = PetRegistry.PetList

        -- Get ActivePetsService for the new pet system
        local ActivePetsService = petServices.ActivePetsService

        -- Method 1: Use ActivePetsService:GetClientPetState to get active pets
        print("=== Getting pets from ActivePetsService ===")
        local clientPetState = ActivePetsService:GetClientPetState(LocalPlayer.Name)
        print("Client pet state:", clientPetState and "found" or "nil")

        if clientPetState then
            for petUUID, petState in pairs(clientPetState) do
                print("Found active pet UUID:", petUUID)
                
                -- Get pet data from ActivePetsService
                local petData = ActivePetsService:GetPetData(LocalPlayer.Name, petUUID)
                print("Pet data for", petUUID, ":", petData and "found" or "nil")

                if petData then
                    -- Get pet type data for DefaultHunger
                    local petTypeData = PetList[petData.PetType]
                    local defaultHunger = petTypeData and petTypeData.DefaultHunger or 100
                    local currentHunger = petData.PetData.Hunger or 0
                    local hungerPercentage = currentHunger / defaultHunger

                    -- More strict threshold - only feed if less than 90% full
                    local needsFood = hungerPercentage < 0.9

                    print("Pet hunger analysis:")
                    print("- Type:", petData.PetType)
                    print("- UUID:", petUUID)
                    print("- Current hunger:", currentHunger)
                    print("- Max hunger:", defaultHunger)
                    print("- Hunger percentage:", math.floor(hungerPercentage * 100) .. "%")
                    print("- Needs food:", needsFood, "(threshold: 90%)")

                    table.insert(activePets, {
                        uuid = petUUID,
                        petType = petData.PetType or "Unknown",
                        petData = petData.PetData,
                        isEquipped = true,
                        currentHunger = currentHunger,
                        maxHunger = defaultHunger,
                        hungerPercentage = hungerPercentage,
                        needsFood = needsFood,
                        clientState = petState, -- Include the client state for reference
                    })
                end
            end
        end

        -- Method 2: Also check workspace for pet objects with proper attributes (as backup)
        print("=== Scanning workspace for additional pets ===")
        for _, obj in pairs(workspace:GetDescendants()) do
            if
                obj:GetAttribute("OWNER") == LocalPlayer.Name
                and obj:GetAttribute("UUID")
                and obj:HasTag("PetTargetable")
            then
                local petUUID = obj:GetAttribute("UUID")
                
                -- Check if we already have this pet from ActivePetsService
                local alreadyHave = false
                for _, existing in pairs(activePets) do
                    if existing.uuid == petUUID then
                        alreadyHave = true
                        existing.object = obj -- Add the physical object reference
                        break
                    end
                end

                if not alreadyHave then
                    print("Found workspace pet not in ActivePetsService:", petUUID)
                    
                    -- Try to get pet data from ActivePetsService
                    local petData = ActivePetsService:GetPetData(LocalPlayer.Name, petUUID)
                    
                    if petData then
                        -- Get pet type data for DefaultHunger
                        local petTypeData = PetList[petData.PetType]
                        local defaultHunger = petTypeData and petTypeData.DefaultHunger or 100
                        local currentHunger = petData.PetData.Hunger or 0
                        local hungerPercentage = currentHunger / defaultHunger
                        local needsFood = hungerPercentage < 0.9

                        table.insert(activePets, {
                            uuid = petUUID,
                            petType = petData.PetType or "Unknown",
                            petData = petData.PetData,
                            object = obj,
                            isEquipped = true,
                            currentHunger = currentHunger,
                            maxHunger = defaultHunger,
                            hungerPercentage = hungerPercentage,
                            needsFood = needsFood,
                        })
                    else
                        -- Fallback: check hunger individually using old method
                        local stillNeedsFood = petNeedsFood(petUUID)
                        print("Workspace pet hunger check:", petUUID, "needs food:", stillNeedsFood)

                        table.insert(activePets, {
                            uuid = petUUID,
                            petType = obj:GetAttribute("PetType") or "Unknown",
                            object = obj,
                            isEquipped = true,
                            currentHunger = 0,
                            maxHunger = 100,
                            hungerPercentage = 0,
                            needsFood = stillNeedsFood,
                        })
                    end
                end
            end
        end

        print("Total active pets found:", #activePets)
        -- Show hunger status for each pet
        for i, pet in pairs(activePets) do
            local hungerStatus = math.floor(pet.hungerPercentage * 100)
            print(
                "Pet #"
                .. i
                .. " ("
                .. pet.petType
                .. ") - Hunger: "
                .. hungerStatus
                .. "% ("
                .. pet.currentHunger
                .. "/"
                .. pet.maxHunger
                .. ") - Needs food: "
                .. tostring(pet.needsFood)
            )
        end

        return activePets
    end)

    if success then
        return result
    else
        print("Error getting active pets:", result)
        return {}
    end
end

-- Get player's fruit/plant inventory
local function getPlayerFruits()
    local fruits = {}

    -- Check character inventory
    if LocalPlayer.Character then
        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") and tool:HasTag("FruitTool") then
                table.insert(fruits, tool.Name)
            end
        end
    end

    -- Check backpack
    if LocalPlayer.Backpack then
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and tool:HasTag("FruitTool") then
                table.insert(fruits, tool.Name)
            end
        end
    end

    -- Remove duplicates
    local uniqueFruits = {}
    local seen = {}
    for _, fruit in pairs(fruits) do
        if not seen[fruit] then
            seen[fruit] = true
            table.insert(uniqueFruits, fruit)
        end
    end

    return uniqueFruits
end

-- Feed pets with selected plants
local function feedPetsWithPlants()
    local petServices = getPetServices()
    if not petServices then
        print("Pet services not available")
        return false
    end

    local activePets = getActivePets()
    print("=== FEEDING PETS ===")
    print("Active pets found:", #activePets)

    if #activePets == 0 then
        print("No active pets found")
        Library:Notify("âŒ No active pets found!", 3)
        return false
    end

    -- Filter pets that actually need food
    local hungryPets = {}
    for i, pet in pairs(activePets) do
        local hungerStatus = math.floor(pet.hungerPercentage * 100)
        print(
            "Pet #"
            .. i
            .. " ("
            .. pet.petType
            .. ") - Hunger: "
            .. hungerStatus
            .. "% - Needs food: "
            .. tostring(pet.needsFood)
        )

        if pet.needsFood then
            table.insert(hungryPets, pet)
            print("âœ… Pet #" .. i .. " needs food (hunger: " .. hungerStatus .. "%)")
        else
            print("â­ï¸ Pet #" .. i .. " is well-fed (hunger: " .. hungerStatus .. "%) - skipping")
            Library:Notify(
                "â­ï¸ Pet #" .. i .. " (" .. pet.petType .. ") is well-fed (" .. hungerStatus .. "%) - skipping",
                1
            )
        end
    end

    print("Hungry pets that need feeding:", #hungryPets, "out of", #activePets, "total pets")

    if #hungryPets == 0 then
        print("No pets need feeding - all are well-fed!")
        Library:Notify("ðŸŽ‰ All pets are well-fed! No feeding needed.", 3)
        return false
    end

    -- Check if player has any selected fruits
    local availableFruits = {}
    for plantName, selected in pairs(SelectedPlantsToFeed) do
        if selected then
            -- Check if player has this fruit in inventory
            local hasFruit = false
            local fruitTool = nil

            -- Check character first
            if LocalPlayer.Character then
                for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
                    if tool:IsA("Tool") and tool:HasTag("FruitTool") and tool.Name == plantName then
                        hasFruit = true
                        fruitTool = tool
                        break
                    end
                end
            end

            -- Check backpack if not found in character
            if not hasFruit and LocalPlayer.Backpack then
                for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                    if tool:IsA("Tool") and tool:HasTag("FruitTool") and tool.Name == plantName then
                        fruitTool = tool
                        hasFruit = true
                        break
                    end
                end
            end

            if hasFruit and fruitTool then
                table.insert(availableFruits, { name = plantName, tool = fruitTool })
            end
        end
    end

    print("Available fruits:", #availableFruits)
    for i, fruit in pairs(availableFruits) do
        print("Fruit #" .. i .. ":", fruit.name)
    end

    if #availableFruits == 0 then
        print("No selected fruits available in inventory")
        Library:Notify("âŒ No selected fruits found in inventory!", 3)
        return false
    end

    local fedCount = 0
    local totalFeedAttempts = 0
    local skippedWellFed = 0

    -- Feed each fruit type to ONLY HUNGRY pets
    for fruitIndex, fruitData in pairs(availableFruits) do
        print("=== FEEDING FRUIT #" .. fruitIndex .. ": " .. fruitData.name .. " ===")

        -- Equip the fruit if not already equipped
        if fruitData.tool.Parent ~= LocalPlayer.Character then
            print("Equipping fruit:", fruitData.name)
            LocalPlayer.Character.Humanoid:EquipTool(fruitData.tool)
            task.wait(0.8) -- Wait for equip
        end

        -- Verify fruit is equipped
        local currentTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
        if not currentTool or not currentTool:HasTag("FruitTool") then
            print("ERROR: Failed to equip fruit", fruitData.name)
            Library:Notify("Failed to equip " .. fruitData.name, 2)
            continue
        end

        print("Successfully equipped:", currentTool.Name)

        -- Feed ONLY HUNGRY pets with this fruit
        for petIndex, pet in pairs(hungryPets) do
            -- Check if auto feed is still enabled
            if not AutoFeedPetEnabled then
                print("Auto feed disabled by user")
                break
            end

            -- Double-check if pet still needs food (hunger might have changed)
            print("=== PRE-FEED HUNGER CHECK ===")
            local stillNeedsFood = petNeedsFood(pet.uuid)
            print("Pet", pet.petType, "still needs food:", stillNeedsFood)

            if not stillNeedsFood then
                skippedWellFed = skippedWellFed + 1
                print("â­ï¸ Pet #" .. petIndex .. " (" .. pet.petType .. ") is now well-fed (90%+) - skipping")
                Library:Notify(
                    "â­ï¸ Pet #" .. petIndex .. " (" .. pet.petType .. ") is now well-fed (90%+) - skipping",
                    1
                )
                continue
            end

            totalFeedAttempts = totalFeedAttempts + 1
            local hungerStatus = math.floor(pet.hungerPercentage * 100)
            print(
                "Feeding attempt #"
                .. totalFeedAttempts
                .. " - Pet #"
                .. petIndex
                .. " ("
                .. pet.petType
                .. ") ["
                .. hungerStatus
                .. "% hunger] with "
                .. fruitData.name
            )

            -- Double-check fruit is still equipped
            currentTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
            if not currentTool or not currentTool:HasTag("FruitTool") then
                print("ERROR: Fruit disappeared, re-equipping...")
                LocalPlayer.Character.Humanoid:EquipTool(fruitData.tool)
                task.wait(0.5)
                currentTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
                if not currentTool then
                    print("ERROR: Cannot re-equip fruit for pet", petIndex)
                    break
                end
            end

            -- Try to feed the pet using ActivePetsService:Feed
            print("=== ATTEMPTING TO FEED PET ===")
            print("Pet UUID:", pet.uuid)
            print("Pet Type:", pet.petType)
            print("Fruit:", currentTool.Name)

            local success, result = pcall(function()
                petServices.ActivePetsService:Feed(pet.uuid)
            end)

            if success then
                fedCount = fedCount + 1
                print(
                    "âœ… SUCCESS: Fed pet #"
                    .. petIndex
                    .. " ("
                    .. pet.petType
                    .. ") ["
                    .. hungerStatus
                    .. "% â†’ more fed] with "
                    .. fruitData.name
                )
                Library:Notify(
                    "ðŸ¾ Fed Pet #"
                    .. petIndex
                    .. " ("
                    .. pet.petType
                    .. ") ["
                    .. hungerStatus
                    .. "%] with "
                    .. fruitData.name,
                    1
                )

                -- Wait and then check hunger again
                task.wait(1.0)

                -- Post-feed hunger check to see if pet is now full
                print("=== POST-FEED HUNGER CHECK ===")
                local nowNeedsFood = petNeedsFood(pet.uuid)
                print("Pet", pet.petType, "still needs food after feeding:", nowNeedsFood)

                if not nowNeedsFood then
                    print("ðŸŽ‰ Pet #" .. petIndex .. " (" .. pet.petType .. ") is now full! Moving to next pet.")
                    Library:Notify("ðŸŽ‰ Pet #" .. petIndex .. " (" .. pet.petType .. ") is now full!", 1)
                end

                -- Wait between each pet feeding
                task.wait(0.8)
            else
                print("âŒ FAILED: Pet #" .. petIndex .. " (" .. pet.petType .. ") - Error:", result)
                -- Pet might be full now or error occurred, continue to next pet
                Library:Notify("âš ï¸ Pet #" .. petIndex .. " couldn't be fed (might be full now)", 1)
                task.wait(0.8)
            end
        end

        -- Wait between different fruit types
        if AutoFeedPetEnabled and fruitIndex < #availableFruits then
            print("Waiting before next fruit type...")
            task.wait(2)
        end
    end

    print("=== FEEDING COMPLETE ===")
    print("Fed", fedCount, "out of", totalFeedAttempts, "feeding attempts")
    print("Hungry pets:", #hungryPets, "/ Total pets:", #activePets)
    print("Skipped well-fed pets:", skippedWellFed)
    print("Available fruits:", #availableFruits)

    if fedCount > 0 then
        Library:Notify(
            "âœ… Fed "
            .. fedCount
            .. " hungry pets successfully! Skipped "
            .. (#activePets - #hungryPets + skippedWellFed)
            .. " well-fed pets.",
            4
        )
    else
        Library:Notify("âŒ No pets were fed - all pets are well-fed or no fruits available", 3)
    end

    return fedCount > 0
end

-- Auto feed pets loop with cycling
local PetFeedingIndex = 1
local LastFruitIndex = 1

local function autoFeedPetsInOrder()
    if not AutoFeedPetEnabled then
        return
    end
    task.spawn(function()
        while AutoFeedPetEnabled do
            task.wait(2) -- Check every 2 seconds

            local petServices = getPetServices()
            if not petServices then
                print("Pet services not available")
                task.wait(3)
                continue
            end

            local activePets = getActivePets()
            if #activePets == 0 then
                print("No active pets found")
                task.wait(3)
                continue
            end

            -- Filter pets that need feeding (hunger under 70%)
            local hungryPets = {}
            for _, pet in pairs(activePets) do
                if pet.hungerPercentage and pet.hungerPercentage < 0.7 then
                    table.insert(hungryPets, pet)
                    print(
                        "Pet " .. pet.petType .. " needs food: " .. math.floor(pet.hungerPercentage * 100) .. "% hunger"
                    )
                else
                    local hungerPercent = pet.hungerPercentage and math.floor(pet.hungerPercentage * 100) or 0
                    print("Pet " .. pet.petType .. " doesn't need food: " .. hungerPercent .. "% hunger (skipping)")
                end
            end

            if #hungryPets == 0 then
                print("No hungry pets found (all pets have >70% hunger)")
                task.spawn(function()
                    pcall(function()
                        Library:Notify("âœ… All pets are well fed! (>70% hunger)", 2)
                    end)
                end)
                task.wait(5)
                continue
            end

            -- Get available fruits
            local availableFruits = {}
            for plantName, selected in pairs(SelectedPlantsToFeed) do
                if selected then
                    local hasFruit = false
                    local fruitTool = nil

                    -- Check character and backpack
                    if LocalPlayer.Character then
                        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
                            if tool:IsA("Tool") and tool:HasTag("FruitTool") and tool.Name == plantName then
                                hasFruit = true
                                fruitTool = tool
                                break
                            end
                        end
                    end

                    if not hasFruit and LocalPlayer.Backpack then
                        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                            if tool:IsA("Tool") and tool:HasTag("FruitTool") and tool.Name == plantName then
                                fruitTool = tool
                                hasFruit = true
                                break
                            end
                        end
                    end

                    if hasFruit and fruitTool then
                        table.insert(availableFruits, { name = plantName, tool = fruitTool })
                    end
                end
            end

            if #availableFruits == 0 then
                print("No fruits available for feeding")
                task.wait(3)
                continue
            end

            -- Cycle through hungry pets and fruits
            if PetFeedingIndex > #hungryPets then
                PetFeedingIndex = 1 -- Reset to first hungry pet
            end

            if LastFruitIndex > #availableFruits then
                LastFruitIndex = 1 -- Reset to first fruit
            end

            local currentPet = hungryPets[PetFeedingIndex]
            local currentFruit = availableFruits[LastFruitIndex]

            if currentPet and currentFruit then
                local hungerPercent = math.floor(currentPet.hungerPercentage * 100)
                print(
                    "Auto-feeding Pet #"
                    .. PetFeedingIndex
                    .. " ("
                    .. currentPet.petType
                    .. ", "
                    .. hungerPercent
                    .. "% hunger) with "
                    .. currentFruit.name
                )

                -- Equip the fruit
                if currentFruit.tool.Parent ~= LocalPlayer.Character then
                    LocalPlayer.Character.Humanoid:EquipTool(currentFruit.tool)
                    task.wait(0.3)
                end

                -- Check if player still has fruit equipped
                local currentTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
                if currentTool and currentTool:HasTag("FruitTool") then
                    -- Try to feed
                    local success, result = pcall(function()
                        petServices.ActivePetsService:Feed(currentPet.uuid)
                    end)

                    if success then
                        print("Successfully fed Pet #" .. PetFeedingIndex)
                        task.spawn(function()
                            pcall(function()
                                Library:Notify(
                                    "ðŸ¾ Fed hungry pet ("
                                    .. hungerPercent
                                    .. "% hunger): "
                                    .. currentPet.petType
                                    .. " with "
                                    .. currentFruit.name,
                                    2
                                )
                            end)
                        end)
                    else
                        print("Failed to feed Pet #" .. PetFeedingIndex .. ":", result)
                        task.spawn(function()
                            pcall(function()
                                Library:Notify(
                                    "âš ï¸ Pet couldn't be fed - "
                                    .. currentPet.petType
                                    .. " ("
                                    .. hungerPercent
                                    .. "% hunger)",
                                    2
                                )
                            end)
                        end)
                    end
                else
                    print("No fruit equipped for Pet #" .. PetFeedingIndex)
                end

                -- Move to next pet
                PetFeedingIndex = PetFeedingIndex + 1

                -- If we've fed all hungry pets, move to next fruit type
                if PetFeedingIndex > #hungryPets then
                    LastFruitIndex = LastFruitIndex + 1
                    if LastFruitIndex > #availableFruits then
                        LastFruitIndex = 1 -- Reset fruit cycle
                    end
                    PetFeedingIndex = 1 -- Reset to first hungry pet for next fruit cycle
                end
            end
        end
    end)
end

-- Auto feed pets loop
local function autoFeedPets()
    if not AutoFeedPetEnabled then
        return
    end

    -- Use the new ordered feeding system
    autoFeedPetsInOrder()
end

-- Plant selection dropdown
AutoFeedPetGroupBox:AddDropdown("FeedPlantsList", {
    Values = { "Loading fruits..." },
    Default = 1,
    Multi = true, -- Allow multiple selections

    Text = "Select Plants/Fruits",
    Tooltip = "Choose which plants/fruits to feed to your pets",

    Callback = function(Value)
        print("[cb] Selected seeds for feeding:", Value)
        SelectedPlantsToFeed = Value
    end,
})

-- Refresh fruit list button
AutoFeedPetGroupBox:AddButton("ðŸ”„ Refresh Fruit List", function()
    local playerFruits = getPlayerFruits()

    if #playerFruits > 0 then
        Options.FeedPlantsList:SetValues(playerFruits)
        Library:Notify("ðŸ”„ Found " .. #playerFruits .. " fruits in inventory!", 2)
    else
        Options.FeedPlantsList:SetValues({ "No fruits found" })
        Library:Notify("âŒ No fruits found in inventory", 3)
    end
end)

-- Auto Feed Pets toggle
AutoFeedPetGroupBox:AddToggle("AutoFeedPets", {
    Text = "Auto Feed Pets",
    Tooltip = "Automatically feed selected plants to pets with <70% hunger (smart feeding)",
    Default = false,
    Callback = function(Value)
        print("[cb] Auto Feed Pets toggled:", Value)
        AutoFeedPetEnabled = Value
        if Value then
            autoFeedPets()
            task.spawn(function()
                pcall(function()
                    Library:Notify("ðŸ¾ Auto feed pets enabled! (Using ActivePetsService | <90% hunger)", 3)
                end)
            end)
        else
            task.spawn(function()
                pcall(function()
                    Library:Notify("âŒ Auto feed pets disabled", 2)
                end)
            end)
        end
    end,
})

-- Manual feed pets button
AutoFeedPetGroupBox:AddButton("Feed Pets Now", function()
    local fedPets = feedPetsWithPlants()
    if fedPets then
        Library:Notify("Fed pets with selected plants!", 2)
    else
        Library:Notify("No pets fed - check fruit inventory and pet selection", 3)
    end
end)

-- Pet list from the pet documentation (All pets from game files)
local PetList = {
    -- Basic Pets
    "Dog",
    "Golden Lab",
    "Bunny",
    "Black Bunny",
    "Cat",
    "Orange Tabby",
    "Deer",
    "Spotted Deer",
    "Monkey",
    "Silver Monkey",
    "Chicken",
    "Rooster",
    "Pig",
    "Turtle",
    "Cow",

    -- Rare & Mythical Pets
    "Snail",
    "Giant Ant",
    "Dragonfly",
    "Polar Bear",
    "Panda",
    "Sea Otter",
    "Caterpillar",
    "Praying Mantis",
    "Hedgehog",
    "Kiwi",
    "Mole",
    "Frog",
    "Echo Frog",
    "Owl",
    "Night Owl",
    "Raccoon",
    "Grey Mouse",
    "Squirrel",
    "Brown Mouse",
    "Red Giant Ant",
    "Red Fox",

    -- Event/Special Pets
    "Chicken Zombie",
    "Blood Hedgehog",
    "Blood Kiwi",
    "Blood Owl",
    "Moon Cat",

    -- Flying/Bee Pets
    "Bee",
    "Honey Bee",
    "Petal Bee",
    "Golden Bee",
    "Bear Bee",
    "Queen Bee",
    "Wasp",
    "Tarantula Hawk",
    "Moth",
    "Butterfly",
    "Disco Bee",
    "Pack Bee",

    -- Other Flying Pets
    "Firefly",
    "Red Dragon",
    "Cooked Owl",

    -- Aquatic Pets
    "Starfish",
    "Crab",
    "Seagull",
    "Toucan",
    "Flamingo",
    "Sea Turtle",
    "Seal",

    -- Land Animals
    "Orangutan",
    "Peacock",
    "Capybara",
    "Scarlet Macaw",
    "Ostrich",
    "Mimic Octopus",
    "Meerkat",
    "Sand Snake",
    "Axolotl",
    "Hyacinth Macaw",
    "Fennec Fox",
    "Hamster",
}

-- Function to check if player has any of the known pets (updated for new pet system)
local function checkPlayerPets()
    local foundPets = {}
    local activePets = {}

    -- Method 1: Try to use ActivePetsService (new working method)
    local success1, petsFromActiveService = pcall(function()
        -- Check if required services exist first
        if not Services.ReplicatedStorage:FindFirstChild("Modules") then
            return {}
        end

        local Modules = Services.ReplicatedStorage.Modules
        if not Modules:FindFirstChild("PetServices") then
            return {}
        end

        local PetServices = Modules.PetServices
        if not PetServices:FindFirstChild("ActivePetsService") then
            return {}
        end

        -- Try to require ActivePetsService safely
        local ActivePetsService = require(PetServices.ActivePetsService)
        if not ActivePetsService then
            return {}
        end

        -- Try to get DataService safely
        if not Modules:FindFirstChild("DataService") then
            return {}
        end

        local DataService = require(Modules.DataService)
        local data = DataService:GetData()

        if not data or not data.PetsData then
            return {}
        end

        -- Try to get PetRegistry safely
        if not Services.ReplicatedStorage:FindFirstChild("Data") or not Services.ReplicatedStorage.Data:FindFirstChild("PetRegistry") then
            return {}
        end

        local PetRegistry = require(Services.ReplicatedStorage.Data.PetRegistry)
        local PetList = PetRegistry.PetList

        -- Get pets using ActivePetsService
        local clientPetState = ActivePetsService:GetClientPetState(LocalPlayer.Name)
        if not clientPetState then
            return {}
        end

        local processedPets = {}
        for petUUID, petState in pairs(clientPetState) do
            -- Get pet data from ActivePetsService
            local petData = ActivePetsService:GetPetData(LocalPlayer.Name, petUUID)
            if petData then
                -- Safely get pet type data
                local petTypeData = PetList[petData.PetType]
                local defaultHunger = petTypeData and petTypeData.DefaultHunger or 100
                local currentHunger = (petData.PetData and petData.PetData.Hunger) or 0
                local hungerPercentage = currentHunger / defaultHunger
                local age = (petData.PetData and petData.PetData.Level) or 0 -- Use Level as age

                -- Check if this pet is in our known pet list (from game PetRegistry)
                local isKnownPet = PetList[petData.PetType] ~= nil

                table.insert(processedPets, {
                    uuid = petUUID,
                    name = petData.PetType,
                    type = petData.PetType,
                    age = age,
                    currentHunger = currentHunger,
                    maxHunger = defaultHunger,
                    hungerPercentage = hungerPercentage,
                    isKnownPet = isKnownPet,
                    location = "Farm Area",
                })
            end
        end

        return processedPets
    end)

    if success1 and petsFromActiveService then
        -- Separate known pets from all pets
        for _, pet in pairs(petsFromActiveService) do
            table.insert(activePets, pet)
            if pet.isKnownPet then
                table.insert(foundPets, pet)
            end
        end
    end

    -- Method 2: Scan workspace for pet objects (safer fallback method)
    local success2, workspacePets = pcall(function()
        local workspacePetList = {}

        -- Add a small delay to ensure we're in a stable thread context
        task.wait(0.1)

        for _, obj in pairs(workspace:GetDescendants()) do
            if
                obj:GetAttribute("OWNER") == LocalPlayer.Name
                and obj:GetAttribute("UUID")
                and obj:HasTag("PetTargetable")
            then
                local petType = obj:GetAttribute("PetType") or obj.Name
                local uuid = obj:GetAttribute("UUID")

                -- Check if we already have this pet from ActivePetsService
                local alreadyFound = false
                for _, existing in pairs(activePets) do
                    if existing.uuid == uuid then
                        alreadyFound = true
                        existing.workspaceObject = obj
                        break
                    end
                end

                if not alreadyFound then
                    -- Check if this pet is in our known pet list (fallback to hardcoded list)
                    local isKnownPet = false
                    for _, knownPet in pairs(PetList) do
                        if petType == knownPet or obj.Name == knownPet then
                            isKnownPet = true
                            break
                        end
                    end

                    local pet = {
                        name = petType ~= "PetMover" and petType or obj.Name,
                        type = petType,
                        uuid = uuid,
                        location = obj.Parent and obj.Parent.Name or "Unknown",
                        isKnownPet = isKnownPet,
                        workspaceObject = obj,
                    }

                    table.insert(workspacePetList, pet)
                end
            end
        end
        return workspacePetList
    end)

    if success2 and workspacePets then
        for _, pet in pairs(workspacePets) do
            table.insert(activePets, pet)
            if pet.isKnownPet then
                table.insert(foundPets, pet)
            end
        end
    end

    return foundPets, activePets
end

-- Show Active Pets button
AutoFeedPetGroupBox:AddButton("ðŸ“Š Show Active Pets", function()
    Library:Notify("ðŸ” Scanning for active pets...", 2)

    -- Use task.spawn to ensure proper thread context for workspace access
    task.spawn(function()
        -- Safely check for pets with comprehensive error handling
        local success, knownPets, allActivePets = pcall(function()
            return checkPlayerPets()
        end)

        if not success then
            Library:Notify("âŒ Error scanning pets: " .. tostring(knownPets), 5)
            return
        end

        local debugInfo = {}

        -- Check game data for additional information (with error handling)
        local dataSuccess, dataResult = pcall(function()
            if not Services.ReplicatedStorage:FindFirstChild("Modules") then
                return "Modules not found"
            end

            if not Services.ReplicatedStorage.Modules:FindFirstChild("DataService") then
                return "DataService not found"
            end

            local DataService = require(Services.ReplicatedStorage.Modules.DataService)
            local data = DataService:GetData()

            if not data then
                return "No game data"
            end

            if not data.PetsData then
                return "No PetsData"
            end

            if not data.PetsData.EquippedPets then
                return "No EquippedPets"
            end

            local equippedCount = #data.PetsData.EquippedPets
            return "Equipped pets in data: " .. equippedCount
        end)

        if dataSuccess then
            table.insert(debugInfo, dataResult)
        else
            table.insert(debugInfo, "Data check failed: " .. tostring(dataResult))
        end

        -- Check ActivePetsService status
        local activeServiceSuccess, activeServiceResult = pcall(function()
            if not Services.ReplicatedStorage:FindFirstChild("Modules") then
                return "Modules not found"
            end

            local PetServices = Services.ReplicatedStorage.Modules:FindFirstChild("PetServices")
            if not PetServices then
                return "PetServices not found"
            end

            local ActivePetsService = require(PetServices:FindFirstChild("ActivePetsService"))
            if not ActivePetsService then
                return "ActivePetsService not available"
            end

            local clientState = ActivePetsService:GetClientPetState(LocalPlayer.Name)
            if not clientState then
                return "No client pet state"
            end

            local petCount = 0
            for _ in pairs(clientState) do
                petCount = petCount + 1
            end

            return "ActivePetsService pets: " .. petCount
        end)

        if activeServiceSuccess then
            table.insert(debugInfo, activeServiceResult)
        else
            table.insert(debugInfo, "ActivePetsService check failed: " .. tostring(activeServiceResult))
        end

        -- Show results with priority on known pets
        if #knownPets > 0 then
            local message = "ðŸ¾ Active Pets Found (" .. #knownPets .. "/" .. #allActivePets .. "):\n\n"
            for i, pet in pairs(knownPets) do
                message = message .. i .. ". " .. pet.name .. "\n"
                if pet.age and pet.age > 0 then
                    message = message .. "   ðŸŽ‚ Age: " .. pet.age .. "\n"
                end
                if pet.hungerPercentage then
                    local hungerEmoji = pet.hungerPercentage > 0.7 and "ðŸŸ¢"
                        or pet.hungerPercentage > 0.3 and "ðŸŸ¡"
                        or "ðŸ”´"
                    message = message
                        .. "   ðŸŽ Hunger: "
                        .. math.floor(pet.hungerPercentage * 100)
                        .. "% "
                        .. hungerEmoji
                        .. "\n"
                end
                message = message .. "   ðŸ“ Location: " .. pet.location .. "\n"
                if pet.uuid then
                    message = message .. "   ðŸ†” ID: " .. string.sub(pet.uuid, 1, 8) .. "...\n"
                end
                if i >= 4 then -- Limit to 4 pets for readability
                    message = message .. "\n... and " .. (#knownPets - 4) .. " more pets"
                    break
                end
            end

            -- Add other active pets if any
            local otherPets = #allActivePets - #knownPets
            if otherPets > 0 then
                message = message .. "\n\nðŸ” Other/Unknown Pets: " .. otherPets
            end

            Library:Notify(message, 12)
        elseif #allActivePets > 0 then
            local message = "ðŸ¾ Active Pets Found (" .. #allActivePets .. "):\n\n"
            for i, pet in pairs(allActivePets) do
                local displayName = pet.name ~= "PetMover" and pet.name or pet.type
                message = message .. i .. ". " .. displayName .. "\n"
                if pet.age and pet.age > 0 then
                    message = message .. "   ðŸŽ‚ Age: " .. pet.age .. "\n"
                end
                if pet.hungerPercentage then
                    local hungerEmoji = pet.hungerPercentage > 0.7 and "ðŸŸ¢"
                        or pet.hungerPercentage > 0.3 and "ðŸŸ¡"
                        or "ðŸ”´"
                    message = message
                        .. "   ðŸŽ Hunger: "
                        .. math.floor(pet.hungerPercentage * 100)
                        .. "% "
                        .. hungerEmoji
                        .. "\n"
                end
                message = message .. "   ðŸ“ Location: " .. pet.location .. "\n"
                if i >= 4 then -- Limit to 4 pets for readability
                    message = message .. "\n... and " .. (#allActivePets - 4) .. " more pets"
                    break
                end
            end
            message = message .. "\n\nâš ï¸ Using workspace detection (ActivePetsService may not be fully loaded)"
            Library:Notify(message, 10)
        else
            -- Show detailed debug info when no pets found
            local debugMessage = "âŒ No Active Pets Found\n\nðŸ“Š Debug Information:\n"
            for _, info in pairs(debugInfo) do
                debugMessage = debugMessage .. "â€¢ " .. info .. "\n"
            end
            debugMessage = debugMessage .. "â€¢ Total workspace pets: " .. #allActivePets .. "\n"
            debugMessage = debugMessage .. "\nðŸ’¡ Troubleshooting Tips:\n"
            debugMessage = debugMessage .. "â€¢ Make sure you have pets equipped\n"
            debugMessage = debugMessage .. "â€¢ Try spawning/summoning your pets\n"
            debugMessage = debugMessage .. "â€¢ Wait a moment for ActivePetsService to load\n"
            debugMessage = debugMessage .. "â€¢ Check if you're in the right area\n"
            debugMessage = debugMessage .. "â€¢ Ensure you're in your own farm plot"

            Library:Notify(debugMessage, 10)
        end

        -- Always show this notification to confirm button works
        task.wait(1)
        Library:Notify("ðŸ” Pet scan completed! Check results above.", 3)
    end)
end)

-- ================================================================
-- SELL TAB CONTENT - Complete Auto Sell System
-- ================================================================

-- Add elements directly to Sell Tab (no groupbox needed in tabbox tabs)
SellTab:AddLabel("ðŸ’° Auto Sell")
SellTab:AddDivider()

-- Variables for sell functionality
local AutoSellInventoryEnabled = false
local OriginalPlayerPosition = nil
local autoSellEnabled = false
local autoSellConnection = nil
local setupAutoSellEquipMonitor = nil
local setupCharacterMonitor = nil
local AutoSellOnNotificationEnabled = false
local NotificationConnection = nil
local isSelling = false

-- Get the sell remotes
local Sell_Inventory = Services.ReplicatedStorage.GameEvents:WaitForChild("Sell_Inventory")
local Sell_Item = Services.ReplicatedStorage.GameEvents:WaitForChild("Sell_Item")

-- Function to find Sell Stands location
local function findSellStands()
	local success, result = pcall(function()
		-- Method 1: Look for NPCS > Sell Stand
		local npcs = workspace:FindFirstChild("NPCS")
		if npcs then
			local sellStand = npcs:FindFirstChild("Sell Stand")
					or npcs:FindFirstChild("SellStand")
					or npcs:FindFirstChild("Sell")
			if sellStand then
				return sellStand
			end
		end

		-- Method 2: Search for any "Sell" related NPCs
		if npcs then
			for _, npc in pairs(npcs:GetChildren()) do
				if string.find(npc.Name:lower(), "sell") then
					return npc
				end
			end
		end

		-- Method 3: Look in workspace.Interaction for sell stands
		local interaction = workspace:FindFirstChild("Interaction")
		if interaction then
			local sellStand = interaction:FindFirstChild("SellStand") or interaction:FindFirstChild("Sell Stand")
			if sellStand then
				return sellStand
			end
		end

		return nil
	end)

	if success and result then
		return result
	else
		print("Error finding sell stands:", result)
		return nil
	end
end

-- Function to get safe teleport position near sell stands
local function getSellStandPosition()
	local sellStand = findSellStands()
	if not sellStand then
		print("âŒ No sell stand found")
		return nil
	end

	-- Try to find the exact position of the sell stand for precise teleportation
	local position = nil
	if sellStand:FindFirstChild("HumanoidRootPart") then
		position = sellStand.HumanoidRootPart.Position
		print("ðŸ“ Found sell stand via HumanoidRootPart:", position)
	elseif sellStand.PrimaryPart then
		position = sellStand.PrimaryPart.Position
		print("ðŸ“ Found sell stand via PrimaryPart:", position)
	else
		-- Find any part in the sell stand to use as reference
		for _, child in pairs(sellStand:GetChildren()) do
			if child:IsA("BasePart") then
				position = child.Position
				print("ðŸ“ Found sell stand via BasePart (" .. child.Name .. "):", position)
				break
			end
		end
	end

	if not position then
		print("âŒ Could not determine sell stand position")
		return nil
	end

	return position
end

-- Improved sell inventory function with better teleportation for auto-sell
local function sellInventoryWithImprovedTeleport()
	local success, result = pcall(function()
		-- Store original position
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
			OriginalPlayerPosition = LocalPlayer.Character.HumanoidRootPart.Position
			print("ðŸ“ Stored original position:", OriginalPlayerPosition)
		else
			print("âŒ Could not get player position!")
			return false
		end

		-- Find sell stand position
		local sellStandPosition = getSellStandPosition()
		if not sellStandPosition then
			Library:Notify("Could not find Sell Stands!", 3)
			return false
		end

		print("Teleporting to Sell Stands for auto-sell...")
		Library:Notify("Teleporting to Sell Stands...", 2)

		-- Calculate optimal position - very close to sell stand but not overlapping
		local optimalPosition = sellStandPosition + Vector3.new(0, 0.5, 1.5) -- Close proximity for reliable interaction

		-- Single teleport to optimal position
		LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(optimalPosition)
		print("ðŸ“ Teleported to position:", optimalPosition)
		task.wait(2.0) -- Allow full teleport registration and network sync

		-- Face the sell stand for better interaction
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
			local lookDirection = (sellStandPosition - LocalPlayer.Character.HumanoidRootPart.Position).Unit
			LocalPlayer.Character.HumanoidRootPart.CFrame =
			CFrame.lookAt(LocalPlayer.Character.HumanoidRootPart.Position, sellStandPosition)
			task.wait(0.5)
		end

		-- Get backpack count before selling for validation
		local backpackCount = 0
		local backpack = LocalPlayer:FindFirstChild("Backpack")
		if backpack then
			backpackCount = #backpack:GetChildren()
			print("ðŸ“¦ Items in backpack before sell:", backpackCount)
		end

		-- Sell inventory
		print("ðŸ’° Selling inventory (auto-sell)...")
		Library:Notify("ðŸ’° Selling inventory...", 2)
		Sell_Inventory:FireServer()
		-- Wait with progress feedback
		for i = 1, 4 do
			task.wait(1)
			print("â³ Waiting for sell to complete... (" .. i .. "/4 seconds)")
		end

		-- Validate sell completion by checking backpack
		local newBackpackCount = 0
		if backpack then
			newBackpackCount = #backpack:GetChildren()
			print("ðŸ“¦ Items in backpack after sell:", newBackpackCount)
		end

		-- Additional wait if items still in backpack
		if newBackpackCount > 0 and newBackpackCount >= backpackCount then
			print("âš ï¸  Items still in backpack, waiting longer...")
			Library:Notify("Extending sell wait time...", 2)
			task.wait(3)
		end

		-- Teleport back to original position
		if OriginalPlayerPosition then
			print("Teleporting back to original location...")
			Library:Notify("Teleporting back...", 2)
			LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(OriginalPlayerPosition + Vector3.new(0, 2, 0))
			task.wait(1.0) -- Ensure teleport back completes
		end

		Library:Notify("Auto-sell completed successfully!", 3)
		print("âœ… Auto-sell process finished. Items sold:", (backpackCount - newBackpackCount))
		return true
	end)

	if not success then
		print("Error in autoSellWithTeleport:", result)
		Library:Notify("Error during auto-sell: " .. tostring(result), 4)

		-- Try to teleport back even if there was an error
		if
		OriginalPlayerPosition
				and LocalPlayer.Character
				and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		then
			pcall(function()
				LocalPlayer.Character.HumanoidRootPart.CFrame =
				CFrame.new(OriginalPlayerPosition + Vector3.new(0, 2, 0))
			end)
		end
		return false
	end

	return result
end

-- Function to sell inventory with teleportation (wrapper for improved version)
local function sellInventoryWithTeleport()
	return sellInventoryWithImprovedTeleport()
end

-- Enhanced sell item in hand function with teleportation
local function sellItemInHandWithTeleport()
	local success, result = pcall(function()
		-- Store original position
		if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
			OriginalPlayerPosition = LocalPlayer.Character.HumanoidRootPart.Position
			print("ðŸ“ Stored original position:", OriginalPlayerPosition)
		else
			print("âŒ Could not get player position!")
			return false
		end

		-- Find and teleport to sell stands
		local sellStandPosition = getSellStandPosition()
		if not sellStandPosition then
			Library:Notify("âŒ Could not find Sell Stands!", 3)
			return false
		end

		print("ðŸš€ Teleporting to Sell Stands...")
		Library:Notify("ðŸš€ Teleporting to Sell Stands...", 2)
		-- Teleport to sell stands - better positioning
		LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(sellStandPosition + Vector3.new(0, 0.5, 2))
		task.wait(1) -- Wait longer for teleport to register

		-- Face the sell stand for better interaction
		LocalPlayer.Character.HumanoidRootPart.CFrame =
		CFrame.lookAt(LocalPlayer.Character.HumanoidRootPart.Position, sellStandPosition)
		task.wait(0.5) -- Wait to ensure facing direction is registered

		-- Sell item in hand
		print("ðŸ’° Selling item in hand...")
		Library:Notify("ðŸ’° Selling item in hand...", 2)

		-- Get the currently equipped tool
		local equippedTool = nil
		if LocalPlayer.Character then
			equippedTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
		end

		if equippedTool then
			print("ðŸ”§ Found equipped tool:", equippedTool.Name)

			-- First sell attempt
			Sell_Item:FireServer()
			task.wait(0.5) -- Wait for sell to process

			-- Check if item is still equipped (sell might have failed)
			if LocalPlayer.Character:FindFirstChildWhichIsA("Tool") then
				print("âš ï¸ First sell attempt failed, trying again with adjusted position...")

				-- Move slightly closer to the sell stand and try again
				LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(sellStandPosition + Vector3.new(0, 0.5, 1))
				task.wait(0.3)

				-- Second sell attempt
				Sell_Item:FireServer()
				task.wait(0.5)

				-- If still equipped, try one more time with different angle
				if LocalPlayer.Character:FindFirstChildWhichIsA("Tool") then
					print("âš ï¸ Second sell attempt failed, trying final position...")

					-- Try from a different angle
					LocalPlayer.Character.HumanoidRootPart.CFrame =
					CFrame.new(sellStandPosition + Vector3.new(1, 0.5, 1))
					task.wait(0.3)

					-- Final sell attempt
					Sell_Item:FireServer()
					task.wait(0.5)
				end
			end
		else
			print("âŒ No tool equipped in hand!")
			Library:Notify("âŒ No item in hand to sell!", 2)
			return false
		end

		-- Teleport back to original position
		if OriginalPlayerPosition then
			print("Teleporting back to original location...")
			Library:Notify("Teleporting back...", 2)
			LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(OriginalPlayerPosition + Vector3.new(0, 2, 0))
			task.wait(0.5)
		end

		Library:Notify("Item sold and teleported back!", 3)
		return true
	end)

	if not success then
		print("Error in sellItemInHandWithTeleport:", result)
		Library:Notify("Error during sell process: " .. tostring(result), 4)

		-- Try to teleport back even if there was an error
		if
		OriginalPlayerPosition
				and LocalPlayer.Character
				and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
		then
			pcall(function()
				LocalPlayer.Character.HumanoidRootPart.CFrame =
				CFrame.new(OriginalPlayerPosition + Vector3.new(0, 2, 0))
			end)
		end
		return false
	end

	return result
end

-- Sell Inventory Toggle
SellTab:AddToggle("AutoSellInventory", {
	Text = "Sell Inventory",
	Tooltip = "Teleport to Sell Stands, sell inventory, and teleport back",
	Default = false,

	Callback = function(Value)
		print("[cb] Sell Inventory toggled:", Value)
		AutoSellInventoryEnabled = Value

		if Value then
			-- Single inventory sell with teleportation
			sellInventoryWithTeleport()
			-- Reset toggle after single use
			Toggles.AutoSellInventory:SetValue(false)
		end
	end,
})

-- Auto Sell on Equip Toggle
SellTab:AddToggle("AutoSell", {
	Text = "Auto Sell on Equip",
	Tooltip = "Automatically teleport to Sell Stands and sell items when equipped",
	Default = false,

	Callback = function(Value)
		print("[cb] Auto Sell on Equip toggled:", Value)
		autoSellEnabled = Value

		if Value then
			Library:Notify("Auto-sell on equip enabled! Equip items to sell them.", 3)

			-- Check if player already has an equipped item (if setupAutoSellEquipMonitor is defined)
			if setupAutoSellEquipMonitor and LocalPlayer.Character then
				local equippedTool = LocalPlayer.Character:FindFirstChildWhichIsA("Tool")
				if equippedTool then
					print("Auto-detected already equipped item:", equippedTool.Name)
					Library:Notify("Selling already equipped item: " .. equippedTool.Name, 2)

					-- Use pcall to catch any errors
					task.spawn(function()
						pcall(function()
							sellItemInHandWithTeleport()
						end)
					end)
				end
			end
		else
			Library:Notify("Auto-sell on equip disabled", 2)
		end
	end,
})

-- Auto Sell on Full Backpack Notification
SellTab:AddToggle("AutoSellOnNotification", {
	Text = "ðŸ”” Auto Sell on Full Backpack",
	Tooltip = "Automatically sell inventory when 'Max backpack space! Go sell!' notification appears",
	Default = false,

	Callback = function(Value)
		print("[cb] Auto Sell on Notification toggled:", Value)
		AutoSellOnNotificationEnabled = Value

		if Value then
			Library:Notify("ðŸ”” Auto Sell on Notification enabled! Will auto-sell when backpack is full.", 4)

			-- Connect to the notification event
			if NotificationConnection then
				NotificationConnection:Disconnect()
			end

			NotificationConnection = Services.ReplicatedStorage.GameEvents.Notification.OnClientEvent:Connect(function(message)
				print("ðŸ”” Notification received:", message) -- Debug print
				print("ðŸ”” AutoSellOnNotificationEnabled:", AutoSellOnNotificationEnabled) -- Debug print
				print("ðŸ”” isSelling:", isSelling) -- Debug print

				if AutoSellOnNotificationEnabled and message == "Max backpack space! Go sell!" and not isSelling then
					print("ðŸ”” Detected full backpack notification! Auto-selling inventory...")
					Library:Notify("ðŸ”” Backpack Full! Auto-selling inventory...", 3)

					-- Set selling state to prevent multiple simultaneous sells
					isSelling = true

					-- Small delay to prevent immediate re-triggering
					task.wait(1)

					-- Call the sell function and verify success
					local sellSuccess = sellInventoryWithImprovedTeleport()

					-- Verify backpack is actually empty after selling
					local backpackStillFull = false
					local backpack = LocalPlayer:FindFirstChild("Backpack")
					if backpack then
						local itemCount = #backpack:GetChildren()
						print("ðŸ“¦ Items remaining in backpack after sell:", itemCount)
						-- More reasonable threshold - if we sold at least 50% of items or have less than 15 items, consider it successful
						if itemCount > 20 then -- Only consider full if more than 20 items
							backpackStillFull = true
							print("âš ï¸ Backpack still appears full after selling!")
						else
							print("âœ… Backpack sell was successful - " .. itemCount .. " items remaining")
						end
					end

					-- Wait a bit more if backpack is still full
					if backpackStillFull then
						Library:Notify("âš ï¸ Backpack still full, waiting longer...", 3)
						task.wait(3)

						-- Check again with more lenient threshold
						if backpack then
							local itemCount = #backpack:GetChildren()
							print("ðŸ“¦ Items in backpack after extended wait:", itemCount)
							if itemCount <= 25 then -- Much more reasonable threshold
								backpackStillFull = false
							end
						end
					end

					-- Reset selling state
					isSelling = false

					-- Notify user of the action
					if sellSuccess and not backpackStillFull then
						Library:Notify("âœ… Auto-sold inventory successfully!", 4)
					else
						Library:Notify("âš ï¸ Auto-sell completed but may need manual check!", 4)
					end
				end
			end)
		else
			Library:Notify("ðŸ”” Auto Sell on Notification disabled!", 2)

			-- Disconnect the notification event
			if NotificationConnection then
				NotificationConnection:Disconnect()
				NotificationConnection = nil
			end
		end
	end,
})

-- Manual sell button
SellTab:AddButton("ðŸ’° Sell Inventory Now", function()
	Library:Notify("ðŸ’° Manually selling inventory...", 2)
	sellInventoryWithTeleport()
end)

-- Initialize auto sell functions now that sellItemInHandWithTeleport is defined
setupAutoSellEquipMonitor = function()
	if autoSellConnection then
		autoSellConnection:Disconnect()
	end

	autoSellConnection = LocalPlayer.Character.ChildAdded:Connect(function(child)
		if autoSellEnabled and child:IsA("Tool") then
			print("ðŸ” Auto-detected equipped item:", child.Name)
			Library:Notify("ðŸ” Detected equipped item: " .. child.Name, 2)
			-- Wait a brief moment to ensure the tool is fully equipped
			task.wait(0.2)
			-- Sell the item that was just equipped
			task.spawn(function()
				sellItemInHandWithTeleport()
			end)
		end
	end)
end

setupCharacterMonitor = function()
	if LocalPlayer.Character then
		setupAutoSellEquipMonitor()
	end

	LocalPlayer.CharacterAdded:Connect(function(character)
		character:WaitForChild("Humanoid")
		setupAutoSellEquipMonitor()
	end)
end

-- Initialize the character monitor
setupCharacterMonitor()

-- Initialize auto sell if Auto Sell is already enabled from saved settings
if autoSellEnabled then
	print("âœ… Auto-sell was enabled from saved settings")
end

-- ================================================================
-- PLAYER TAB CONTENT - Complete Player Features from SloppyCoding
-- ================================================================

-- Global variables for Player Movement
local InfiniteJumpEnabled = false
local OriginalJumpPower = 50
local OriginalWalkSpeed = 16

-- Get player character and humanoid
local function getPlayerHumanoid()
	if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
		return LocalPlayer.Character.Humanoid
	end
	return nil
end

-- Infinite Jump functionality
local function setupInfiniteJump()
	local UserInputService = game:GetService("UserInputService")

	local function onJumpRequest()
		if InfiniteJumpEnabled then
			local humanoid = getPlayerHumanoid()
			if humanoid then
				humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
			end
		end
	end

	UserInputService.JumpRequest:Connect(onJumpRequest)
end

-- Store original values when character spawns
local function storeOriginalValues()
	local humanoid = getPlayerHumanoid()
	if humanoid then
		-- Try to get JumpPower first
		local jumpValue = nil
		local success1 = pcall(function()
			jumpValue = humanoid.JumpPower
		end)

		-- If JumpPower doesn't exist, try JumpHeight
		if not success1 or jumpValue == nil then
			pcall(function()
				jumpValue = humanoid.JumpHeight
			end)
		end

		-- Use the actual value or fallback to 50
		OriginalJumpPower = jumpValue or 50
		OriginalWalkSpeed = humanoid.WalkSpeed or 16

		-- Update the slider default to match the actual game value
		if Options.JumpPower then
			Options.JumpPower:SetValue(OriginalJumpPower)
		end
		if Options.WalkSpeed then
			Options.WalkSpeed:SetValue(OriginalWalkSpeed)
		end
	end
end

-- Character respawn handler
LocalPlayer.CharacterAdded:Connect(function()
	task.wait(1) -- Wait for character to fully load
	storeOriginalValues()

	-- Re-apply current slider values to new character
	task.wait(0.5) -- Extra wait to ensure character is ready
	if Options.JumpPower and Options.WalkSpeed then
		local currentJump = Options.JumpPower.Value
		local currentSpeed = Options.WalkSpeed.Value

		local humanoid = getPlayerHumanoid()
		if humanoid then
			-- Apply current jump value
			local success1 = pcall(function()
				humanoid.JumpPower = currentJump
			end)
			if not success1 then
				pcall(function()
					humanoid.JumpHeight = currentJump
				end)
			end

			-- Apply current speed
			humanoid.WalkSpeed = currentSpeed
		end
	end
end)

-- Store initial values if character already exists
if LocalPlayer.Character then
	storeOriginalValues()
end

-- Setup infinite jump
setupInfiniteJump()

-- Player Tab UI - Movement Section
PlayerTab:AddLabel("  Player Movement")
PlayerTab:AddDivider()

PlayerTab:AddToggle("InfiniteJump", {
	Text = "Infinite Jump",
	Tooltip = "Allows unlimited jumping",
	Default = false,

	Callback = function(Value)
		InfiniteJumpEnabled = Value
		if Value then
			Library:Notify("ðŸ¦˜ Infinite Jump enabled!", 2)
		else
			Library:Notify("âŒ Infinite Jump disabled", 2)
		end
	end,
})

PlayerTab:AddSlider("JumpPower", {
	Text = "Jump Power",
	Tooltip = "Adjust your jump height",
	Default = OriginalJumpPower, -- Use the actual game default
	Min = 16,
	Max = 200,
	Rounding = 0,

	Callback = function(Value)
		local humanoid = getPlayerHumanoid()
		if humanoid then
			-- Check if JumpPower property exists (older Roblox)
			local success1 = pcall(function()
				humanoid.JumpPower = Value
			end)

			-- Check if JumpHeight property exists (newer Roblox)
			if not success1 then
				pcall(function()
					humanoid.JumpHeight = Value
				end)
			end
		end
	end,
})

PlayerTab:AddSlider("WalkSpeed", {
	Text = "Walk Speed",
	Tooltip = "Adjust your movement speed",
	Default = OriginalWalkSpeed, -- Use the actual game default
	Min = 0,
	Max = 100,
	Rounding = 0,

	Callback = function(Value)
		local humanoid = getPlayerHumanoid()
		if humanoid then
			humanoid.WalkSpeed = Value
		end
	end,
})

PlayerTab:AddButton("ðŸ”„ Reset to Default", function()
	local humanoid = getPlayerHumanoid()
	if humanoid then
		-- Reset jump power/height
		local success1 = pcall(function()
			humanoid.JumpPower = OriginalJumpPower
		end)

		if not success1 then
			pcall(function()
				humanoid.JumpHeight = OriginalJumpPower
			end)
		end

		-- Reset walk speed
		humanoid.WalkSpeed = OriginalWalkSpeed

		-- Update sliders to match
		Options.JumpPower:SetValue(OriginalJumpPower)
		Options.WalkSpeed:SetValue(OriginalWalkSpeed)

		Library:Notify("ðŸ”„ Movement reset to default values", 2)
	end
end)

PlayerTab:AddDivider()

-- Server Section
PlayerTab:AddLabel("ðŸŒ Server Controls")

PlayerTab:AddButton("ðŸ”„ Server Hop", function()
	Library:Notify("ðŸ”„ Server hopping...", 3)

	local TeleportService = game:GetService("TeleportService")
	local PlaceId = game.PlaceId

	-- Queue the script to run after teleport
	queue_on_teleport("loadstring(game:HttpGet('https://rawscripts.net/raw/Grow-a-Garden-Grow-a-Garden-Stock-bot-41500'))()")

	-- Teleport to a different server of the same game
	TeleportService:Teleport(PlaceId, LocalPlayer)
end)

-- ================================================================
-- AUTO TAB STRUCTURE (Two-Tab Switch System)
-- ================================================================

-- Left Tabbox for Auto Features
local LeftAutoTabBox = Tabs.Auto:AddLeftTabbox("Left Auto Features")

-- Tab 1: Auto Favourite
local AutoFarmTab = LeftAutoTabBox:AddTab("Auto Favourite")

-- Simple Auto Favourite System - Global Variables
local SelectedFruit = nil
local AutoFavouriteEnabled = false

-- â­ Auto Favourite System Variables
local AutoFavoriteEnabled = false
local AutoUnfavoriteEnabled = false
local AutoUnfavoriteAllEnabled = false
local SelectedFruitForFavorite = nil
local SelectedMutationsForFavorite = {}
local SelectedVariantsForFavorite = {}
local FavoriteMutationFilterEnabled = false
local FavoriteVariantFilterEnabled = false

-- All possible mutation names (for Auto Favourite)
local AllMutations = {
	"Shocked",
	"Windstruck",
	"Dawnbound",
	"Twisted",
	"Cloudtouched",
	"Voidtouched",
	"Wet",
	"Fried",
	"Molten",
	"Alienlike",
	"Galactic",
	"Aurora",
	"Chilled",
	"Sundried",
	"Wiltproof",
	"Drenched",
	"Verdant",
	"Paradisal",
	"Frozen",
	"Disco",
	"Pollinated"
}

-- All possible variant names (for Auto Favourite)
local AllVariants = {
	"Normal",
	"Gold",
	"Rainbow"
}

-- Simple list of all fruits/plants
local AllFruits = {
    "Aloe Vera", "Apple", "Avocado", "Bamboo", "Banana", "Beanstalk", "Bee Balm", "Bell Pepper",
    "Bendboo", "Blood Banana", "Blue Lollipop", "Blueberry", "Burning Bud", "Cacao", "Cactus",
    "Candy Blossom", "Candy Sunflower", "Cantaloupe", "Carrot", "Cauliflower", "Celestiberry",
    "Cherry Blossom", "Chocolate Carrot", "Cocovine", "Coconut", "Corn", "Cranberry", "Crimson Vine",
    "Crocus", "Cursed Fruit", "Daffodil", "Dandelion", "Delphinium", "Dragon Fruit", "Dragon Pepper",
    "Durian", "Easter Egg", "Eggplant", "Elephant Ears", "Ember Lily", "Feijoa", "Foxglove",
    "Glowshroom", "Grape", "Green Apple", "Guanabana", "Hive Fruit", "Honeysuckle", "Ice Cream Bean",
    "Kiwi", "Lavender", "Lemon", "Lilac", "Lily of the Valley", "Lime", "Loquat", "Lotus", "Lumira",
    "Mango", "Manuka Flower", "Mega Mushroom", "Mint", "Moon Blossom", "Moon Mango", "Moon Melon",
    "Moonflower", "Moonglow", "Mushroom", "Nectar Thorn", "Nectarine", "Nectarshade", "Nightshade",
    "Noble Flower", "Orange Tulip", "Papaya", "Parasol Flower", "Passionfruit", "Peace Lily", "Peach",
    "Pear", "Pepper", "Pineapple", "Pink Lily", "Pink Tulip", "Pitcher Plant", "Prickly Pear",
    "Pumpkin", "Purple Cabbage", "Purple Dahlia", "Rafflesia", "Raspberry", "Red Lollipop", "Rose",
    "Rosy Delight", "Soul Fruit", "Starfruit", "Strawberry", "Succulent", "Sugar Apple", "Suncoil",
    "Sunflower", "Tomato", "Traveler's Fruit", "Venus Fly Trap", "Violet Corn", "Watermelon",
    "White Mullberry", "Wild Carrot"
}

-- Function to get player's farm
local function getMyFarm()
    for _, farm in workspace.Farm:GetChildren() do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data.Owner.Value == LocalPlayer.Name then
                return farm
            end
        end
    end
    return nil
end

-- Function to equip Favorite Tool
local function equipFavoriteTool()
    local player = LocalPlayer
    local backpack = player:FindFirstChild("Backpack")

    -- Check if already equipped
    if player.Character then
        for _, tool in pairs(player.Character:GetChildren()) do
            if tool:IsA("Tool") and string.find(tool.Name, "Favorite Tool") then
                print("âœ… Favorite Tool already equipped:", tool.Name)
                return tool
            end
        end
    end

    -- Look for tool in backpack
    if backpack then
        for _, tool in pairs(backpack:GetChildren()) do
            if tool:IsA("Tool") and string.find(tool.Name, "Favorite Tool") then
                print("ðŸ”§ Equipping Favorite Tool:", tool.Name)
                player.Character.Humanoid:EquipTool(tool)
                task.wait(0.5)
                return tool
            end
        end
    end

    print("âŒ No Favorite Tool found!")
    Library:Notify("âŒ You need a Favorite Tool! Get one from the store first.", 4)
    return nil
end

-- Function to check if fruit/plant has selected mutations for favoriting
local function hasSelectedMutationForFavorite(item)
    if not FavoriteMutationFilterEnabled or not SelectedMutationsForFavorite or not next(SelectedMutationsForFavorite) then
        return true -- If filter is disabled or no mutations selected, allow all
    end

    -- Check for mutations as StringValue objects first
    for mutation, selected in pairs(SelectedMutationsForFavorite) do
        if selected then
            -- Check if mutation exists as a StringValue object
            local mutationObj = item:FindFirstChild(mutation)
            if mutationObj and mutationObj:IsA("StringValue") then
                print("ðŸ§¬ Found favorite mutation StringValue:", mutation, "on", item.Name)
                return true
            end

            -- Check if mutation exists as an attribute
            if item:GetAttribute(mutation) then
                print("ðŸ§¬ Found favorite mutation attribute:", mutation, "on", item.Name)
                return true
            end
        end
    end

    return false -- No selected mutations found
end

-- Function to check if fruit/plant has selected variants for favoriting
local function hasSelectedVariantForFavorite(item)
    if not FavoriteVariantFilterEnabled or not SelectedVariantsForFavorite or not next(SelectedVariantsForFavorite) then
        return true -- If filter is disabled or no variants selected, allow all
    end

    -- Check for variant as StringValue object (new method)
    local variantObj = item:FindFirstChild("Variant")
    if variantObj and variantObj:IsA("StringValue") then
        local variantValue = variantObj.Value
        if SelectedVariantsForFavorite[variantValue] then
            print("ðŸŽ¨ Found favorite variant StringValue:", variantValue, "on", item.Name)
            return true
        end
    end

    -- Fallback: Check for variant as attribute (old method)
    for variant, selected in pairs(SelectedVariantsForFavorite) do
        if selected and item:GetAttribute(variant) then
            print("ðŸŽ¨ Found favorite variant attribute:", variant, "on", item.Name)
            return true -- Found a selected variant
        end
    end

    return false -- No selected variants found
end

-- Enhanced function to favorite fruits with filtering
local function autoFavoriteFilteredFruits()
    if not SelectedFruitForFavorite then
        return
    end

    -- Equip the favorite tool first
    local favoriteTool = equipFavoriteTool()
    if not favoriteTool then
        return
    end

    -- Get player's farm
    local myFarm = getMyFarm()
    if not myFarm then
        print("âŒ No farm found")
        return
    end

    local important = myFarm:FindFirstChild("Important")
    local plantsPhysical = important and important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("âŒ No plants found in farm")
        return
    end

    -- Find plants matching the selected fruit
    local matchingPlants = {}
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        if string.find(plant.Name, SelectedFruitForFavorite) then
            table.insert(matchingPlants, plant)
        end
    end

    if #matchingPlants == 0 then
        print("âŒ No " .. SelectedFruitForFavorite .. " plants found")
        return
    end

    print("ðŸŽ¯ Found " .. #matchingPlants .. " " .. SelectedFruitForFavorite .. " plants to check")

    local favoritedCount = 0

    -- Process each matching plant
    for _, plant in pairs(matchingPlants) do
        if not AutoFavoriteEnabled then break end

        -- Check if plant already favorited (using "d" attribute)
        if plant:GetAttribute("d") ~= true then
            -- Check if fully grown (basic check)
            local grow = plant:FindFirstChild("Grow")
            local isFullyGrown = true
            if grow and grow:FindFirstChild("Age") then
                local maxAge = plant:GetAttribute("MaxAge")
                if maxAge and grow.Age.Value < maxAge then
                    print("ðŸŒ± Plant not fully grown:", plant.Name)
                    isFullyGrown = false
                end
            end

            if isFullyGrown then
                -- Look for fruits in the plant (this is what we actually favorite)
                local fruitsFolder = plant:FindFirstChild("Fruits")
                if fruitsFolder then
                    -- Find fruits that match our selected type and aren't favorited (using "d" attribute)
                    local fruitsToFavorite = {}
                    for _, fruit in pairs(fruitsFolder:GetChildren()) do
                        if string.find(fruit.Name, SelectedFruitForFavorite) and fruit:GetAttribute("d") ~= true then
                            -- Apply mutation filter
                            if hasSelectedMutationForFavorite(fruit) then
                                -- Apply variant filter
                                if hasSelectedVariantForFavorite(fruit) then
                                    table.insert(fruitsToFavorite, fruit)
                                else
                                    print("ðŸŽ¨ Fruit " .. fruit.Name .. " doesn't match variant filter")
                                end
                            else
                                print("ðŸ§¬ Fruit " .. fruit.Name .. " doesn't match mutation filter")
                            end
                        end
                    end

                    if #fruitsToFavorite > 0 then
                        -- Favorite each fruit using the exact structure from your working manual call
                        for _, fruit in pairs(fruitsToFavorite) do
                            print("ðŸŒŸ Attempting to favorite fruit:", fruit.Name, "in plant:", plant.Name)

                            local success, result = pcall(function()
                                -- Use the exact same structure as your working manual call
                                local args = {
                                    favoriteTool,  -- The equipped favorite tool
                                    fruit,         -- The actual fruit object (not the plant)
                                    true           -- true to favorite
                                }

                                local FavoriteToolRemote = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("FavoriteToolRemote")
                                return FavoriteToolRemote:InvokeServer(unpack(args))
                            end)

                            if success and result == true then
                                print("âœ… Successfully favorited fruit:", fruit.Name)
                                favoritedCount = favoritedCount + 1
                                if favoritedCount % 5 == 0 then -- Show notification every 5 favorites
                                    Library:Notify("â­ Favorited " .. favoritedCount .. " fruits", 2)
                                end
                            else
                                print("âŒ Failed to favorite fruit:", fruit.Name, "- Result:", result)
                                if result == false then
                                    print("âŒ Tool might be out of uses or fruit not eligible")
                                end
                            end

                            task.wait(0.3) -- Small delay between favorites
                        end
                    else
                        print("âŒ No unfavorited " .. SelectedFruitForFavorite .. " fruits matching filters found in plant (d!=true)")
                    end
                else
                    print("âŒ No Fruits folder found in:", plant.Name)
                end
            end
        else
            print("â­ Plant already favorited:", plant.Name)
        end

        task.wait(0.2) -- Small delay between plants
    end

    if favoritedCount > 0 then
        Library:Notify("âœ… Favorited " .. favoritedCount .. " " .. SelectedFruitForFavorite .. " fruits total!", 3)
    else
        Library:Notify("â„¹ï¸ No " .. SelectedFruitForFavorite .. " fruits needed favoriting", 2)
    end
end

-- Enhanced function to unfavorite fruits with filtering
local function autoUnfavoriteFilteredFruits()
    if not SelectedFruitForFavorite then
        print("ðŸ’” DEBUG: No fruit selected for unfavoriting")
        return
    end

    print("ðŸ’” DEBUG: Starting unfavorite process for:", SelectedFruitForFavorite)

    -- Equip the favorite tool first
    local favoriteTool = equipFavoriteTool()
    if not favoriteTool then
        print("ðŸ’” DEBUG: Failed to equip favorite tool")
        return
    end

    -- Get player's farm
    local myFarm = getMyFarm()
    if not myFarm then
        print("âŒ No farm found")
        return
    end

    local important = myFarm:FindFirstChild("Important")
    local plantsPhysical = important and important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("âŒ No plants found in farm")
        return
    end

    print("ðŸ’” DEBUG: Searching for plants containing:", SelectedFruitForFavorite)

    -- Find plants matching the selected fruit
    local matchingPlants = {}
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        if string.find(plant.Name, SelectedFruitForFavorite) then
            table.insert(matchingPlants, plant)
            print("ðŸ’” DEBUG: Found matching plant:", plant.Name)
        end
    end

    if #matchingPlants == 0 then
        print("âŒ No " .. SelectedFruitForFavorite .. " plants found")
        return
    end

    print("ðŸ’” Found " .. #matchingPlants .. " " .. SelectedFruitForFavorite .. " plants to check for unfavoriting")

    local unfavoritedCount = 0
    local totalFavoritedFruitsFound = 0

    -- Process each matching plant
    for _, plant in pairs(matchingPlants) do
        if not AutoUnfavoriteEnabled then break end

        print("ðŸ’” DEBUG: Checking plant:", plant.Name)

        -- Look for fruits in the plant
        local fruitsFolder = plant:FindFirstChild("Fruits")
        if not fruitsFolder then
            print("âŒ No Fruits folder found in:", plant.Name)
            continue
        end

        print("ðŸ’” DEBUG: Found fruits folder with", #fruitsFolder:GetChildren(), "items")

        -- Find fruits that match our selected type and ARE favorited (using "d" attribute)
        local fruitsToUnfavorite = {}
        for _, fruit in pairs(fruitsFolder:GetChildren()) do
            print("ðŸ’” DEBUG: Checking fruit:", fruit.Name, "- d attribute:", fruit:GetAttribute("d"))

            if string.find(fruit.Name, SelectedFruitForFavorite) then
                print("ðŸ’” DEBUG: Fruit matches selected type")

                -- Check if the "d" attribute is true (favorited)
                if fruit:GetAttribute("d") == true then
                    totalFavoritedFruitsFound = totalFavoritedFruitsFound + 1
                    print("ðŸ’” DEBUG: Fruit is favorited (d=true), checking filters...")

                    -- Apply mutation filter
                    if not hasSelectedMutationForFavorite(fruit) then
                        print("ðŸ§¬ Fruit " .. fruit.Name .. " doesn't match mutation filter")
                        continue
                    end

                    -- Apply variant filter
                    if not hasSelectedVariantForFavorite(fruit) then
                        print("ðŸŽ¨ Fruit " .. fruit.Name .. " doesn't match variant filter")
                        continue
                    end

                    print("ðŸ’” DEBUG: Fruit passed all filters, adding to unfavorite list")
                    table.insert(fruitsToUnfavorite, fruit)
                else
                    print("ðŸ’” DEBUG: Fruit is not favorited (d!=true), skipping")
                end
            else
                print("ðŸ’” DEBUG: Fruit does not match selected type")
            end
        end

        if #fruitsToUnfavorite == 0 then
            print("âŒ No favorited " .. SelectedFruitForFavorite .. " fruits matching filters found in plant")
            continue
        end

        print("ðŸ’” DEBUG: Found", #fruitsToUnfavorite, "fruits to unfavorite in this plant")

        -- Unfavorite each fruit
        for _, fruit in pairs(fruitsToUnfavorite) do
            print("ðŸ’” Attempting to unfavorite fruit:", fruit.Name, "in plant:", plant.Name)

            local success, result = pcall(function()
                local args = {
                    favoriteTool,  -- The equipped favorite tool
                    fruit,         -- The actual fruit object (not the plant)
                    false          -- false to unfavorite
                }

                local FavoriteToolRemote = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("FavoriteToolRemote")
                return FavoriteToolRemote:InvokeServer(unpack(args))
            end)

            if success and result == true then
                print("âœ… Successfully unfavorited fruit:", fruit.Name)
                unfavoritedCount = unfavoritedCount + 1
                if unfavoritedCount % 5 == 0 then -- Show notification every 5 unfavorites
                    Library:Notify("ðŸ’” Unfavorited " .. unfavoritedCount .. " fruits", 2)
                end
            else
                print("âŒ Failed to unfavorite fruit:", fruit.Name, "- Result:", result)
                print("ðŸ’” DEBUG: Success:", success, "Result:", result)
            end

            task.wait(0.3) -- Small delay between unfavorites
        end

        task.wait(0.2) -- Small delay between plants
    end

    print("ðŸ’” DEBUG: Final summary - Total favorited fruits found:", totalFavoritedFruitsFound, "- Unfavorited:", unfavoritedCount)

    if unfavoritedCount > 0 then
        Library:Notify("âœ… Unfavorited " .. unfavoritedCount .. " " .. SelectedFruitForFavorite .. " fruits total!", 3)
    else
        if totalFavoritedFruitsFound > 0 then
            Library:Notify("âš ï¸ Found " .. totalFavoritedFruitsFound .. " favorited " .. SelectedFruitForFavorite .. " fruits but none passed filters", 3)
        else
            Library:Notify("â„¹ï¸ No favorited " .. SelectedFruitForFavorite .. " fruits found", 2)
        end
    end
end

-- Function to unfavorite ALL fruits in farm (ignores filters)
local function autoUnfavoriteAllFruits()
    -- Equip the favorite tool first
    local favoriteTool = equipFavoriteTool()
    if not favoriteTool then
        return
    end

    -- Get player's farm
    local myFarm = getMyFarm()
    if not myFarm then
        print("âŒ No farm found")
        return
    end

    local important = myFarm:FindFirstChild("Important")
    local plantsPhysical = important and important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("âŒ No plants found in farm")
        return
    end

    print("ðŸš¨ Checking ALL plants for favorited fruits to unfavorite...")

    local unfavoritedCount = 0

    -- Process ALL plants in farm
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        if not AutoUnfavoriteAllEnabled then break end

        -- Look for fruits in the plant
        local fruitsFolder = plant:FindFirstChild("Fruits")
        if not fruitsFolder then
            continue
        end

        -- Find ALL fruits that ARE favorited (using "d" attribute)
        local fruitsToUnfavorite = {}
        for _, fruit in pairs(fruitsFolder:GetChildren()) do
            -- Check if the "d" attribute is true (favorited)
            if fruit:GetAttribute("d") == true then
                print("ðŸš¨ DEBUG: Found favorited fruit:", fruit.Name, "- d attribute:", fruit:GetAttribute("d"))
                table.insert(fruitsToUnfavorite, fruit)
            end
        end

        if #fruitsToUnfavorite == 0 then
            continue
        end

        -- Unfavorite each fruit
        for _, fruit in pairs(fruitsToUnfavorite) do
            print("ðŸš¨ Attempting to unfavorite ALL fruit:", fruit.Name, "in plant:", plant.Name)

            local success, result = pcall(function()
                local args = {
                    favoriteTool,  -- The equipped favorite tool
                    fruit,         -- The actual fruit object (not the plant)
                    false          -- false to unfavorite
                }

                local FavoriteToolRemote = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("FavoriteToolRemote")
                return FavoriteToolRemote:InvokeServer(unpack(args))
            end)

            if success and result == true then
                print("âœ… Successfully unfavorited ALL fruit:", fruit.Name)
                unfavoritedCount = unfavoritedCount + 1
                if unfavoritedCount % 10 == 0 then -- Show notification every 10 unfavorites
                    Library:Notify("ðŸš¨ Unfavorited " .. unfavoritedCount .. " fruits", 2)
                end
            else
                print("âŒ Failed to unfavorite ALL fruit:", fruit.Name, "- Result:", result)
            end

            task.wait(0.4) -- Slightly longer delay for safety when unfavoriting everything
        end

        task.wait(0.3) -- Delay between plants
    end

    if unfavoritedCount > 0 then
        Library:Notify("âœ… Unfavorited " .. unfavoritedCount .. " fruits total from entire farm!", 4)
    else
        Library:Notify("â„¹ï¸ No favorited fruits found in farm", 2)
    end
end

-- â­ Auto Favourite System UI
AutoFarmTab:AddLabel("â­ Auto Favourite System")
AutoFarmTab:AddDivider()

-- Fruit/Plant Selection Dropdown
AutoFarmTab:AddDropdown("FavoriteFruitSelect", {
    Values = AllFruits,
    Default = 1,
    Text = "Select Fruit/Plant Type",
    Tooltip = "Choose which type of fruit/plant to automatically favorite",
    Callback = function(Value)
        SelectedFruitForFavorite = Value
        print("ðŸŽ¯ Selected fruit for auto favourite:", Value)
        Library:Notify("Selected: " .. Value, 2)
    end,
})

-- Mutation Selection Dropdown
AutoFarmTab:AddDropdown("FavoriteMutationsSelect", {
    Values = AllMutations,
    Default = 1,
    Multi = true,
    Text = "Select Mutations",
    Tooltip = "Choose which mutations to filter for when favoriting. Leave empty to include all mutations.",
    Callback = function(Value)
        print("[cb] Selected mutations for favorite changed:")
        SelectedMutationsForFavorite = Value
        for mutation, selected in next, Options.FavoriteMutationsSelect.Value do
            print(mutation, selected)
        end
    end,
})

-- Mutation Filter Toggle
AutoFarmTab:AddToggle("FavoriteMutationFilter", {
    Text = "Enable Mutation Filter",
    Tooltip = "When enabled, only favorite fruits/plants that have the selected mutations above.",
    Default = false,
    Callback = function(Value)
        print("[cb] Favorite Mutation Filter toggled:", Value)
        FavoriteMutationFilterEnabled = Value
        if Value then
            local selectedCount = 0
            if SelectedMutationsForFavorite then
                for _, selected in pairs(SelectedMutationsForFavorite) do
                    if selected then selectedCount = selectedCount + 1 end
                end
            end
            if selectedCount > 0 then
                Library:Notify("ðŸ§¬ Favorite mutation filter enabled! Will only favorite " .. selectedCount .. " selected mutations", 3)
            else
                Library:Notify("âš ï¸ Favorite mutation filter enabled but no mutations selected!", 3)
            end
        else
            Library:Notify("ðŸ§¬ Favorite mutation filter disabled - favoriting all mutations", 2)
        end
    end,
})

-- Variant Selection Dropdown
AutoFarmTab:AddDropdown("FavoriteVariantsSelect", {
    Values = AllVariants,
    Default = 1,
    Multi = true,
    Text = "Select Variants",
    Tooltip = "Choose which variants to filter for when favoriting. Leave empty to include all variants.",
    Callback = function(Value)
        print("[cb] Selected variants for favorite changed:")
        SelectedVariantsForFavorite = Value
        for variant, selected in next, Options.FavoriteVariantsSelect.Value do
            print(variant, selected)
        end
    end,
})

-- Variant Filter Toggle
AutoFarmTab:AddToggle("FavoriteVariantFilter", {
    Text = "Enable Variant Filter",
    Tooltip = "When enabled, only favorite fruits/plants that have the selected variants above.",
    Default = false,
    Callback = function(Value)
        print("[cb] Favorite Variant Filter toggled:", Value)
        FavoriteVariantFilterEnabled = Value
        if Value then
            local selectedCount = 0
            if SelectedVariantsForFavorite then
                for _, selected in pairs(SelectedVariantsForFavorite) do
                    if selected then selectedCount = selectedCount + 1 end
                end
            end
            if selectedCount > 0 then
                Library:Notify("âœ¨ Favorite variant filter enabled! Will only favorite " .. selectedCount .. " selected variants", 3)
            else
                Library:Notify("âš ï¸ Favorite variant filter enabled but no variants selected!", 3)
            end
        else
            Library:Notify("âœ¨ Favorite variant filter disabled - favoriting all variants", 2)
        end
    end,
})

AutoFarmTab:AddDivider()

-- Auto Favorite Plants Toggle
AutoFarmTab:AddToggle("AutoFavoritePlants", {
    Text = "Auto Favorite Plants",
    Default = false,
    Tooltip = "Automatically favorite plants/fruits matching your filters",
    Callback = function(Value)
        AutoFavoriteEnabled = Value
        if Value then
            if not SelectedFruitForFavorite then
                Library:Notify("âš ï¸ Please select a fruit/plant type first!", 3)
                Toggles.AutoFavoritePlants:SetValue(false)
                return
            end

            local filterInfo = ""
            if FavoriteMutationFilterEnabled then
                local mutationCount = 0
                if SelectedMutationsForFavorite then
                    for _, selected in pairs(SelectedMutationsForFavorite) do
                        if selected then mutationCount = mutationCount + 1 end
                    end
                end
                filterInfo = filterInfo .. " | Mutations: " .. mutationCount
            end
            if FavoriteVariantFilterEnabled then
                local variantCount = 0
                if SelectedVariantsForFavorite then
                    for _, selected in pairs(SelectedVariantsForFavorite) do
                        if selected then variantCount = variantCount + 1 end
                    end
                end
                filterInfo = filterInfo .. " | Variants: " .. variantCount
            end

            Library:Notify("â­ Auto Favorite enabled for " .. SelectedFruitForFavorite .. filterInfo, 3)

            -- Start the auto favourite loop
            task.spawn(function()
                while AutoFavoriteEnabled do
                    if AutoFavoriteEnabled then
                        autoFavoriteFilteredFruits()
                    end
                    task.wait(5) -- Check every 5 seconds
                end
            end)
        else
            Library:Notify("â­ Auto Favorite disabled!", 3)
        end
    end,
})

-- Auto UnFavorite Plants Toggle
AutoFarmTab:AddToggle("AutoUnFavoritePlants", {
    Text = "Auto UnFavorite Plants",
    Default = false,
    Tooltip = "Automatically unfavorite plants/fruits matching your filters",
    Callback = function(Value)
        AutoUnfavoriteEnabled = Value
        if Value then
            if not SelectedFruitForFavorite then
                Library:Notify("âš ï¸ Please select a fruit/plant type first!", 3)
                Toggles.AutoUnFavoritePlants:SetValue(false)
                return
            end

            Library:Notify("ðŸ’” Auto UnFavorite enabled for " .. SelectedFruitForFavorite, 3)

            -- Start the auto unfavourite loop
            task.spawn(function()
                while AutoUnfavoriteEnabled do
                    if AutoUnfavoriteEnabled then
                        autoUnfavoriteFilteredFruits()
                    end
                    task.wait(5) -- Check every 5 seconds
                end
            end)
        else
            Library:Notify("ðŸ’” Auto UnFavorite disabled!", 3)
        end
    end,
})

-- Auto UnFavorite All Plants Toggle
AutoFarmTab:AddToggle("AutoUnFavoriteAllPlants", {
    Text = "Auto UnFavorite All Plants",
    Default = false,
    Tooltip = "Automatically unfavorite ALL plants in your farm (ignores filters)",
    Callback = function(Value)
        AutoUnfavoriteAllEnabled = Value
        if Value then
            Library:Notify("ðŸš¨ Auto UnFavorite ALL enabled! This will unfavorite everything!", 4)

            -- Start the auto unfavourite all loop
            task.spawn(function()
                while AutoUnfavoriteAllEnabled do
                    if AutoUnfavoriteAllEnabled then
                        autoUnfavoriteAllFruits()
                    end
                    task.wait(8) -- Check every 8 seconds (longer delay for safety)
                end
            end)
        else
            Library:Notify("ðŸš¨ Auto UnFavorite ALL disabled!", 3)
        end
    end,
})

-- Manual Action Buttons
AutoFarmTab:AddDivider()

AutoFarmTab:AddButton("ðŸŒŸ Favorite Now", {
    Text = "ðŸŒŸ Favorite Selected Now",
    Func = function()
        if not SelectedFruitForFavorite then
            Library:Notify("âš ï¸ Please select a fruit/plant type first!", 3)
            return
        end

        Library:Notify("ðŸŒŸ Finding and favoriting " .. SelectedFruitForFavorite .. " fruits...", 3)
        task.spawn(autoFavoriteFilteredFruits)
    end,
    Tooltip = "Manually run the favoriting process once for the selected filters",
})

AutoFarmTab:AddButton("ðŸ’” UnFavorite Now", {
    Text = "ðŸ’” UnFavorite Selected Now",
    Func = function()
        if not SelectedFruitForFavorite then
            Library:Notify("âš ï¸ Please select a fruit/plant type first!", 3)
            return
        end

        Library:Notify("ðŸ’” Finding and unfavoriting " .. SelectedFruitForFavorite .. " fruits...", 3)
        task.spawn(autoUnfavoriteFilteredFruits)
    end,
    Tooltip = "Manually run the unfavoriting process once for the selected filters",
})

AutoFarmTab:AddButton("ðŸš¨ UnFavorite ALL Now", {
    Text = "ðŸš¨ UnFavorite ALL Now",
    Func = function()
        Library:Notify("ðŸš¨ Unfavoriting ALL fruits in your farm...", 4)
        task.spawn(autoUnfavoriteAllFruits)
    end,
    Tooltip = "Manually unfavorite ALL fruits in your farm (ignores all filters)",
})

AutoFarmTab:AddDivider()

-- Tab 2: Auto Favourite Inventory
local AutoInventoryTab = LeftAutoTabBox:AddTab("Auto Favourite Inventory")

-- â­ Auto Favourite Inventory System Variables
local AutoFavoriteInventoryEnabled = false
local SelectedInventoryItems = {}
local InventoryFavoriteMinWeight = 1
local FavoriteInventoryByWeight = false
local FavoriteInventoryByType = false

-- Function to get all items in backpack
local function getBackpackItems()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local items = {}

    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                table.insert(items, item)
            end
        end
    end

    return items
end

-- Function to extract weight from item name
local function extractWeight(itemName)
    local weight = string.match(itemName, "%[([%d%.]+)kg%]")
    return weight and tonumber(weight) or 0
end

-- Function to extract item type from name (remove weight and quantity)
local function getItemType(itemName)
    local cleanName = itemName
    -- Remove weight indicators like [6.64kg]
    cleanName = string.gsub(cleanName, "%s*%[%d+%.?%d*kg%]", "")
    -- Remove quantity indicators like [X5], [X10], etc.
    cleanName = string.gsub(cleanName, "%s*%[X%d+%]", "")
    -- Trim whitespace
    cleanName = cleanName:gsub("^%s+", ""):gsub("%s+$", "")
    return cleanName
end

-- Function to auto favorite inventory items
local function autoFavoriteInventoryItems()
    print("ðŸ“¦ DEBUG: Starting inventory favorite process")

    local backpackItems = getBackpackItems()

    if #backpackItems == 0 then
        print("ðŸ“¦ DEBUG: No items found in backpack")
        Library:Notify("ðŸ“¦ No items found in backpack", 2)
        return
    end

    print("ðŸ“¦ DEBUG: Found", #backpackItems, "items in backpack")

    local favoritedCount = 0

    for _, item in pairs(backpackItems) do
        if not AutoFavoriteInventoryEnabled then break end

        local itemName = item.Name
        local itemType = getItemType(itemName)
        local itemWeight = extractWeight(itemName)

        print("ðŸ“¦ DEBUG: Checking item:", itemName, "- Type:", itemType, "- Weight:", itemWeight)

        -- Check if item is already favorited (using "d" attribute)
        if item:GetAttribute("d") == true then
            print("ðŸ“¦ DEBUG: Item already favorited:", itemName)
            continue
        end

        local shouldFavorite = false

        -- Check type filter
        if FavoriteInventoryByType and SelectedInventoryItems and next(SelectedInventoryItems) then
            for selectedType, selected in pairs(SelectedInventoryItems) do
                if selected and string.find(itemType, selectedType) then
                    shouldFavorite = true
                    print("ðŸ“¦ DEBUG: Item matches selected type filter:", selectedType)
                    break
                end
            end
        end

        -- Check weight filter
        if FavoriteInventoryByWeight and itemWeight >= InventoryFavoriteMinWeight then
            shouldFavorite = true
            print("ðŸ“¦ DEBUG: Item meets weight requirement:", itemWeight, ">=", InventoryFavoriteMinWeight)
        end

        -- If no filters enabled, favorite everything
        if not FavoriteInventoryByType and not FavoriteInventoryByWeight then
            shouldFavorite = true
            print("ðŸ“¦ DEBUG: No filters enabled, favoriting all items")
        end

        if shouldFavorite then
            print("ðŸ“¦ Attempting to favorite inventory item:", itemName)

            local success, result = pcall(function()
                local FavoriteItemRemote = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Favorite_Item")
                FavoriteItemRemote:FireServer(item)
                return true
            end)

            if success then
                print("âœ… Successfully favorited inventory item:", itemName)
                favoritedCount = favoritedCount + 1
                if favoritedCount % 10 == 0 then -- Show notification every 10 favorites
                    Library:Notify("ðŸ“¦ Favorited " .. favoritedCount .. " inventory items", 2)
                end
            else
                print("âŒ Failed to favorite inventory item:", itemName, "- Error:", result)
            end

            task.wait(0.2) -- Small delay between favorites
        else
            print("ðŸ“¦ DEBUG: Item doesn't meet criteria, skipping:", itemName)
        end
    end

    if favoritedCount > 0 then
        Library:Notify("âœ… Favorited " .. favoritedCount .. " inventory items total!", 3)
    else
        Library:Notify("â„¹ï¸ No inventory items needed favoriting", 2)
    end
end

-- Function to auto unfavorite inventory items
local function autoUnfavoriteInventoryItems()
    print("ðŸ“¦ðŸ’” DEBUG: Starting inventory unfavorite process")

    local backpackItems = getBackpackItems()

    if #backpackItems == 0 then
        print("ðŸ“¦ðŸ’” DEBUG: No items found in backpack")
        Library:Notify("ðŸ“¦ No items found in backpack", 2)
        return
    end

    print("ðŸ“¦ðŸ’” DEBUG: Found", #backpackItems, "items in backpack")

    local unfavoritedCount = 0

    for _, item in pairs(backpackItems) do
        local itemName = item.Name

        print("ðŸ“¦ðŸ’” DEBUG: Checking item:", itemName, "- d attribute:", item:GetAttribute("d"))

        -- Check if item is favorited (using "d" attribute)
        if item:GetAttribute("d") == true then
            print("ðŸ“¦ðŸ’” Attempting to unfavorite inventory item:", itemName)

            local success, result = pcall(function()
                -- Use the same Favorite_Item remote - calling it on a favorited item will unfavorite it
                local FavoriteItemRemote = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("Favorite_Item")
                FavoriteItemRemote:FireServer(item)
                return true
            end)

            if success then
                print("âœ… Successfully unfavorited inventory item:", itemName)
                unfavoritedCount = unfavoritedCount + 1
                if unfavoritedCount % 10 == 0 then -- Show notification every 10 unfavorites
                    Library:Notify("ðŸ“¦ðŸ’” Unfavorited " .. unfavoritedCount .. " inventory items", 2)
                end
            else
                print("âŒ Failed to unfavorite inventory item:", itemName, "- Error:", result)
            end

            task.wait(0.2) -- Small delay between unfavorites
        else
            print("ðŸ“¦ðŸ’” DEBUG: Item not favorited (d!=true), skipping:", itemName)
        end
    end

    if unfavoritedCount > 0 then
        Library:Notify("âœ… Unfavorited " .. unfavoritedCount .. " inventory items total!", 3)
    else
        Library:Notify("â„¹ï¸ No favorited inventory items found", 2)
    end
end

-- â­ Auto Favourite Inventory UI
AutoInventoryTab:AddLabel("ðŸ“¦ Auto Favourite Inventory System")
AutoInventoryTab:AddDivider()

-- Item Type Selection Dropdown
AutoInventoryTab:AddDropdown("InventoryItemSelect", {
    Values = AllFruits, -- Use same list as main fruits
    Default = 1,
    Multi = true,
    Text = "Select Item Types",
    Tooltip = "Choose which types of items to automatically favorite in your inventory",
    Callback = function(Value)
        print("[cb] Selected inventory items changed:")
        SelectedInventoryItems = Value
        for item, selected in next, Options.InventoryItemSelect.Value do
            print(item, selected)
        end
    end,
})

-- Type Filter Toggle
AutoInventoryTab:AddToggle("FavoriteInventoryByType", {
    Text = "Enable Type Filter",
    Tooltip = "When enabled, only favorite inventory items that match the selected types above.",
    Default = false,
    Callback = function(Value)
        print("[cb] Inventory Type Filter toggled:", Value)
        FavoriteInventoryByType = Value
        if Value then
            local selectedCount = 0
            if SelectedInventoryItems then
                for _, selected in pairs(SelectedInventoryItems) do
                    if selected then selectedCount = selectedCount + 1 end
                end
            end
            if selectedCount > 0 then
                Library:Notify("ðŸ“¦ Inventory type filter enabled! Will only favorite " .. selectedCount .. " selected types", 3)
            else
                Library:Notify("âš ï¸ Inventory type filter enabled but no types selected!", 3)
            end
        else
            Library:Notify("ðŸ“¦ Inventory type filter disabled - favoriting all types", 2)
        end
    end,
})

-- Weight Filter
AutoInventoryTab:AddSlider("InventoryMinWeight", {
    Text = "Minimum Weight (kg)",
    Default = 1,
    Min = 0,
    Max = 100,
    Rounding = 2,
    Compact = false,
    Tooltip = "Minimum weight required to favorite an item (only works if weight filter is enabled)",
    Callback = function(Value)
        InventoryFavoriteMinWeight = Value
        print("[cb] Inventory minimum weight set to:", Value, "kg")
    end,
})

-- Weight Filter Toggle
AutoInventoryTab:AddToggle("FavoriteInventoryByWeight", {
    Text = "Enable Weight Filter",
    Tooltip = "When enabled, only favorite inventory items that meet the minimum weight requirement.",
    Default = false,
    Callback = function(Value)
        print("[cb] Inventory Weight Filter toggled:", Value)
        FavoriteInventoryByWeight = Value
        if Value then
            Library:Notify("âš–ï¸ Inventory weight filter enabled! Minimum weight: " .. InventoryFavoriteMinWeight .. "kg", 3)
        else
            Library:Notify("âš–ï¸ Inventory weight filter disabled", 2)
        end
    end,
})

AutoInventoryTab:AddDivider()

-- Auto Favorite Inventory Toggle
AutoInventoryTab:AddToggle("AutoFavoriteInventory", {
    Text = "Auto Favorite Inventory",
    Default = false,
    Tooltip = "Automatically favorite items in your inventory based on your filters",
    Callback = function(Value)
        AutoFavoriteInventoryEnabled = Value
        if Value then
            local filterInfo = ""
            if FavoriteInventoryByType then
                local typeCount = 0
                if SelectedInventoryItems then
                    for _, selected in pairs(SelectedInventoryItems) do
                        if selected then typeCount = typeCount + 1 end
                    end
                end
                filterInfo = filterInfo .. " | Types: " .. typeCount
            end
            if FavoriteInventoryByWeight then
                filterInfo = filterInfo .. " | Min Weight: " .. InventoryFavoriteMinWeight .. "kg"
            end

            Library:Notify("ðŸ“¦ Auto Favorite Inventory enabled" .. filterInfo, 3)

            -- Start the auto favorite inventory loop
            task.spawn(function()
                while AutoFavoriteInventoryEnabled do
                    if AutoFavoriteInventoryEnabled then
                        autoFavoriteInventoryItems()
                    end
                    task.wait(10) -- Check every 10 seconds (less frequent than farm)
                end
            end)
        else
            Library:Notify("ðŸ“¦ Auto Favorite Inventory disabled!", 3)
        end
    end,
})

-- Manual Action Buttons
AutoInventoryTab:AddDivider()

AutoInventoryTab:AddButton("ðŸ“¦ðŸŒŸ Favorite Inventory Now", {
    Text = "ðŸ“¦ðŸŒŸ Favorite Inventory Now",
    Func = function()
        Library:Notify("ðŸ“¦ Favoriting inventory items...", 3)
        task.spawn(autoFavoriteInventoryItems)
    end,
    Tooltip = "Manually favorite all inventory items matching your filters",
})

AutoInventoryTab:AddButton("ðŸ“¦ðŸ’” UnFavorite Inventory Now", {
    Text = "ðŸ“¦ðŸ’” UnFavorite Inventory Now",
    Func = function()
        Library:Notify("ðŸ“¦ðŸ’” Unfavoriting inventory items...", 3)
        task.spawn(autoUnfavoriteInventoryItems)
    end,
    Tooltip = "Manually unfavorite all favorited items in your inventory (uses same Favorite_Item remote)",
})

AutoInventoryTab:AddDivider()

-- Right Tabbox for Auto Settings
local RightAutoTabBox = Tabs.Auto:AddRightTabbox("Auto Settings")

-- Tab 1: Auto Watercan Settings
local AutoWatercanTab = RightAutoTabBox:AddTab("Auto Watercan")

-- Global variables for Auto Watercan
local AutoWaterEnabled = false
local SelectedFruitToWater = "Strawberry"
local WateringInterval = 60 -- Seconds between watering cycles
local WaterCanToolName = "Watering Can [152x Uses]" -- Name of the watering can tool

-- Function to check if the watering can is in inventory
local function hasWateringCanInInventory()
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local wateringCan = nil

    -- Check backpack
    if backpack then
        -- Look for any watering can tool (exact name might vary with uses)
        for _, tool in pairs(backpack:GetChildren()) do
            if string.match(tool.Name, "Watering Can") then
                return true, tool.Name
            end
        end
    end

    -- Check if already equipped
    if LocalPlayer.Character then
        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
            if string.match(tool.Name, "Watering Can") then
                return true, tool.Name
            end
        end
    end

    return false, nil
end

-- Function to equip the watering can
local function equipWateringCan()
    local hasWateringCan, canName = hasWateringCanInInventory()
    if not hasWateringCan then
        Library:Notify("âŒ No watering can found in inventory!", 3)
        return false
    end

    local backpack = LocalPlayer:FindFirstChild("Backpack")
    if not backpack then return false end

    -- Check if already equipped
    if LocalPlayer.Character then
        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
            if string.match(tool.Name, "Watering Can") then
                return true -- Already equipped
            end
        end
    end

    -- Find the watering can and equip it
    for _, tool in pairs(backpack:GetChildren()) do
        if string.match(tool.Name, "Watering Can") then
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                tool.Parent = LocalPlayer.Character
                return true
            end
        end
    end

    return false
end

-- Function to find plants of the selected type
local function findSelectedFruitPlants()
    local myFarm = getMyFarm()
    if not myFarm then
        print("âŒ No farm found")
        return {}
    end

    local important = myFarm:FindFirstChild("Important")
    if not important then
        print("âŒ No Important folder found")
        return {}
    end

    local plantsPhysical = important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("âŒ No Plants_Physical folder found")
        return {}
    end

    local selectedPlants = {}

    for _, plant in pairs(plantsPhysical:GetChildren()) do
        if string.find(plant.Name, SelectedFruitToWater) then
            -- First try to find the Base part
            local basePart = plant:FindFirstChild("Base")
            if basePart then
                table.insert(selectedPlants, basePart)
            else
                -- If no Base part, try to find part named "1" as fallback
                local part1 = plant:FindFirstChild("1")
                if part1 then
                    table.insert(selectedPlants, part1)
                end
            end
        end
    end

    return selectedPlants
end

-- Function to water a plant
local function waterPlant(plantBase)
    if not plantBase or not plantBase.Parent then return false end

    local Water_RE = Services.ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("Water_RE")

    -- Get the position of the base part
    local position = plantBase.Position

    -- Fire the water remote event with the position
    local args = {
        Vector3.new(position.X, position.Y, position.Z)
    }

    local success, err = pcall(function()
        Water_RE:FireServer(unpack(args))
    end)

    if not success then
        print("âŒ Failed to water plant:", err)
        return false
    end

    return true
end

-- Function to run the auto water cycle - Continuous watering until toggle off or watering can runs out
local function runAutoWaterCycle()
    if not AutoWaterEnabled then return end

    print("ðŸš¿ Starting continuous watering for " .. SelectedFruitToWater)
    Library:Notify("ðŸš¿ Starting continuous watering for " .. SelectedFruitToWater, 3)

    local totalWateredCount = 0

    while AutoWaterEnabled do
        -- Check if watering can is still available
        local hasWateringCan, canName = hasWateringCanInInventory()
        if not hasWateringCan then
            Library:Notify("âš ï¸ Watering can is empty or missing - stopping auto water", 3)
            AutoWaterEnabled = false
            Options.AutoWaterFruits:SetValue(false)
            break
        end

        -- Equip the watering can
        if not equipWateringCan() then
            Library:Notify("âŒ Failed to equip watering can - stopping auto water", 3)
            AutoWaterEnabled = false
            Options.AutoWaterFruits:SetValue(false)
            break
        end

        -- Find plants to water
        local plantsToWater = findSelectedFruitPlants()

        if #plantsToWater == 0 then
            Library:Notify("âš ï¸ No " .. SelectedFruitToWater .. " plants found to water", 3)
            task.wait(2)
            continue
        end

        -- Water each plant (base or part1)
        local cycleWateredCount = 0
        for _, plantPart in pairs(plantsToWater) do
            if not AutoWaterEnabled then break end

            -- Check again if watering can is still available
            if not hasWateringCanInInventory() then
                Library:Notify("âš ï¸ Watering can is empty - stopping auto water", 3)
                AutoWaterEnabled = false
                Options.AutoWaterFruits:SetValue(false)
                break
            end

            if waterPlant(plantPart) then
                cycleWateredCount = cycleWateredCount + 1
                totalWateredCount = totalWateredCount + 1
            end

            task.wait(0.5) -- Small delay between watering actions
        end

        -- Update watering count every cycle
        if cycleWateredCount > 0 then
            Library:Notify("ðŸš¿ Watered " .. cycleWateredCount .. " " .. SelectedFruitToWater .. " plants (Total: " .. totalWateredCount .. ")", 2)
        end

        task.wait(1) -- Short break before starting the next cycle
    end

    Library:Notify("âœ… Watering finished! Total watered: " .. totalWateredCount .. " " .. SelectedFruitToWater .. " plants", 3)
end

-- Water automation section
AutoWatercanTab:AddLabel("Automation Water")
AutoWatercanTab:AddDivider()

-- Dropdown for selecting fruits to water
AutoWatercanTab:AddDropdown("SelectFruits", {
    Values = {
        -- All plants/fruits from game files (PlantTraitsData + SeedData) - 2025 Update
        "Aloe Vera",
        "Apple",
        "Avocado",
        "Bamboo",
        "Banana",
        "Beanstalk",
        "Bee Balm",
        "Bell Pepper",
        "Bendboo",
        "Blood Banana",
        "Blue Lollipop",
        "Blueberry",
        "Burning Bud",
        "Cacao",
        "Cactus",
        "Candy Blossom",
        "Candy Sunflower",
        "Cantaloupe",
        "Carrot",
        "Cauliflower",
        "Celestiberry",
        "Cherry Blossom",
        "Chocolate Carrot",
        "Cocovine",
        "Coconut",
        "Corn",
        "Cranberry",
        "Crimson Vine",
        "Crocus",
        "Cursed Fruit",
        "Daffodil",
        "Dandelion",
        "Delphinium",
        "Dragon Fruit",
        "Dragon Pepper",
        "Durian",
        "Easter Egg",
        "Eggplant",
        "Elephant Ears",
        "Ember Lily",
        "Feijoa",
        "Foxglove",
        "Glowshroom",
        "Grape",
        "Green Apple",
        "Guanabana",
        "Hive Fruit",
        "Honeysuckle",
        "Ice Cream Bean",
        "Kiwi",
        "Lavender",
        "Lemon",
        "Lilac",
        "Lily of the Valley",
        "Lime",
        "Loquat",
        "Lotus",
        "Lumira",
        "Mango",
        "Manuka Flower",
        "Mega Mushroom",
        "Mint",
        "Moon Blossom",
        "Moon Mango",
        "Moon Melon",
        "Moonflower",
        "Moonglow",
        "Mushroom",
        "Nectar Thorn",
        "Nectarine",
        "Nectarshade",
        "Nightshade",
        "Noble Flower",
        "Orange Tulip",
        "Papaya",
        "Parasol Flower",
        "Passionfruit",
        "Peace Lily",
        "Peach",
        "Pear",
        "Pepper",
        "Pineapple",
        "Pink Lily",
        "Pink Tulip",
        "Pitcher Plant",
        "Prickly Pear",
        "Pumpkin",
        "Purple Cabbage",
        "Purple Dahlia",
        "Rafflesia",
        "Raspberry",
        "Red Lollipop",
        "Rose",
        "Rosy Delight",
        "Soul Fruit",
        "Starfruit",
        "Strawberry",
        "Succulent",
        "Sugar Apple",
        "Suncoil",
        "Sunflower",
        "Tomato",
        "Traveler's Fruit",
        "Venus Fly Trap",
        "Violet Corn",
        "Watermelon",
        "White Mullberry",
        "Wild Carrot",
    },
    Default = 1, -- Default to Aloe Vera
    Multi = false,
    Text = "Select Plant to Water",
    Tooltip = "Choose which plant to auto water (base only, not fruits)",
    Callback = function(Value)
        SelectedFruitToWater = Value
        print("[Auto Water] Selected plant:", Value)
    end
})

-- Toggle for auto watering plant bases
AutoWatercanTab:AddToggle("AutoWaterFruits", {
    Text = "Auto Water Plant Bases",
    Default = false,
    Tooltip = "Continuously water plant bases until watering can is empty or toggle is turned off",
    Callback = function(Value)
        AutoWaterEnabled = Value
        if Value then
            Library:Notify("ðŸš¿ Starting continuous watering for " .. SelectedFruitToWater, 3)

            -- Start continuous watering loop without intervals
            task.spawn(function()
                runAutoWaterCycle()
            end)
        else
            Library:Notify("ðŸš¿ Auto Watering disabled!", 3)
            Options.AutoWaterFruits:SetText("Auto Water Plant Bases")
        end
    end
})

-- Tab 2: Calculator
local CalculatorTab = RightAutoTabBox:AddTab("Calculator")

-- Function to format numbers with commas
local function formatNumber(num)
    local formatted = tostring(num)
    local k
    while true do
        formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
        if k == 0 then break end
    end
    return formatted
end

-- Function to calculate inventory value using exact CalculatePlantValue logic
local function calculateInventoryValue()
    print("ðŸ’° DEBUG: Starting inventory value calculation...")

    -- Try to load the official CalculatePlantValue module
    local CalculatePlantValue, Item_Module, MutationHandler
    local success, result = pcall(function()
        return require(game:GetService("ReplicatedStorage").Modules.ModuleScripts.CalculatePlantValue.module)
    end)
    if success then
        CalculatePlantValue = result
        print("ðŸ’° DEBUG: Successfully loaded official CalculatePlantValue module")
    else
        print("ðŸ’° DEBUG: Failed to load official CalculatePlantValue module:", result)
        print("ðŸ’° DEBUG: Falling back to manual implementation")

        -- Load required modules with correct paths
        success, result = pcall(function()
            return require(game:GetService("ReplicatedStorage").ModuleScripts.Item_Module.module)
        end)
        if success then
            Item_Module = result
            print("ðŸ’° DEBUG: Successfully loaded Item_Module")
        else
            print("ðŸ’° DEBUG: Failed to load Item_Module:", result)
            -- Try alternative path
            success, result = pcall(function()
                return require(game:GetService("ReplicatedStorage").Item_Module)
            end)
            if success then
                Item_Module = result
                print("ðŸ’° DEBUG: Successfully loaded Item_Module from alternative path")
            else
                print("ðŸ’° DEBUG: Failed to load Item_Module from all paths:", result)
                return 0, 0
            end
        end

        success, result = pcall(function()
            return require(game:GetService("ReplicatedStorage").Modules.ModuleScripts.MutationHandler.module)
        end)
        if success then
            MutationHandler = result
            print("ðŸ’° DEBUG: Successfully loaded MutationHandler")
        else
            print("ðŸ’° DEBUG: Failed to load MutationHandler:", result)
            -- Try alternative path
            success, result = pcall(function()
                return require(game:GetService("ReplicatedStorage").Modules.MutationHandler)
            end)
            if success then
                MutationHandler = result
                print("ðŸ’° DEBUG: Successfully loaded MutationHandler from alternative path")
            else
                print("ðŸ’° DEBUG: Failed to load MutationHandler from all paths:", result)
                return 0, 0
            end
        end
    end

    -- Calculate inventory total (backpack items)
    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local total = 0
    local itemsProcessed = 0

    print("ðŸ’° DEBUG: Backpack found:", backpack ~= nil)

    local function calculateItemValue(item)
        -- If we have the official module, use it
        if CalculatePlantValue then
            -- Skip seeds
            local Item_String = item:FindFirstChild("Item_String")
            local itemStringValue = (Item_String and Item_String.Value) and Item_String.Value or item.Name

            if string.match(itemStringValue:lower(), "seed") then
                return 0
            end

            -- Use the official module to calculate value
            local value = CalculatePlantValue(item)

            print("ðŸ’° DEBUG: Processing item using official module - Name:", item.Name, "Value:", value)

            return value
        end

        -- Fallback to our implementation if official module isn't available
        -- Get item children using exact same logic as CalculatePlantValue
        local Item_String = item:FindFirstChild("Item_String")
        local itemStringValue
        if not Item_String or not Item_String.Value then
            itemStringValue = item.Name
        else
            itemStringValue = Item_String.Value
        end

        local Variant = item:FindFirstChild("Variant")
        if not Variant then
            return 0
        end

        local Weight = item:FindFirstChild("Weight")
        if not Weight then
            return 0
        end

        print("ðŸ’° DEBUG: Processing item - Name:", item.Name, "Item_String:", itemStringValue, "Variant:", Variant.Value, "Weight:", Weight.Value)

        -- Skip seeds (same logic as your existing code)
        if string.match(itemStringValue:lower(), "seed") then
            return 0
        end

        -- Get data using exact same method as CalculatePlantValue
        local itemData = Item_Module.Return_Data(itemStringValue)
        if not itemData or #itemData < 3 then
            return 0
        end

        -- Apply exact same calculation as CalculatePlantValue
        local clamped = math.clamp(Weight.Value / itemData[2], 0.95, 100000000)
        local value = math.round((itemData[3] * MutationHandler:CalcValueMulti(item) * Item_Module.Return_Multiplier(Variant.Value)) * (clamped * clamped))

        return value
    end

    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item:IsA("Tool") then
                local itemValue = calculateItemValue(item)
                total = total + itemValue
                itemsProcessed = itemsProcessed + 1
            end
        end
    end

    -- Also check equipped items
    if LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") then
                local itemValue = calculateItemValue(item)
                total = total + itemValue
                itemsProcessed = itemsProcessed + 1
            end
        end
    end

    print("ðŸ’° DEBUG: Final calculation - Total:", total, "Items processed:", itemsProcessed)

    -- Round to 2 decimal places
    total = math.floor(total * 100) / 100

    return total, itemsProcessed
end

-- Function to calculate the total value of all plants in the farm using exact game logic
local function calculateFarmValue()
    print("ðŸŒ¿ DEBUG: Starting farm value calculation...")

    -- Try to load the official CalculatePlantValue module
    local CalculatePlantValue, Item_Module, MutationHandler, StringUtils
    local success, result = pcall(function()
        return require(game:GetService("ReplicatedStorage").Modules.ModuleScripts.CalculatePlantValue.module)
    end)
    if success then
        CalculatePlantValue = result
        print("ðŸŒ¿ DEBUG: Successfully loaded official CalculatePlantValue module")
    else
        print("ðŸŒ¿ DEBUG: Failed to load official CalculatePlantValue module:", result)
        print("ðŸŒ¿ DEBUG: Falling back to manual implementation")

        -- Load required modules with correct paths
        success, result = pcall(function()
            return require(game:GetService("ReplicatedStorage").ModuleScripts.Item_Module.module)
        end)
        if success then
            Item_Module = result
            print("ðŸŒ¿ DEBUG: Successfully loaded Item_Module")
        else
            print("ðŸŒ¿ DEBUG: Failed to load Item_Module:", result)
            -- Try alternative path
            success, result = pcall(function()
                return require(game:GetService("ReplicatedStorage").Item_Module)
            end)
            if success then
                Item_Module = result
                print("ðŸŒ¿ DEBUG: Successfully loaded Item_Module from alternative path")
            else
                print("ðŸŒ¿ DEBUG: Failed to load Item_Module from all paths:", result)
                return 0, 0
            end
        end

        success, result = pcall(function()
            return require(game:GetService("ReplicatedStorage").Modules.ModuleScripts.MutationHandler.module)
        end)
        if success then
            MutationHandler = result
            print("ðŸŒ¿ DEBUG: Successfully loaded MutationHandler")
        else
            print("ðŸŒ¿ DEBUG: Failed to load MutationHandler:", result)
            -- Try alternative path
            success, result = pcall(function()
                return require(game:GetService("ReplicatedStorage").Modules.MutationHandler)
            end)
            if success then
                MutationHandler = result
                print("ðŸŒ¿ DEBUG: Successfully loaded MutationHandler from alternative path")
            else
                print("ðŸŒ¿ DEBUG: Failed to load MutationHandler from all paths:", result)
                return 0, 0
            end
        end

        success, result = pcall(function()
            return require(game:GetService("ReplicatedStorage").Modules.ModuleScripts.StringUtils.module)
        end)
        if success then
            StringUtils = result
            print("ðŸŒ¿ DEBUG: Successfully loaded StringUtils")
        else
            print("ðŸŒ¿ DEBUG: Failed to load StringUtils:", result)
            -- Try alternative path
            success, result = pcall(function()
                return require(game:GetService("ReplicatedStorage").Modules.StringUtils)
            end)
            if success then
                StringUtils = result
                print("ðŸŒ¿ DEBUG: Successfully loaded StringUtils from alternative path")
            else
                print("ðŸŒ¿ DEBUG: Failed to load StringUtils from all paths:", result)
                -- StringUtils is not critical, so we can continue without it
            end
        end
    end

    -- Function to calculate plant value
    local function calculatePlantValue(plant)
        -- If we have the official module, use it
        if CalculatePlantValue then
            local value = CalculatePlantValue(plant)
            print("ðŸŒ¿ DEBUG: Using official module for plant:", plant.Name, "Value:", value)
            return value
        end

        -- Fallback to our implementation if official module isn't available
        -- Get Item_String or use plant name
        local Item_String = plant:FindFirstChild("Item_String")
        local itemName
        if Item_String and Item_String.Value and Item_String.Value ~= "" then
            itemName = Item_String.Value
        else
            itemName = plant.Name
        end

        -- Get Variant
        local Variant = plant:FindFirstChild("Variant")
        if not Variant then
            return 0
        end

        -- Get Weight
        local Weight = plant:FindFirstChild("Weight")
        if not Weight then
            return 0
        end

        -- Get item data using exact same logic as game
        local itemData = Item_Module.Return_Data(itemName)
        if not itemData or #itemData < 3 then
            warn("calculatePlantValue | ItemData is invalid for", itemName)
            return 0
        end

        -- Calculate value using exact game formula
        local clamped = math.clamp(Weight.Value / itemData[2], 0.95, 100000000)
        local mutationMultiplier = MutationHandler:CalcValueMulti(plant)
        local variantMultiplier = Item_Module.Return_Multiplier(Variant.Value)

        local finalValue = math.round((itemData[3] * mutationMultiplier * variantMultiplier) * (clamped * clamped))

        return finalValue
    end

    -- Get player's farm
    local myFarm = getMyFarm()
    if not myFarm then
        print("ðŸŒ¿ DEBUG: Could not find player's farm")
        return 0, 0
    end

    local important = myFarm:FindFirstChild("Important")
    if not important then
        print("ðŸŒ¿ DEBUG: Could not find Important folder in farm")
        return 0, 0
    end

    local plantsPhysical = important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("ðŸŒ¿ DEBUG: Could not find Plants_Physical folder")
        return 0, 0
    end

    print("ðŸŒ¿ DEBUG: Found", #plantsPhysical:GetChildren(), "plants in farm")

    -- Calculate total value of plants and fruits
    local total = 0
    local plantsProcessed = 0

    for _, plant in pairs(plantsPhysical:GetChildren()) do
        local plantValue = 0

        -- Calculate value for the plant itself if it's harvestable
        if plant:FindFirstChild("Variant") and plant:FindFirstChild("Weight") then
            local success, result = pcall(function()
                return calculatePlantValue(plant)
            end)

            if success then
                plantValue = plantValue + result
            end
        end

        -- Calculate value for all fruits on the plant
        local fruitsFolder = plant:FindFirstChild("Fruits")
        if fruitsFolder then
            for _, fruit in pairs(fruitsFolder:GetChildren()) do
                -- Skip if not a model or tool
                if not (fruit:IsA("Model") or fruit:IsA("Tool")) then continue end

                -- Calculate fruit value using exact same logic
                local success, result = pcall(function()
                    return calculatePlantValue(fruit)
                end)

                if success then
                    plantValue = plantValue + result
                end
            end
        end

        total = total + plantValue
        plantsProcessed = plantsProcessed + 1
    end

    print("ðŸŒ¿ DEBUG: Final calculation - Total:", total, "Plants processed:", plantsProcessed)

    -- Round to 2 decimal places
    total = math.floor(total * 100) / 100

    return total, plantsProcessed
end

-- Calculator interface with only calculation buttons
CalculatorTab:AddButton("ðŸ’° Calculate Inventory Value", {
    Text = "ðŸ’° Calculate Inventory Value",
    Func = function()
        Library:Notify("ðŸ’° Calculating inventory value...", 2)

        local inventoryTotal, itemsProcessed

        task.spawn(function()
            inventoryTotal, itemsProcessed = calculateInventoryValue()

            -- Use task.defer to ensure notification runs on main thread
            task.defer(function()
                if itemsProcessed > 0 then
                    Library:Notify("ðŸ’° Inventory Total: $" .. formatNumber(inventoryTotal) .. " (" .. itemsProcessed .. " items)", 5)
                    print("ðŸ’° FINAL RESULT: Inventory worth $" .. formatNumber(inventoryTotal) .. " from " .. itemsProcessed .. " items")
                else
                    Library:Notify("ðŸ“¦ No items found in inventory to calculate", 3)
                end
            end)
        end)
    end,
    Tooltip = "Calculate the total worth of all fruits/items in your inventory using the exact game calculation formula",
})

CalculatorTab:AddButton("ðŸŒ¿ Calculate Farm Value", {
    Text = "ðŸŒ¿ Calculate Farm Value",
    Func = function()
        Library:Notify("ðŸŒ¿ Calculating farm value...", 2)

        local farmTotal, plantsProcessed

        task.spawn(function()
            farmTotal, plantsProcessed = calculateFarmValue()

            -- Use task.defer to ensure notification runs on main thread
            task.defer(function()
                if plantsProcessed > 0 then
                    Library:Notify("ðŸŒ¿ Farm Total: $" .. formatNumber(farmTotal) .. " (" .. plantsProcessed .. " plants)", 5)
                    print("ðŸŒ¿ FINAL RESULT: Farm worth $" .. formatNumber(farmTotal) .. " from " .. plantsProcessed .. " plants")
                else
                    Library:Notify("ðŸŒ¿ No plants found in farm to calculate", 3)
                end
            end)
        end)
    end,
    Tooltip = "Calculate the total worth of all plants and fruits in your farm using the game's calculation formula",
})

-- Stealer GroupBox for Auto tab
local StealerGroupBox = Tabs.Auto:AddRightGroupbox("Stealer")

-- Reference to the ByteNetReliable remote for stealing fruits
local ByteNetReliable = Services.ReplicatedStorage:WaitForChild("ByteNetReliable")

-- Function to find the best value fruit across all farms in the server
local function findBestValueFruit(skipFavorited)
    print("ðŸ” DEBUG: Starting best value fruit search...")
    if skipFavorited then
        print("ðŸ” DEBUG: Skipping favorited fruits")
    end

    -- Try to load the official CalculatePlantValue module
    local CalculatePlantValue, Item_Module, MutationHandler
    local success, result = pcall(function()
        return require(game:GetService("ReplicatedStorage").Modules.ModuleScripts.CalculatePlantValue.module)
    end)
    if success then
        CalculatePlantValue = result
        print("ðŸ” DEBUG: Successfully loaded official CalculatePlantValue module")
    else
        print("ðŸ” DEBUG: Failed to load official CalculatePlantValue module:", result)
        print("ðŸ” DEBUG: Falling back to manual implementation")

        -- Load required modules with correct paths
        success, result = pcall(function()
            return require(game:GetService("ReplicatedStorage").ModuleScripts.Item_Module.module)
        end)
        if success then
            Item_Module = result
            print("ðŸ” DEBUG: Successfully loaded Item_Module")
        else
            print("ðŸ” DEBUG: Failed to load Item_Module:", result)
            -- Try alternative path
            success, result = pcall(function()
                return require(game:GetService("ReplicatedStorage").Item_Module)
            end)
            if success then
                Item_Module = result
                print("ðŸ” DEBUG: Successfully loaded Item_Module from alternative path")
            else
                print("ðŸ” DEBUG: Failed to load Item_Module from all paths:", result)
                return nil
            end
        end

        success, result = pcall(function()
            return require(game:GetService("ReplicatedStorage").Modules.ModuleScripts.MutationHandler.module)
        end)
        if success then
            MutationHandler = result
            print("ðŸ” DEBUG: Successfully loaded MutationHandler")
        else
            print("ðŸ” DEBUG: Failed to load MutationHandler:", result)
            -- Try alternative path
            success, result = pcall(function()
                return require(game:GetService("ReplicatedStorage").Modules.MutationHandler)
            end)
            if success then
                MutationHandler = result
                print("ðŸ” DEBUG: Successfully loaded MutationHandler from alternative path")
            else
                print("ðŸ” DEBUG: Failed to load MutationHandler from all paths:", result)
                return nil
            end
        end
    end

    -- Function to calculate plant value
    local function calculatePlantValue(plant)
        -- If we have the official module, use it
        if CalculatePlantValue then
            local value = CalculatePlantValue(plant)

            -- Get additional info for display
            local Item_String = plant:FindFirstChild("Item_String")
            local itemName = (Item_String and Item_String.Value and Item_String.Value ~= "") and Item_String.Value or plant.Name
            local Variant = plant:FindFirstChild("Variant")
            local variantValue = Variant and Variant.Value or "Normal"
            local Weight = plant:FindFirstChild("Weight")
            local weightValue = Weight and Weight.Value or 0

            return {
                value = value,
                name = itemName,
                variant = variantValue,
                weight = weightValue,
                mutationMulti = 1 -- We don't have access to this with the official module
            }
        end

        -- Fallback to our implementation if official module isn't available
        -- Get Item_String or use plant name
        local Item_String = plant:FindFirstChild("Item_String")
        local itemName
        if Item_String and Item_String.Value and Item_String.Value ~= "" then
            itemName = Item_String.Value
        else
            itemName = plant.Name
        end

        -- Get Variant
        local Variant = plant:FindFirstChild("Variant")
        if not Variant then
            return { value = 0 }
        end

        -- Get Weight
        local Weight = plant:FindFirstChild("Weight")
        if not Weight then
            return { value = 0 }
        end

        -- Get item data using exact same logic as game
        local itemData = Item_Module.Return_Data(itemName)
        if not itemData or #itemData < 3 then
            warn("calculatePlantValue | ItemData is invalid for", itemName)
            return { value = 0 }
        end

        -- Calculate value using exact game formula
        local clamped = math.clamp(Weight.Value / itemData[2], 0.95, 100000000)
        local mutationMultiplier = MutationHandler:CalcValueMulti(plant)
        local variantMultiplier = Item_Module.Return_Multiplier(Variant.Value)

        local finalValue = math.round((itemData[3] * mutationMultiplier * variantMultiplier) * (clamped * clamped))

        -- Return a table with all the values
        return {
            value = finalValue,
            name = itemName,
            variant = Variant.Value,
            weight = Weight.Value,
            mutationMulti = mutationMultiplier
        }
    end

    -- Variables to track best fruit
    local bestFruit = nil
    local bestValue = 0
    local bestFruitInfo = {
        name = "",
        variant = "",
        weight = 0,
        mutations = "",
        owner = "",
        value = 0
    }

    -- Scan all farms in the server
    for _, farm in pairs(workspace.Farm:GetChildren()) do
        local important = farm:FindFirstChild("Important")
        if important then
            local data = important:FindFirstChild("Data")
            if data and data:FindFirstChild("Owner") then
                local ownerName = data.Owner.Value

                -- Skip player's own farm
                if ownerName == LocalPlayer.Name then
                    print("ðŸ” DEBUG: Skipping player's own farm")
                    continue
                end

                local plantsPhysical = important:FindFirstChild("Plants_Physical")
                if plantsPhysical then
                    for _, plant in pairs(plantsPhysical:GetChildren()) do
                        -- Check for fruits on the plant
                        local fruitsFolder = plant:FindFirstChild("Fruits")
                        if fruitsFolder then
                            for _, fruit in pairs(fruitsFolder:GetChildren()) do
                                -- Skip if not a model or tool
                                if not (fruit:IsA("Model") or fruit:IsA("Tool")) then continue end

                                -- Skip favorited fruits if skipFavorited is true
                                if skipFavorited and fruit:GetAttribute("Favorited") then
                                    print("ðŸ” DEBUG: Skipping favorited fruit:", fruit.Name)
                                    continue
                                end

                                -- Calculate fruit value
                                local success, result = pcall(function()
                                    return calculatePlantValue(fruit)
                                end)

                                local value, itemName, variant, weight, mutationMulti
                                if success and type(result) == "table" then
                                    value = result.value
                                    itemName = result.name
                                    variant = result.variant
                                    weight = result.weight
                                    mutationMulti = result.mutationMulti
                                else
                                    -- Fallback values if something went wrong
                                    value = 0
                                    itemName = fruit.Name
                                    variant = "Normal"
                                    weight = 0
                                    mutationMulti = 1
                                end

                                if success and value > bestValue then
                                    bestFruit = fruit
                                    bestValue = value

                                    -- Get mutations as a string
                                    local mutations = ""
                                    for _, mutation in pairs(AllMutations) do
                                        if fruit:GetAttribute(mutation) then
                                            if mutations ~= "" then
                                                mutations = mutations .. ", "
                                            end
                                            mutations = mutations .. mutation
                                        end
                                    end

                                    bestFruitInfo = {
                                        name = itemName,
                                        variant = variant,
                                        weight = weight,
                                        mutations = mutations,
                                        owner = ownerName,
                                        value = value
                                    }

                                    print("ðŸ” DEBUG: New best fruit found -", itemName, "Value:", value, "Owner:", ownerName)
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    -- Return both the fruit info and the fruit instance
    return {
        info = bestFruitInfo,
        instance = bestFruit
    }
end

-- Function to teleport to a fruit
local function teleportToFruit(fruit)
    if not fruit or not fruit:IsDescendantOf(workspace) then
        Library:Notify("âŒ Cannot teleport to fruit: Invalid fruit instance", 3)
        return false
    end

    -- Get the fruit's position
    local fruitPosition = fruit:GetPivot().Position

    -- Add a small offset to avoid getting stuck in the fruit
    local teleportPosition = fruitPosition + Vector3.new(0, 3, 0)

    -- Get the player's character
    local character = LocalPlayer.Character
    if not character then
        Library:Notify("âŒ Cannot teleport: Character not found", 3)
        return false
    end

    -- Enable noclip for smooth teleportation
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then
        Library:Notify("âŒ Cannot teleport: HumanoidRootPart not found", 3)
        return false
    end

    print("ðŸš€ Teleporting to fruit:", fruit.Name, "at position:", teleportPosition)

    -- Teleport to the fruit
    humanoidRootPart.CFrame = CFrame.new(teleportPosition)

    -- Wait for teleport to register properly
    task.wait(0.3)

    return true
end

-- Function to create a ping effect on a fruit
local function pingFruit(fruit)
    if not fruit or not fruit:IsDescendantOf(workspace) then
        Library:Notify("âŒ Cannot ping fruit: Invalid fruit instance", 3)
        return false
    end

    -- Create a highlight effect
    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(255, 0, 0) -- Red color
    highlight.OutlineColor = Color3.fromRGB(255, 255, 0) -- Yellow outline
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = fruit

    -- Create a pulsing effect
    task.spawn(function()
        for i = 1, 5 do -- Pulse 5 times
            -- Fade in
            for j = 5, 0, -1 do
                highlight.FillTransparency = j/10
                task.wait(0.05)
            end

            -- Fade out
            for j = 0, 5 do
                highlight.FillTransparency = j/10
                task.wait(0.05)
            end
        end

        -- Remove the highlight after pulsing
        highlight:Destroy()
    end)

    return true
end

-- Function to steal a fruit using the ByteNetReliable remote
local function stealFruit(fruit)
    if not fruit or not fruit:IsDescendantOf(workspace) then
        Library:Notify("âŒ Cannot steal fruit: Invalid fruit instance", 3)
        return false
    end

    -- Use the ByteNetReliable remote with the specific buffer string from the issue description
    local success, err = pcall(function()
        -- This is the exact buffer string from the issue description
        local bufferString = "\8\0\0\224\194k;\232A\1"

        -- Try to get the ByteNet module which has buffer utilities
        local ByteNet = require(Services.ReplicatedStorage.Modules.ByteNet)

        -- Get the fruit's instance ID to ensure we're targeting the right fruit
        local fruitId = fruit:GetAttribute("ID") or fruit.Name
        print("ðŸ”“ DEBUG: Targeting fruit with ID:", fruitId)

        -- Create a buffer that includes the fruit instance ID
        local targetBuffer

        -- Try to use the Remotes module to create a proper packet
        local success, remotes = pcall(function()
            return require(Services.ReplicatedStorage.Modules.ModuleScripts.Remotes.module)
        end)

        if success and remotes and remotes.Crops and remotes.Crops.Collect then
            -- If we have access to the proper remote definition, use it
            targetBuffer = remotes.Crops.Collect.serialize({value = {fruit}})
            print("ðŸ”“ DEBUG: Created buffer using Remotes.Crops.Collect")
        else
            -- Fire the remote event with the buffer string
            -- Use buffer.fromstring if available, otherwise try ByteNet's buffer utilities
            if buffer and buffer.fromstring then
                targetBuffer = buffer.fromstring(bufferString)
                print("ðŸ”“ DEBUG: Created buffer using buffer.fromstring")
            elseif ByteNet and ByteNet.fromstring then
                targetBuffer = ByteNet.fromstring(bufferString)
                print("ðŸ”“ DEBUG: Created buffer using ByteNet.fromstring")
            else
                -- Fallback: Try to create a buffer manually
                targetBuffer = buffer.create(#bufferString)
                for i = 1, #bufferString do
                    buffer.writeu8(targetBuffer, i - 1, string.byte(bufferString, i))
                end
                print("ðŸ”“ DEBUG: Created buffer manually")
            end
        end

        -- Fire the remote with our target buffer
        firesignal(ByteNetReliable.OnClientEvent, targetBuffer)
        print("ðŸ”“ DEBUG: Fired ByteNetReliable remote targeting fruit:", fruit.Name)
    end)

    if success then
        return true
    else
        print("âŒ ERROR stealing fruit:", err)
        return false
    end
end

-- Best Value button
StealerGroupBox:AddButton("Best Value", function()
    Library:Notify("ðŸ” Scanning all farms for best value fruit...", 3)

    local bestFruitResult

    task.spawn(function()
        bestFruitResult = findBestValueFruit()

        -- Use task.defer to ensure notification runs on main thread
        task.defer(function()
            if bestFruitResult and bestFruitResult.info and bestFruitResult.info.value > 0 then
                local bestFruitInfo = bestFruitResult.info
                local mutationText = bestFruitInfo.mutations ~= "" and " [" .. bestFruitInfo.mutations .. "]" or ""
                local variantText = bestFruitInfo.variant ~= "Normal" and " (" .. bestFruitInfo.variant .. ")" or ""
                local weightText = string.format("%.2f", bestFruitInfo.weight) .. "kg"

                Library:Notify("ðŸ’° Best Value: " .. mutationText .. " " .. bestFruitInfo.name .. variantText .. 
                    " [" .. weightText .. "] - $" .. formatNumber(bestFruitInfo.value) .. 
                    " (Owner: " .. bestFruitInfo.owner .. ")", 8)

                print("ðŸ” FINAL RESULT: Best fruit is", bestFruitInfo.name, "worth $" .. formatNumber(bestFruitInfo.value), 
                    "owned by", bestFruitInfo.owner)
            else
                Library:Notify("ðŸ” No valuable fruits found in any farm", 3)
            end
        end)
    end)
end)

-- Teleport to Best Fruit button
StealerGroupBox:AddButton("Teleport to Best Fruit", function()
    Library:Notify("ðŸ” Scanning for best fruit to teleport to...", 3)

    local bestFruitResult

    task.spawn(function()
        bestFruitResult = findBestValueFruit()

        -- Use task.defer to ensure notification runs on main thread
        task.defer(function()
            if bestFruitResult and bestFruitResult.info and bestFruitResult.info.value > 0 and bestFruitResult.instance then
                local bestFruitInfo = bestFruitResult.info
                local fruitInstance = bestFruitResult.instance

                -- Check if the fruit is favorited
                if fruitInstance:GetAttribute("Favorited") then
                    -- Fruit is favorited, inform the player
                    Library:Notify("â­ Found favorited " .. bestFruitInfo.name .. " worth $" .. 
                        formatNumber(bestFruitInfo.value) .. " from " .. bestFruitInfo.owner, 5)

                    print("â­ FOUND FAVORITED: Fruit is favorited -", bestFruitInfo.name, "worth $" .. formatNumber(bestFruitInfo.value), 
                        "from", bestFruitInfo.owner)
                end

                -- Teleport to the fruit
                Library:Notify("ðŸš€ Teleporting to " .. bestFruitInfo.name .. " worth $" .. 
                    formatNumber(bestFruitInfo.value) .. " from " .. bestFruitInfo.owner, 3)

                local teleportSuccess = teleportToFruit(fruitInstance)

                if teleportSuccess then
                    -- Create a ping effect on the fruit
                    pingFruit(fruitInstance)

                    Library:Notify("âœ… Successfully teleported to " .. bestFruitInfo.name .. " worth $" .. 
                        formatNumber(bestFruitInfo.value) .. " from " .. bestFruitInfo.owner, 5)

                    print("ðŸš€ TELEPORT SUCCESS: Teleported to", bestFruitInfo.name, "worth $" .. formatNumber(bestFruitInfo.value), 
                        "from", bestFruitInfo.owner)
                else
                    Library:Notify("âŒ Failed to teleport to " .. bestFruitInfo.name, 3)
                end
            else
                Library:Notify("ðŸ” No valuable fruits found", 3)
            end
        end)
    end)
end)

-- Variable to track the teleport button
local currentTeleportButton = nil

-- Find Valuable Fruit button (shows the highest value fruit that isn't favorited)
StealerGroupBox:AddButton("Find Valuable Fruit", function()
    -- Remove any existing teleport button
    if currentTeleportButton then
        currentTeleportButton:Remove()
        currentTeleportButton = nil
    end

    Library:Notify("ðŸ” Scanning for best non-favorited fruit...", 3)

    local bestFruitResult

    task.spawn(function()
        -- Use skipFavorited = true to filter out favorited fruits
        bestFruitResult = findBestValueFruit(true)

        -- Use task.defer to ensure notification runs on main thread
        task.defer(function()
            if bestFruitResult and bestFruitResult.info and bestFruitResult.info.value > 0 and bestFruitResult.instance then
                local bestFruitInfo = bestFruitResult.info
                local fruitInstance = bestFruitResult.instance

                -- Show information about the best non-favorited fruit
                local mutationText = bestFruitInfo.mutations ~= "" and " [" .. bestFruitInfo.mutations .. "]" or ""
                local variantText = bestFruitInfo.variant ~= "Normal" and " (" .. bestFruitInfo.variant .. ")" or ""
                local weightText = string.format("%.2f", bestFruitInfo.weight) .. "kg"

                -- Create a notification with a longer duration to give the player time to read
                Library:Notify("ðŸ’° Best Non-Favorited: " .. mutationText .. " " .. bestFruitInfo.name .. variantText .. 
                    " [" .. weightText .. "] - $" .. formatNumber(bestFruitInfo.value) .. 
                    " (Owner: " .. bestFruitInfo.owner .. ")", 8)

                print("ðŸ” FINAL RESULT: Best non-favorited fruit is", bestFruitInfo.name, "worth $" .. formatNumber(bestFruitInfo.value), 
                    "owned by", bestFruitInfo.owner)

                -- Add a button to teleport to this fruit
                local teleportButton = StealerGroupBox:AddButton("Teleport to " .. bestFruitInfo.name .. " ($" .. formatNumber(bestFruitInfo.value) .. ")", function()
                    -- Teleport to the fruit
                    Library:Notify("ðŸš€ Teleporting to " .. bestFruitInfo.name .. " worth $" .. 
                        formatNumber(bestFruitInfo.value) .. " from " .. bestFruitInfo.owner, 3)

                    local teleportSuccess = teleportToFruit(fruitInstance)

                    if teleportSuccess then
                        -- Create a ping effect on the fruit
                        pingFruit(fruitInstance)

                        Library:Notify("âœ… Successfully teleported to " .. bestFruitInfo.name, 3)
                    else
                        Library:Notify("âŒ Failed to teleport to " .. bestFruitInfo.name, 3)
                    end

                    -- Remove the button after use
                    teleportButton:Remove()
                    currentTeleportButton = nil
                end)

                -- Store reference to the button
                currentTeleportButton = teleportButton
            else
                Library:Notify("ðŸ” No valuable non-favorited fruits found", 3)
            end
        end)
    end)
end)

-- ================================================================
-- CORE FUNCTIONS (Exact from SloppyCoding)
-- ================================================================

-- getMyFarm function (Exact from SloppyCoding)
local function getMyFarm()
	for _, farm in workspace.Farm:GetChildren() do
		local important = farm:FindFirstChild("Important")
		if important then
			local data = important:FindFirstChild("Data")
			if data and data.Owner.Value == LocalPlayer.Name then
				return farm
			end
		end
	end
	return nil
end

-- getRandomPlantPosition function (Enhanced with position modes)
local function getRandomPlantPosition()
	local myFarm = getMyFarm()
	if myFarm then
		local canPlantParts = {}
		-- Find all Can_Plant parts in the farm
		for _, child in pairs(myFarm:GetDescendants()) do
			if child.Name == "Can_Plant" and child:IsA("BasePart") then
				table.insert(canPlantParts, child)
			end
		end

		if #canPlantParts > 0 then
			local selectedPart

			-- Check position mode
			local positionMode = Options.SelectPosition and Options.SelectPosition.Value or "Random"

			if positionMode == "Player Position" then
				-- Plant directly at player's feet
				local character = LocalPlayer.Character
				if character and character:FindFirstChild("HumanoidRootPart") then
					local playerPos = character.HumanoidRootPart.Position
					-- Plant at player's feet (slightly below to ensure it's on ground)
					return Vector3.new(playerPos.X, playerPos.Y - 3, playerPos.Z)
				else
					-- Fallback to random if no character
					selectedPart = canPlantParts[math.random(1, #canPlantParts)]
				end
			else
				-- Random mode (default)
				selectedPart = canPlantParts[math.random(1, #canPlantParts)]
			end

			if selectedPart then
				-- Get random position on the selected part
				local size = selectedPart.Size
				local position = selectedPart.Position
				local randomX = position.X + math.random(-size.X / 2, size.X / 2)
				local randomZ = position.Z + math.random(-size.Z / 2, size.Z / 2)
				return Vector3.new(randomX, position.Y, randomZ)
			end
		end
	end
	return nil
end

-- ================================================================
-- MAIN TAB - AUTO PLANT SYSTEM (Exact from SloppyCoding)
-- ================================================================
local AutoPlantGroupBox = Tabs.Main:AddLeftGroupbox("Auto Plant Seeds")

-- PlantSeeds Dropdown (Exact from SloppyCoding)
AutoPlantGroupBox:AddDropdown("PlantSeeds", {
	Values = {
		-- All plants/fruits from game files (PlantTraitsData + SeedData) - 2025 Update
		"Aloe Vera",
		"Apple",
		"Avocado",
		"Bamboo",
		"Banana",
		"Beanstalk",
		"Bee Balm",
		"Bell Pepper",
		"Bendboo",
		"Blood Banana",
		"Blue Lollipop",
		"Blueberry",
		"Burning Bud",
		"Cacao",
		"Cactus",
		"Candy Blossom",
		"Candy Sunflower",
		"Cantaloupe",
		"Carrot",
		"Cauliflower",
		"Celestiberry",
		"Cherry Blossom",
		"Chocolate Carrot",
		"Cocovine",
		"Coconut",
		"Corn",
		"Cranberry",
		"Crimson Vine",
		"Crocus",
		"Cursed Fruit",
		"Daffodil",
		"Dandelion",
		"Delphinium",
		"Dragon Fruit",
		"Dragon Pepper",
		"Durian",
		"Easter Egg",
		"Eggplant",
		"Elephant Ears",
		"Ember Lily",
		"Feijoa",
		"Foxglove",
		"Glowshroom",
		"Grape",
		"Green Apple",
		"Guanabana",
		"Hive Fruit",
		"Honeysuckle",
		"Ice Cream Bean",
		"Kiwi",
		"Lavender",
		"Lemon",
		"Lilac",
		"Lily of the Valley",
		"Lime",
		"Loquat",
		"Lotus",
		"Lumira",
		"Mango",
		"Manuka Flower",
		"Mega Mushroom",
		"Mint",
		"Moon Blossom",
		"Moon Mango",
		"Moon Melon",
		"Moonflower",
		"Moonglow",
		"Mushroom",
		"Nectar Thorn",
		"Nectarine",
		"Nectarshade",
		"Nightshade",
		"Noble Flower",
		"Orange Tulip",
		"Papaya",
		"Parasol Flower",
		"Passionfruit",
		"Peace Lily",
		"Peach",
		"Pear",
		"Pepper",
		"Pineapple",
		"Pink Lily",
		"Pink Tulip",
		"Pitcher Plant",
		"Prickly Pear",
		"Pumpkin",
		"Purple Cabbage",
		"Purple Dahlia",
		"Rafflesia",
		"Raspberry",
		"Red Lollipop",
		"Rose",
		"Rosy Delight",
		"Soul Fruit",
		"Starfruit",
		"Strawberry",
		"Succulent",
		"Sugar Apple",
		"Suncoil",
		"Sunflower",
		"Tomato",
		"Traveler's Fruit",
		"Venus Fly Trap",
		"Violet Corn",
		"Watermelon",
		"White Mullberry",
		"Wild Carrot",
	},
	Default = 1,
	Multi = true, -- Allows multiple selections

	Text = "Seeds - Auto Plant Seeds",
	Tooltip = "Choose seeds to auto-plant. System prioritizes actual seed items (e.g., CarrotSeed over Carrot). Both will be equipped but only seeds will plant. Updated with ALL 102 plants from game files!",

	Callback = function(Value)
		print("[cb] Plant seeds selection changed:")
		for seed, selected in next, Options.PlantSeeds.Value do

			print(seed, selected)
		end
	end,
})

-- Select All Summer Plants Button (Exact from SloppyCoding)
AutoPlantGroupBox:AddButton("Select All Summer Plants", function()
	-- Debug: show what's actually in inventory
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		print("=== INVENTORY DEBUG ===")
		for _, item in pairs(backpack:GetChildren()) do
			if item:IsA("Tool") then
				print("Available item:", item.Name)
			end
		end
		print("=== END DEBUG ===")
	end

	-- Add logic to select summer plants here
	Library:Notify("Selected all summer plants", 2)
end)

-- Auto Plant Toggle
AutoPlantGroupBox:AddToggle("AutoPlant", {
	Text = "Auto Plant Selected Seeds",
	Default = false,
	Tooltip = "Automatically plant the selected seeds in your farm",
	Callback = function(Value)
		if Value then
			Library:Notify("Auto Plant enabled!", 3)
			-- Function to find and equip seed
			local function findAndEquipSeed(seedName)
				local backpack = LocalPlayer:FindFirstChild("Backpack")
				if not backpack then return false end

				-- Look for exact seed name first
				local seedTool = backpack:FindFirstChild(seedName .. "Seed") or backpack:FindFirstChild(seedName)
				if seedTool and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
					LocalPlayer.Character.Humanoid:EquipTool(seedTool)
					task.wait(0.5)
					return true
				end
				return false
			end

			-- Start auto planting loop
			task.spawn(function()
				while Toggles.AutoPlant.Value do
					local plantsPlanted = 0

					-- Auto plant selected seeds continuously
					for seed, selected in next, Options.PlantSeeds.Value do
						if selected and Toggles.AutoPlant.Value then
							print("Auto Plant: Trying to plant", seed)
							-- Try to find and equip the correct seed tool
							if findAndEquipSeed(seed) then
								print("Auto Plant: Successfully equipped seed for", seed)
								local plantPosition = getRandomPlantPosition()
								print("Auto Plant: Plant position for", seed, ":", plantPosition)
								if plantPosition then
									-- Try planting with the remote event
									print("Auto Plant: Attempting to plant", seed, "at", plantPosition)
									local success = pcall(function()
										Plant_RE:FireServer(plantPosition, seed)
									end)

									if success then
										print("âœ… Auto Plant: Successfully planted", seed, "at position:", plantPosition)
										plantsPlanted = plantsPlanted + 1
										Library:Notify("ðŸŒ± Planted " .. seed .. "!", 1)
									else
										print("âŒ Auto Plant: Failed to plant", seed)
										Library:Notify("âŒ Failed to plant " .. seed, 1)
									end
								else
									print("âŒ Auto Plant: No Can_Plant parts found in farm!")
									Library:Notify("âŒ No planting spots found in farm!", 2)
								end
							else
								print("âŒ Auto Plant: Could not equip seed for", seed)
								Library:Notify("âŒ " .. seed .. " Seed not found in inventory!", 2)
							end

							-- Reduced delay between different seed types
							local plantDelay = Options.DelayToPlants and Options.DelayToPlants.Value or 0
							if plantDelay > 0 then
								task.wait(plantDelay)
							else
								task.wait(0.1) -- Minimum delay to prevent spam
							end
						end
					end

					-- Show summary if plants were planted
					if plantsPlanted > 0 then
						Library:Notify("ðŸŒ± Planted " .. plantsPlanted .. " seeds this cycle!", 2)
					end

					-- Much shorter wait between planting cycles
					task.wait(0.5)
				end
				print("Auto plant loop ended")
			end)
		else
			Library:Notify("Auto Plant disabled!", 3)
		end
	end,
})

-- Auto Plants All Seeds Toggle
AutoPlantGroupBox:AddToggle("AutoPlantAllSeeds", {
	Text = "Auto Plants All Seeds",
	Tooltip = "Automatically plant ALL available seeds in your backpack. Equips one seed and plants until it's completely finished, then moves to the next seed.",
	Default = false,
	Callback = function(Value)
		print("[cb] Auto Plant All Seeds toggled:", Value)
		if Value then
			Library:Notify("Auto Plant All Seeds enabled! Will plant each seed until finished, then move to next seed", 3)

			-- Start auto planting loop for all seeds
			task.spawn(function()
				while Toggles.AutoPlantAllSeeds.Value do
					local backpack = LocalPlayer:FindFirstChild("Backpack")

					if backpack then
						-- Find the first seed tool in backpack
						local currentSeedTool = nil
						for _, tool in pairs(backpack:GetChildren()) do
							if tool:IsA("Tool") and string.find(tool.Name:lower(), "seed") then
								currentSeedTool = tool
								break -- Take the first seed found
							end
						end

						if currentSeedTool then
							local toolName = currentSeedTool.Name

							-- Convert seed name to plant name (what the server expects)
							local serverPlantName = toolName
							-- First remove quantity indicators like [X5], [X10], etc.
							serverPlantName = string.gsub(serverPlantName, "%s*%[X%d+%]", "")
							-- Remove "Seed" suffix (case insensitive)
							serverPlantName = string.gsub(serverPlantName, "Seed$", "")
							serverPlantName = string.gsub(serverPlantName, "seed$", "")
							serverPlantName = string.gsub(serverPlantName, " Seed$", "")
							serverPlantName = string.gsub(serverPlantName, " seed$", "")
							-- Trim any remaining whitespace
							serverPlantName = serverPlantName:gsub("^%s+", ""):gsub("%s+$", "")

							print("Auto Plant All: Found seed:", toolName, "-> server name:", serverPlantName)

							-- Equip the seed tool
							local character = LocalPlayer.Character
							if character and character:FindFirstChild("Humanoid") then
								character.Humanoid:EquipTool(currentSeedTool)
								print("Auto Plant All: Equipped", toolName)
								task.wait(0.2) -- Wait for tool to be equipped

								-- Plant continuously until this specific seed tool is finished
								local plantsPlantedWithThisSeed = 0
								Library:Notify("ðŸŒ± Now planting: " .. serverPlantName, 2)

								while Toggles.AutoPlantAllSeeds.Value do
									-- Check if the tool still exists (in character or backpack)
									local toolStillExists = false
									if currentSeedTool.Parent == character or currentSeedTool.Parent == backpack then
										toolStillExists = true
									end

									if not toolStillExists then
										print("Auto Plant All: Seed tool", toolName, "is finished/consumed")
										break -- This seed is finished, move to next one
									end

									-- Get plant position using the selected position mode
									local plantPosition = getRandomPlantPosition()
									if plantPosition then
										-- Plant using the cleaned plant name
										print("Auto Plant All: Planting", serverPlantName, "at position", plantPosition)
										local success = pcall(function()
											Plant_RE:FireServer(plantPosition, serverPlantName)
										end)

										if success then
											print("âœ… Auto Plant All: Successfully planted", serverPlantName)
											plantsPlantedWithThisSeed = plantsPlantedWithThisSeed + 1

											-- Show progress every 5 plants, or for first few plants
											if plantsPlantedWithThisSeed <= 3 or plantsPlantedWithThisSeed % 5 == 0 then
												Library:Notify("ðŸŒ± " .. serverPlantName .. " planted " .. plantsPlantedWithThisSeed .. " times", 1)
											end
										else
											print("âŒ Auto Plant All: Failed to plant", serverPlantName)
										end
									else
										print("âŒ Auto Plant All: No plant position available")
										task.wait(1) -- Wait a bit before trying again
									end

									-- Apply delay between plants
									local plantDelay = Options.DelayToPlants and Options.DelayToPlants.Value or 0
									if plantDelay > 0 then
										task.wait(plantDelay)
									else
										task.wait(0.1) -- Minimum delay to prevent spam
									end
								end

								-- Summary for this seed
								if plantsPlantedWithThisSeed > 0 then
									Library:Notify("âœ… Finished " .. serverPlantName .. "! Planted " .. plantsPlantedWithThisSeed .. " seeds", 2)
								else
									Library:Notify("âš ï¸ " .. serverPlantName .. " seed could not be planted", 2)
								end
							else
								print("âŒ Auto Plant All: Could not equip seed - no character/humanoid")
								break
							end
						else
							-- No more seeds found in backpack
							print("Auto Plant All: No more seeds found in backpack!")
							Library:Notify("âœ… Auto Plant All finished! No more seeds in backpack", 3)
							-- Turn off the toggle since we're done
							Toggles.AutoPlantAllSeeds:SetValue(false)
							break
						end
					else
						print("âŒ Auto Plant All: Backpack not found")
						task.wait(1)
					end

					-- Small delay before looking for next seed
					task.wait(0.2)
				end
				print("Auto plant all seeds loop ended")
			end)
		else
			Library:Notify("Auto Plant All Seeds disabled!", 3)
		end
	end,
})

AutoPlantGroupBox:AddDivider()

-- ================================================================
-- AUTO FARM SYSTEM (Exact from SloppyCoding)
-- ================================================================
local AutoFarmGroupBox = Tabs.Main:AddRightGroupbox("Auto Farm")

-- Global variables for mutation and variant filtering
local SelectedMutations = {}
local SelectedVariants = {}
local MutationFilterEnabled = false
local VariantFilterEnabled = false

-- All possible mutation names (from game data)
local AllMutations = {
	"Shocked",
	"Windstruck",
	"Dawnbound",
	"Twisted",
	"Cloudtouched",
	"Voidtouched",
	"Wet",
	"Fried",
	"Molten",
	"Alienlike",
	"Galactic",
	"Aurora",
	"Chilled",
	"Sundried",
	"Wiltproof",
	"Drenched",
	"Verdant",
	"Paradisal",
	"Frozen",
	"Disco",
	"Pollinated"
}

-- All possible variant names (from game data)
local AllVariants = {
	"Normal",
	"Gold",
	"Rainbow"
}

-- Function to check if fruit/plant has selected mutations
local function hasSelectedMutation(item)
	if not MutationFilterEnabled or not SelectedMutations or not next(SelectedMutations) then
		return true -- If filter is disabled or no mutations selected, allow all
	end

	-- Check for mutations as StringValue objects first
	for mutation, selected in pairs(SelectedMutations) do
		if selected then
			-- Check if mutation exists as a StringValue object
			local mutationObj = item:FindFirstChild(mutation)
			if mutationObj and mutationObj:IsA("StringValue") then
				print("ðŸ§¬ Found mutation StringValue:", mutation, "on", item.Name)
				return true
			end

			-- Check if mutation exists as an attribute
			if item:GetAttribute(mutation) then
				print("ðŸ§¬ Found mutation attribute:", mutation, "on", item.Name)
				return true
			end
		end
	end

	return false -- No selected mutations found
end

-- Function to check if fruit/plant has selected variants
local function hasSelectedVariant(item)
	if not VariantFilterEnabled or not SelectedVariants or not next(SelectedVariants) then
		return true -- If filter is disabled or no variants selected, allow all
	end

	-- Check for variant as StringValue object (new method)
	local variantObj = item:FindFirstChild("Variant")
	if variantObj and variantObj:IsA("StringValue") then
		local variantValue = variantObj.Value
		if SelectedVariants[variantValue] then
			print("ðŸŽ¨ Found variant StringValue:", variantValue, "on", item.Name)
			return true
		end
	end

	-- Fallback: Check for variant as attribute (old method)
	for variant, selected in pairs(SelectedVariants) do
		if selected and item:GetAttribute(variant) then
			print("ðŸŽ¨ Found variant attribute:", variant, "on", item.Name)
			return true -- Found a selected variant
		end
	end

	return false -- No selected variants found
end

-- Global variables for AutoFarm
local AutoCollectPlantsEnabled = false
local SelectedPlantsToCollect = {}

-- Helper function to extract plant type from name
local function GetPlantTypeFromName(plantName)
	-- Remove common suffixes and clean the name
	local cleanName = plantName
	cleanName = string.gsub(cleanName, " %[X%d+%]", "") -- Remove quantity indicators
	cleanName = string.gsub(cleanName, "Seed$", "")    -- Remove "Seed" suffix
	cleanName = string.gsub(cleanName, "seed$", "")    -- Remove "seed" suffix
	cleanName = string.gsub(cleanName, " Seed$", "")   -- Remove " Seed" suffix
	cleanName = string.gsub(cleanName, " seed$", "")   -- Remove " seed" suffix
	cleanName = cleanName:gsub("^%s+", ""):gsub("%s+$", "") -- Trim whitespace
	return cleanName
end

-- Function to restore character physics properly (Exact from SloppyCoding)
local function restoreCharacterPhysics()
	pcall(function()
		if LocalPlayer.Character then
			print("Restoring character physics...")

			-- Restore all body parts with specific handling
			for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					-- Always restore CanCollide for body parts (except HumanoidRootPart)
					if part.Name ~= "HumanoidRootPart" then
						part.CanCollide = true
						part.Massless = false
						print("Restored physics for:", part.Name)
					end

					-- Special handling for leg parts
					if string.find(part.Name:lower(), "leg")
							or string.find(part.Name:lower(), "foot")
							or string.find(part.Name:lower(), "ankle") then
						part.CanCollide = true
						part.Massless = false
						part.Material = Enum.Material.Plastic -- Reset material
						print("Special leg restoration for:", part.Name)
					end
				end
			end

			-- Force character to reset physics state
			local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
			if humanoid then
				-- Temporarily change and restore PlatformStand to refresh physics
				humanoid.PlatformStand = true
				task.wait(0.1)
				humanoid.PlatformStand = false
				print("Refreshed humanoid physics")
			end

			-- Reset camera to normal
			LocalPlayer.CameraMode = Enum.CameraMode.Classic
			LocalPlayer.CameraMaxZoomDistance = 128
			LocalPlayer.CameraMinZoomDistance = 0.5

			local Camera = workspace.CurrentCamera
			Camera.CameraType = Enum.CameraType.Custom
			Camera.CameraSubject = humanoid

			print("Character physics and camera fully restored")
		end
	end)
end

-- CanHarvest function (Exact from SloppyCoding)
local function CanHarvest(Plant)
	local Prompt = Plant:FindFirstChild("ProximityPrompt", true)
	if not Prompt then
		return
	end
	if not Prompt.Enabled then
		return
	end
	return true
end

-- HarvestPlant function (SAFE - Only harvests the specific plant passed to it)
local function HarvestPlant(Plant)
	-- ULTRA SAFETY CHECK 1: Verify the plant object is valid and stable
	if not Plant or not Plant.Parent then
		print("âŒ ULTRA SAFETY: Plant object invalid or already removed")
		return false
	end

	local Prompt = Plant:FindFirstChild("ProximityPrompt", true)
	if not Prompt then
		print("âŒ ULTRA SAFETY: No ProximityPrompt found on plant")
		return false
	end

	-- Ensure we have a character and root part
	if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
		print("âŒ ULTRA SAFETY: Character not ready for harvest")
		return false
	end

	-- ULTRA SAFETY CHECK 2: Store comprehensive plant identification data
	local targetPlant = Plant
	local targetPlantName = Plant.Name
	local targetPlantParent = Plant.Parent
	local targetPlantPosition = Plant:GetPivot().Position
	local targetPrompt = Prompt
	local plantUID = tostring(Plant) -- Unique object reference

	print("ðŸŽ¯ ULTRA SAFE HARVEST: Targeting", targetPlantName, "at", targetPlantPosition, "UID:", plantUID)

	-- ULTRA SAFETY CHECK 3: Verify this plant is in our selected filters
	local plantType = GetPlantTypeFromName(targetPlantName)
	if not plantType or not SelectedPlantsToCollect[plantType] then
		print("âŒ ULTRA SAFETY: Plant", targetPlantName, "is NOT in selected filters - ABORTING")
		return false
	end

	-- Get optimal position near the plant
	local plantPosition = Plant:GetPivot().Position
	local optimalPosition = plantPosition + Vector3.new(0, 2, 0) -- Position directly above the plant

	-- ULTRA SAFETY CHECK 4: Verify plant hasn't moved before teleporting
	if (Plant:GetPivot().Position - targetPlantPosition).Magnitude > 0.1 then
		print("âŒ ULTRA SAFETY: Plant moved since identification - ABORTING")
		return false
	end

	-- Teleport to optimal position for collection
	print("ðŸš€ ULTRA SAFE: Teleporting to", optimalPosition)
	LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(optimalPosition)
	task.wait(0.5) -- Wait for teleport to register properly

	-- ULTRA SAFETY CHECK 5: Verify plant still exists and hasn't changed after teleport
	if not targetPlant or not targetPlant.Parent or targetPlant.Parent ~= targetPlantParent then
		print("âŒ ULTRA SAFETY: Target plant disappeared or moved after teleport - ABORTING")
		return false
	end

	if targetPlant.Name ~= targetPlantName or tostring(targetPlant) ~= plantUID then
		print("âŒ ULTRA SAFETY: Plant reference changed after teleport - ABORTING")
		return false
	end

	-- Get even closer to ensure proximity trigger
	local closePosition = plantPosition + Vector3.new(0, 0.5, 0)
	LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(closePosition)
	task.wait(0.3) -- Additional wait for proximity to activate

	-- ULTRA SAFETY CHECK 6: Verify distance to target plant is reasonable
	local currentDistance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPlantPosition).Magnitude
	if currentDistance > 8 then
		print("âŒ ULTRA SAFETY: Too far from target plant after positioning! Distance:", currentDistance)
		return false
	end

	-- ULTRA SAFETY CHECK 7: Re-verify the plant after positioning
	if not targetPlant or not targetPlant.Parent or targetPlant.Parent ~= targetPlantParent then
		print("âŒ ULTRA SAFETY: Target plant disappeared after positioning - ABORTING")
		return false
	end

	if targetPlant.Name ~= targetPlantName then
		print("âŒ ULTRA SAFETY: Plant name changed after positioning - ABORTING")
		return false
	end

	-- Check if prompt is still enabled after positioning
	if not Prompt.Enabled then
		print("âŒ ULTRA SAFETY: ProximityPrompt disabled after positioning")
		return false
	end

	-- Try fireproximityprompt multiple times for better reliability
	local success = false
	local maxAttempts = 3

	for attempt = 1, maxAttempts do
		-- ULTRA SAFETY CHECK 8: Re-verify target before each attempt
		if not targetPlant or not targetPlant.Parent then
			print("âŒ ULTRA SAFETY: Target plant no longer exists at attempt", attempt)
			break
		end

		if targetPlant.Name ~= targetPlantName or tostring(targetPlant) ~= plantUID then
			print("âŒ ULTRA SAFETY: Plant reference corrupted at attempt", attempt)
			break
		end

		-- ULTRA SAFETY CHECK 9: Verify we're still close to the EXACT target
		local attemptDistance = (LocalPlayer.Character.HumanoidRootPart.Position - targetPlantPosition).Magnitude
		if attemptDistance > 10 then
			print("âŒ ULTRA SAFETY: Moved too far from target at attempt", attempt, "Distance:", attemptDistance)
			break
		end

		print("ðŸ”„ ULTRA SAFE: Harvest attempt", attempt, "on", targetPlantName)

		local attemptSuccess = pcall(function()
			-- ULTRA SAFETY CHECK 10: Triple-verify before firing prompt
			local currentPrompt = targetPlant:FindFirstChild("ProximityPrompt", true)
			if not currentPrompt then
				error("Prompt disappeared during harvest attempt")
			end

			if currentPrompt ~= targetPrompt then
				error("Prompt reference changed during harvest attempt")
			end

			if tostring(targetPlant) ~= plantUID then
				error("Plant UID changed during harvest attempt")
			end

			if targetPlant.Name ~= targetPlantName then
				error("Plant name changed during harvest attempt")
			end

			-- Only fire if ALL safety checks pass
			fireproximityprompt(currentPrompt)
		end)

		if attemptSuccess then
			task.wait(0.3) -- Wait for collection to process

			-- Check if the SPECIFIC plant/fruit still exists (successful collection removes it)
			if not targetPlant.Parent then
				success = true
				print("âœ… ULTRA SAFE: Successfully harvested target plant:", targetPlantName, "UID:", plantUID)
				break
			end
		else
			print("âš ï¸ ULTRA SAFE: Attempt", attempt, "failed safety checks for", targetPlantName)
		end

		-- If not successful and not the last attempt, try repositioning
		if not success and attempt < maxAttempts then
			-- ULTRA SAFETY CHECK 11: Only reposition if target still valid
			if targetPlant and targetPlant.Parent and targetPlant.Name == targetPlantName then
				local retryPosition = plantPosition + Vector3.new(0.2, 0.3, 0.2)
				LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(retryPosition)
				task.wait(0.2)
			else
				print("âŒ ULTRA SAFETY: Target invalid for repositioning, stopping attempts")
				break
			end
		end
	end

	-- Final check - if the SPECIFIC target plant is gone, collection was successful
	if not targetPlant.Parent then
		success = true
		print("âœ… ULTRA SAFE: Confirmed successful harvest of", targetPlantName)
	else
		print("âŒ ULTRA SAFE: Failed to harvest", targetPlantName, "after", maxAttempts, "attempts")
	end

	return success
end

-- CollectHarvestableWithFilters function - handles individual fruits with mutation/variant filtering
local function CollectHarvestableWithFilters(Parent, Plants, IgnoreDistance)
	local Character = LocalPlayer.Character
	if not Character then
		return Plants
	end

	local PlayerPosition = Character:GetPivot().Position

	for _, Item in pairs(Parent:GetChildren()) do
		-- Check if auto collect is still enabled
		if not AutoCollectPlantsEnabled then
			break
		end

		-- Distance check (skip if too far and not ignoring distance)
		local ItemPosition = Item:GetPivot().Position
		local Distance = (PlayerPosition - ItemPosition).Magnitude
		if not IgnoreDistance and Distance > 15 then
			continue
		end

		-- Check if item can be harvested
		if CanHarvest(Item) then
			-- Check mutation and variant filters for individual fruits
			local passesMutationFilter = hasSelectedMutation(Item)
			local passesVariantFilter = hasSelectedVariant(Item)

			if passesMutationFilter and passesVariantFilter then
				print("ðŸ“ Adding filtered fruit to collection list:", Item.Name)
				-- Debug mutation and variant info for fruits
				if MutationFilterEnabled then
					for mutation, selected in pairs(SelectedMutations) do
						if selected then
							-- Check StringValue objects
							local mutationObj = Item:FindFirstChild(mutation)
							if mutationObj and mutationObj:IsA("StringValue") then
								print("   â””â”€â”€ Fruit has mutation StringValue:", mutation)
							elseif Item:GetAttribute(mutation) then
								print("   â””â”€â”€ Fruit has mutation attribute:", mutation)
							end
						end
					end
				end
				if VariantFilterEnabled then
					-- Check for variant StringValue
					local variantObj = Item:FindFirstChild("Variant")
					if variantObj and variantObj:IsA("StringValue") then
						print("   â””â”€â”€ Fruit has variant StringValue:", variantObj.Value)
					else
						-- Fallback to attributes
						for variant, selected in pairs(SelectedVariants) do
							if selected and Item:GetAttribute(variant) then
								print("   â””â”€â”€ Fruit has variant attribute:", variant)
							end
						end
					end
				end
				table.insert(Plants, Item)
			else
				local reason = ""
				if not passesMutationFilter then reason = reason .. " (mutation filter)" end
				if not passesVariantFilter then reason = reason .. " (variant filter)" end
				print("â­ï¸ Skipping fruit due to filter:", Item.Name .. reason)
			end
		end
	end
	return Plants
end

-- CollectHarvestable function (Exact from SloppyCoding)
local function CollectHarvestable(Parent, Plants, IgnoreDistance)
	local Character = LocalPlayer.Character
	if not Character then
		return Plants
	end

	local PlayerPosition = Character:GetPivot().Position

	for _, Plant in pairs(Parent:GetChildren()) do
		-- Check if auto collect is still enabled
		if not AutoCollectPlantsEnabled then
			break
		end
		-- Fruits - recursively check fruit folders with selection filter
		local Fruits = Plant:FindFirstChild("Fruits")
				or Plant:FindFirstChild("Fruit")
				or Plant:FindFirstChild("Fruit_Spawn")
		if Fruits then
			-- STRICT: Only collect fruits if parent plant is explicitly selected
			local isParentPlantSelected = false
			if SelectedPlantsToCollect and next(SelectedPlantsToCollect) then
				for selectedPlant, selected in pairs(SelectedPlantsToCollect) do
					if selected and Plant.Name == selectedPlant then
						isParentPlantSelected = true
						break
					end
				end
			end
			-- NO BACKWARD COMPATIBILITY - Must be explicitly selected

			if isParentPlantSelected then
				print("ðŸŽ¯ Collecting fruits from selected plant:", Plant.Name)
				-- For fruits, we need to recursively call but also filter individual fruits
				CollectHarvestableWithFilters(Fruits, Plants, IgnoreDistance)
			else
				print("â­ï¸ Skipping fruits from unselected plant:", Plant.Name)
			end
		end

		-- Distance check (skip if too far and not ignoring distance)
		local PlantPosition = Plant:GetPivot().Position
		local Distance = (PlayerPosition - PlantPosition).Magnitude
		if not IgnoreDistance and Distance > 15 then
			continue
		end

		-- STRICT: Check if plant is explicitly selected for collection
		local isPlantSelected = false
		if SelectedPlantsToCollect and next(SelectedPlantsToCollect) then
			-- Check if this specific plant name is selected
			for selectedPlant, selected in pairs(SelectedPlantsToCollect) do
				if selected and Plant.Name == selectedPlant then
					isPlantSelected = true
					break
				end
			end
		end
		-- NO BACKWARD COMPATIBILITY - Must be explicitly selected

		-- Collect if harvestable, selected, and passes mutation/variant filters
		if CanHarvest(Plant) and isPlantSelected then
			-- Check mutation and variant filters
			local passesMutationFilter = hasSelectedMutation(Plant)
			local passesVariantFilter = hasSelectedVariant(Plant)

			if passesMutationFilter and passesVariantFilter then
				print("ðŸŽ¯ Adding selected plant to collection list:", Plant.Name)
				-- Debug mutation and variant info
				if MutationFilterEnabled then
					for mutation, selected in pairs(SelectedMutations) do
						if selected then
							-- Check StringValue objects
							local mutationObj = Plant:FindFirstChild(mutation)
							if mutationObj and mutationObj:IsA("StringValue") then
								print("   â””â”€â”€ Plant has mutation StringValue:", mutation)
							elseif Plant:GetAttribute(mutation) then
								print("   â””â”€â”€ Plant has mutation attribute:", mutation)
							end
						end
					end
				end
				if VariantFilterEnabled then
					-- Check for variant StringValue
					local variantObj = Plant:FindFirstChild("Variant")
					if variantObj and variantObj:IsA("StringValue") then
						print("   â””â”€â”€ Plant has variant StringValue:", variantObj.Value)
					else
						-- Fallback to attributes
						for variant, selected in pairs(SelectedVariants) do
							if selected and Plant:GetAttribute(variant) then
								print("   â””â”€â”€ Plant has variant attribute:", variant)
							end
						end
					end
				end
				table.insert(Plants, Plant)
			else
				local reason = ""
				if not passesMutationFilter then reason = reason .. " (mutation filter)" end
				if not passesVariantFilter then reason = reason .. " (variant filter)" end
				print("â­ï¸ Skipping plant due to filter:", Plant.Name .. reason)
			end
		elseif CanHarvest(Plant) and not isPlantSelected then
			print("â­ï¸ Skipping unselected plant:", Plant.Name)
		end
	end
	return Plants
end

-- GetHarvestablePlants function (Exact from SloppyCoding)
local function GetHarvestablePlants(IgnoreDistance)
	local Plants = {}

	local success, result = pcall(function()
		local myFarm = getMyFarm()
		if myFarm then
			-- Check if there's a nested Farm folder inside the main farm folder
			local innerFarm = myFarm:FindFirstChild("Farm")
			if innerFarm then
				myFarm = innerFarm
			end

			local important = myFarm:FindFirstChild("Important")
			if important then
				-- Double-check this is actually our farm by verifying owner
				local data = important:FindFirstChild("Data")
				if data and data:FindFirstChild("Owner") and data.Owner.Value == LocalPlayer.Name then
					local plantsPhysical = important:FindFirstChild("Plants_Physical")
					if plantsPhysical then
						CollectHarvestable(plantsPhysical, Plants, IgnoreDistance)
					end
				end
			end
		end
	end)

	if not success then
		print("Error in GetHarvestablePlants:", result)
		-- Return empty table on error instead of crashing
		return {}
	end

	return Plants
end

-- collectAllPlants function (Exact from SloppyCoding)
local function collectAllPlants()
	-- Wrap entire function in error handling
	local success, result = pcall(function()
		-- Check if we need to equip Harvest Tool first
		local player = LocalPlayer
		local backpack = player:FindFirstChild("Backpack")
		local harvestTool = nil

		if backpack then
			harvestTool = backpack:FindFirstChild("Harvest Tool")
			if harvestTool and player.Character and player.Character:FindFirstChild("Humanoid") then
				print("Equipping Harvest Tool...")
				player.Character.Humanoid:EquipTool(harvestTool)
				task.wait(0.5)
			else
				print("No Harvest Tool found in backpack or character not ready")
			end
		end

		-- Enhanced noclip for better plant access
		local function enableNoclip()
			if LocalPlayer.Character then
				for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
					if part:IsA("BasePart") then
						part.CanCollide = false
						if part.Name ~= "HumanoidRootPart" then
							part.Massless = true
						end
					end
				end
			end
		end

		-- Disable noclip and restore physics
		local function disableNoclip()
			if LocalPlayer.Character then
				print("Disabling noclip and restoring physics...")
				for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						part.CanCollide = true
						part.Massless = false

						-- Extra restoration for legs specifically
						if string.find(part.Name:lower(), "leg")
								or string.find(part.Name:lower(), "foot")
								or string.find(part.Name:lower(), "ankle") then
							part.CanCollide = true
							part.Massless = false
							part.Material = Enum.Material.Plastic
							print("Restored leg physics for:", part.Name)
						end
					end
				end

				-- Force physics refresh
				local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
				if humanoid then
					humanoid.PlatformStand = false -- Ensure not platform standing
				end
				print("Noclip disabled and physics restored")
			end
		end

		print("=== STARTING AUTO COLLECT ALL PLANTS ===")

		-- Check if character exists before starting
		if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
			Library:Notify("âŒ Character not ready! Try again in a moment.", 3)
			return
		end

		-- Enable noclip for better movement
		enableNoclip()
		-- Get all harvestable plants (simplified - single attempt)
		local Plants = GetHarvestablePlants(true) -- Ignore distance to collect from entire farm
		print("Found", #Plants, "harvestable plants")
		if #Plants == 0 then
			-- STRICT: Always require plant selection
			local selectedCount = 0
			if SelectedPlantsToCollect then
				for _, selected in pairs(SelectedPlantsToCollect) do
					if selected then
						selectedCount = selectedCount + 1
					end
				end
			end

			if selectedCount > 0 then
				Library:Notify(
						"âŒ No harvestable plants found! Selected " .. selectedCount .. " types but none are ready to harvest.",
						4
				)
			else
				Library:Notify("âŒ SAFETY: No plants selected for collection! Select plants in dropdown first.", 4)
			end
			disableNoclip()
			return
		end

		-- Show what we found
		local selectedCount = 0
		if SelectedPlantsToCollect then
			for _, selected in pairs(SelectedPlantsToCollect) do
				if selected then
					selectedCount = selectedCount + 1
				end
			end
		end

		if selectedCount > 0 then
			Library:Notify(
					"ðŸšœ Found "
							.. #Plants
							.. " harvestable plants from "
							.. selectedCount
							.. " selected types! Starting collection...",
					4
			)
		else
			Library:Notify("ðŸšœ Found " .. #Plants .. " harvestable plants (all types)! Starting collection...", 4)
		end

		local harvestedCount = 0

		-- Visit each plant and harvest it
		for i, Plant in pairs(Plants) do
			-- Check if auto collect is still enabled
			if not AutoCollectPlantsEnabled then
				print("Auto collect stopped by user!")
				break
			end

			-- Check if character still exists (in case of respawn)
			if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
				print("Character was lost during collection! Stopping...")
				Library:Notify("âŒ Character was lost! Auto collect stopped.", 3)
				break
			end

			-- Check if plant still exists
			if not Plant or not Plant.Parent then
				print("Plant", i, "no longer exists, skipping...")
				continue
			end

			-- ULTRA SAFETY PRE-HARVEST: Final verification before attempting harvest
			local plantType = GetPlantTypeFromName(Plant.Name)
			if not plantType or not SelectedPlantsToCollect[plantType] then
				print("âŒ ULTRA SAFETY: Plant", Plant.Name, "is NOT in selected filters - SKIPPING")
				continue
			end

			-- Verify plant has a proximity prompt
			if not Plant:FindFirstChild("ProximityPrompt", true) then
				print("âŒ ULTRA SAFETY: Plant", Plant.Name, "has no ProximityPrompt - SKIPPING")
				continue
			end

			print("âœ… ULTRA SAFE: Pre-harvest verification passed for", Plant.Name)
			print("Processing plant", i, "of", #Plants, ":", Plant.Name) -- Teleport directly to the plant (simplified)
			local teleportSuccess = pcall(function()
				local plantPosition = Plant:GetPivot().Position
				print("Teleporting to plant:", Plant.Name, "at position:", plantPosition)

				-- Single teleport directly to plant
				LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(plantPosition + Vector3.new(0, 1, 0))
			end)

			if not teleportSuccess then
				print("Failed to teleport to plant:", Plant.Name)
				continue
			end

			-- Harvest the plant with error handling and final safety check
			local harvestSuccess, harvestResult = pcall(function()
				-- FINAL SAFETY CHECK: Verify plant is still valid right before harvest
				if not Plant or not Plant.Parent then
					error("Plant disappeared before harvest")
				end

				local plantType = GetPlantTypeFromName(Plant.Name)
				if not plantType or not SelectedPlantsToCollect[plantType] then
					error("Plant no longer in selected filters")
				end

				print("ðŸŽ¯ FINAL SAFETY: Initiating ultra-safe harvest of", Plant.Name)
				return HarvestPlant(Plant)
			end)

			if harvestSuccess and harvestResult then
				harvestedCount = harvestedCount + 1
				Library:Notify("âœ… Harvested " .. Plant.Name, 1)
				print("Successfully harvested:", Plant.Name)
			else
				print("Failed to harvest:", Plant.Name, harvestSuccess and "" or harvestResult)
				Library:Notify("âŒ Failed to harvest " .. Plant.Name, 1)
			end -- Quick wait before moving to next plant
			task.wait(0.1) -- Reduced from 0.2 to 0.1 seconds
		end

		-- Restore physics
		disableNoclip()

		print("=== AUTO COLLECT COMPLETED ===")
		print("Harvested", harvestedCount, "out of", #Plants, "plants")

		if harvestedCount > 0 then
			Library:Notify("ðŸšœ Harvested " .. harvestedCount .. " plants successfully!", 4)
		else
			Library:Notify("âŒ No plants were harvested this cycle", 3)
		end
	end)

	-- Handle any errors that occur during collection
	if not success then
		print("Error in collectAllPlants:", result)
		Library:Notify("âŒ Auto collect encountered an error: " .. tostring(result), 4)

		-- Try to restore physics even if there was an error
		pcall(function()
			restoreCharacterPhysics()
		end)
	end
end

-- Plant selection dropdown for auto farm (Exact from SloppyCoding)
AutoFarmGroupBox:AddDropdown("PlantsToCollect", {
	Values = {
		-- All plants/fruits from game files (PlantTraitsData + SeedData) - 2025 Update
		"Aloe Vera",
		"Apple",
		"Avocado",
		"Bamboo",
		"Banana",
		"Beanstalk",
		"Bee Balm",
		"Bell Pepper",
		"Bendboo",
		"Blood Banana",
		"Blue Lollipop",
		"Blueberry",
		"Burning Bud",
		"Cacao",
		"Cactus",
		"Candy Blossom",
		"Candy Sunflower",
		"Cantaloupe",
		"Carrot",
		"Cauliflower",
		"Celestiberry",
		"Cherry Blossom",
		"Chocolate Carrot",
		"Cocovine",
		"Coconut",
		"Corn",
		"Cranberry",
		"Crimson Vine",
		"Crocus",
		"Cursed Fruit",
		"Daffodil",
		"Dandelion",
		"Delphinium",
		"Dragon Fruit",
		"Dragon Pepper",
		"Durian",
		"Easter Egg",
		"Eggplant",
		"Elephant Ears",
		"Ember Lily",
		"Feijoa",
		"Foxglove",
		"Glowshroom",
		"Grape",
		"Green Apple",
		"Guanabana",
		"Hive Fruit",
		"Honeysuckle",
		"Ice Cream Bean",
		"Kiwi",
		"Lavender",
		"Lemon",
		"Lilac",
		"Lily of the Valley",
		"Lime",
		"Loquat",
		"Lotus",
		"Lumira",
		"Mango",
		"Manuka Flower",
		"Mega Mushroom",
		"Mint",
		"Moon Blossom",
		"Moon Mango",
		"Moon Melon",
		"Moonflower",
		"Moonglow",
		"Mushroom",
		"Nectar Thorn",
		"Nectarine",
		"Nectarshade",
		"Nightshade",
		"Noble Flower",
		"Orange Tulip",
		"Papaya",
		"Parasol Flower",
		"Passionfruit",
		"Peace Lily",
		"Peach",
		"Pear",
		"Pepper",
		"Pineapple",
		"Pink Lily",
		"Pink Tulip",
		"Pitcher Plant",
		"Prickly Pear",
		"Pumpkin",
		"Purple Cabbage",
		"Purple Dahlia",
		"Rafflesia",
		"Raspberry",
		"Red Lollipop",
		"Rose",
		"Rosy Delight",
		"Soul Fruit",
		"Starfruit",
		"Strawberry",
		"Succulent",
		"Sugar Apple",
		"Suncoil",
		"Sunflower",
		"Tomato",
		"Traveler's Fruit",
		"Venus Fly Trap",
		"Violet Corn",
		"Watermelon",
		"White Mullberry",
		"Wild Carrot",
	},
	Default = 1,
	Multi = true, -- Allow multiple selections

	Text = "Select Plants/Fruits to Collect",
	Tooltip = "Choose which plants and fruits to auto-collect. Only selected plants will be teleported to and collected. Updated with ALL 102 plants from game files!",

	Callback = function(Value)
		print("[cb] Selected plants/fruits for collection changed:")
		SelectedPlantsToCollect = Value
		for plant, selected in next, Options.PlantsToCollect.Value do
			print(plant, selected)
		end
	end,
})

-- Mutation Selection Dropdown
AutoFarmGroupBox:AddDropdown("MutationsToCollect", {
	Values = AllMutations,
	Default = 1,
	Multi = true, -- Allow multiple selections

	Text = "Select Mutations to Collect",
	Tooltip = "Choose which mutations to filter for. When mutation filter is enabled, only fruits/plants with these mutations will be collected.",

	Callback = function(Value)
		print("[cb] Selected mutations for collection changed:")
		SelectedMutations = Value
		for mutation, selected in next, Options.MutationsToCollect.Value do
			print(mutation, selected)
		end
	end,
})

-- Mutation Filter Toggle
AutoFarmGroupBox:AddToggle("MutationFilter", {
	Text = "Enable Mutation Filter",
	Tooltip = "When enabled, only collect fruits/plants that have the selected mutations above.",
	Default = false,
	Callback = function(Value)
		print("[cb] Mutation Filter toggled:", Value)
		MutationFilterEnabled = Value
		if Value then
			local selectedCount = 0
			if SelectedMutations then
				for _, selected in pairs(SelectedMutations) do
					if selected then selectedCount = selectedCount + 1 end
				end
			end
			if selectedCount > 0 then
				Library:Notify("ðŸ§¬ Mutation filter enabled! Will only collect " .. selectedCount .. " selected mutations", 3)
			else
				Library:Notify("âš ï¸ Mutation filter enabled but no mutations selected!", 3)
			end
		else
			Library:Notify("ðŸ§¬ Mutation filter disabled - collecting all mutations", 2)
		end
	end,
})

-- Variant Selection Dropdown
AutoFarmGroupBox:AddDropdown("VariantsToCollect", {
	Values = AllVariants,
	Default = 1,
	Multi = true, -- Allow multiple selections

	Text = "Select Variants to Collect",
	Tooltip = "Choose which variants to filter for. When variant filter is enabled, only fruits/plants with these variants will be collected.",

	Callback = function(Value)
		print("[cb] Selected variants for collection changed:")
		SelectedVariants = Value
		for variant, selected in next, Options.VariantsToCollect.Value do
			print(variant, selected)
		end
	end,
})

-- Variant Filter Toggle
AutoFarmGroupBox:AddToggle("VariantFilter", {
	Text = "Enable Variant Filter",
	Tooltip = "When enabled, only collect fruits/plants that have the selected variants above.",
	Default = false,
	Callback = function(Value)
		print("[cb] Variant Filter toggled:", Value)
		VariantFilterEnabled = Value
		if Value then
			local selectedCount = 0
			if SelectedVariants then
				for _, selected in pairs(SelectedVariants) do
					if selected then selectedCount = selectedCount + 1 end
				end
			end
			if selectedCount > 0 then
				Library:Notify("âœ¨ Variant filter enabled! Will only collect " .. selectedCount .. " selected variants", 3)
			else
				Library:Notify("âš ï¸ Variant filter enabled but no variants selected!", 3)
			end
		else
			Library:Notify("âœ¨ Variant filter disabled - collecting all variants", 2)
		end
	end,
})

-- Auto Collect Toggle
AutoFarmGroupBox:AddToggle("AutoCollectAllPlants", {
	Text = "Auto Collect Selected Plants",
	Tooltip = "Automatically collect mature fruits, vegetables and items from your selected plants. Respects mutation and variant filters if enabled.",
	Default = false,
	Callback = function(Value)
		print("[cb] Auto Collect All Plants toggled:", Value)
		AutoCollectPlantsEnabled = Value
		if Value then
			-- SAFETY CHECK: Ensure at least one plant is selected
			local selectedCount = 0
			if SelectedPlantsToCollect then
				for _, selected in pairs(SelectedPlantsToCollect) do
					if selected then
						selectedCount = selectedCount + 1
					end
				end
			end

			-- PREVENT AUTO COLLECT IF NO PLANTS SELECTED
			if selectedCount == 0 then
				Library:Notify("âŒ Cannot start Auto Collect! No plants selected. Please select plants first.", 4)
				-- Turn the toggle back off
				Toggles.AutoCollectAllPlants:SetValue(false)
				return
			end

			local filterInfo = ""
			if MutationFilterEnabled then
				local mutationCount = 0
				if SelectedMutations then
					for _, selected in pairs(SelectedMutations) do
						if selected then mutationCount = mutationCount + 1 end
					end
				end
				filterInfo = filterInfo .. " | Mutations: " .. mutationCount
			end
			if VariantFilterEnabled then
				local variantCount = 0
				if SelectedVariants then
					for _, selected in pairs(SelectedVariants) do
						if selected then variantCount = variantCount + 1 end
					end
				end
				filterInfo = filterInfo .. " | Variants: " .. variantCount
			end

			Library:Notify(
					"ðŸšœ Auto Collect enabled! (" .. selectedCount .. " plant types selected" .. filterInfo .. ")",
					3
			)

			-- Start auto collection loop
			task.spawn(function()
				while AutoCollectPlantsEnabled do
					if AutoCollectPlantsEnabled then -- Double check before starting collection
						print("ðŸšœ Starting collection cycle...")
						collectAllPlants()
					end

					-- Wait between collection cycles, but check if still enabled
					for i = 1, 3 do -- 1.5 seconds total wait (0.5s x 3)
						if not AutoCollectPlantsEnabled then
							break
						end
						task.wait(0.5)
					end
				end
				print("Auto collect all plants loop ended")
				-- Ensure cleanup when loop ends
				restoreCharacterPhysics()
			end)
		else
			Library:Notify("ðŸšœ Auto Collect Selected Plants disabled!", 3)
			print("Auto collect selected plants disabled by user")
			-- Immediate cleanup when toggle is turned off
			restoreCharacterPhysics()
		end
	end,
})

AutoFarmGroupBox:AddDivider()

-- Utility Buttons
AutoFarmGroupBox:AddButton("ï¸ Clear All Filters", function()
	-- Clear all selections
	SelectedPlantsToCollect = {}
	SelectedMutations = {}
	SelectedVariants = {}

	-- Update dropdowns
	if Options.PlantsToCollect then
		Options.PlantsToCollect:SetValue({})
	end
	if Options.MutationsToCollect then
		Options.MutationsToCollect:SetValue({})
	end
	if Options.VariantsToCollect then
		Options.VariantsToCollect:SetValue({})
	end

	-- Disable filters
	if Toggles.MutationFilter then
		Toggles.MutationFilter:SetValue(false)
	end
	if Toggles.VariantFilter then
		Toggles.VariantFilter:SetValue(false)
	end

	Library:Notify("ðŸ—‘ï¸ Cleared all plant, mutation, and variant filters", 3)
end)

-- ================================================================
-- UI SETTINGS TAB (Complete Implementation)
-- ================================================================
local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")

-- Keybind Menu Toggle
MenuGroup:AddToggle("KeybindMenuOpen", {
	Default = Library.KeybindFrame.Visible,
	Text = "Open Keybind Menu",
	Tooltip = "Toggle the visibility of the keybind menu",
	Callback = function(Value)
		Library.KeybindFrame.Visible = Value
	end,
})

-- Custom Cursor Toggle
MenuGroup:AddToggle("ShowCustomCursor", {
	Text = "Custom Cursor",
	Default = true,
	Tooltip = "Enable/disable the custom cursor",
	Callback = function(Value)
		Library.ShowCustomCursor = Value
	end,
})

-- Notification Side Dropdown
MenuGroup:AddDropdown("NotificationSide", {
	Values = { "Left", "Right" },
	Default = "Right",
	Text = "Notification Side",
	Tooltip = "Choose which side notifications appear on",
	Callback = function(Value)
		Library:SetNotifySide(Value)
	end,
})

-- DPI Scale Dropdown
MenuGroup:AddDropdown("DPIDropdown", {
	Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
	Default = "100%",
	Text = "DPI Scale",
	Tooltip = "Adjust the UI scale for different screen sizes",
	Callback = function(Value)
		Value = Value:gsub("%%", "")
		local DPI = tonumber(Value)
		Library:SetDPIScale(DPI)
	end,
})

-- Divider
MenuGroup:AddDivider()

-- Menu Keybind
MenuGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", {
	Default = "RightShift",
	NoUI = true,
	Text = "Menu keybind",
	Tooltip = "Key to open/close the menu"
})

-- Unload Button
MenuGroup:AddButton({
	Text = "Unload",
	Func = function()
		Library:Unload()
	end,
	Tooltip = "Completely unload the script",
	Risky = true
})

-- ================================================================
-- LIBRARY SETUP & ADDON MANAGEMENT
-- ================================================================

-- Set the menu keybind
Library.ToggleKeybind = Options.MenuKeybind

-- Unload handler
Library:OnUnload(function()
	print("REFACTOR unloaded!")
end)

-- ================================================================
-- THEME & SAVE MANAGER SETUP
-- ================================================================

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

-- Ignore keys that are used by ThemeManager
SaveManager:IgnoreThemeSettings()

-- Add MenuKeybind to ignore list (so each config doesn't override the menu key)
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

-- Set up folder structure for configs and themes
ThemeManager:SetFolder("GrowAGardenClean")
SaveManager:SetFolder("GrowAGardenClean/configs")

-- Build the config and theme sections in UI Settings
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

-- Load autoload config if available
SaveManager:LoadAutoloadConfig()

-- ================================================================
-- WELCOME MESSAGE
-- ================================================================
Library:Notify("REFACTOR loaded successfully! Exact SloppyCoding recreation.", 3)
print("ðŸŒ± REFACTOR - Ready for farming!")

-- ================================================================
-- AUTO SPRINKLER SYSTEM
-- ================================================================
local AutoSprinklerGroupBox = Tabs.Main:AddLeftGroupbox("Auto Sprinkler")

-- Global variables for Auto Sprinkler
local AutoSprinklerEnabled = false
local SelectedSprinklerType = nil
local SelectedSprinklerPlacementMethod = "Random"
local SelectedSprinklerPlants = {}

-- Get available sprinkler types from SprinklerData
local AvailableSprinklers = {}
local success, result = pcall(function()
    return require(game:GetService("ReplicatedStorage").Data.ModuleScripts.SprinklerData).SprinklerBoxSizes
end)

if not success then
    -- Fallback to ReplicatedStorage.Data.SprinklerData if ModuleScripts path fails
    success, result = pcall(function()
        return require(game:GetService("ReplicatedStorage").Data.SprinklerData).SprinklerBoxSizes
    end)
end

if success and result then
    for sprinklerName, _ in pairs(result) do
        table.insert(AvailableSprinklers, sprinklerName)
    end
else
    -- Fallback to hardcoded sprinkler list
    AvailableSprinklers = {
        "Basic Sprinkler",
        "Advanced Sprinkler",
        "Godly Sprinkler",
        "Master Sprinkler",
        "Honey Sprinkler",
        "Chocolate Sprinkler",
        "Tropical Mist Sprinkler"
    }
end
table.sort(AvailableSprinklers) -- Sort alphabetically

-- Dropdown for sprinkler selection
AutoSprinklerGroupBox:AddDropdown("SprinklerSelection", {
    Values = AvailableSprinklers,
    Default = 1,
    Multi = false,
    Text = "Select Sprinkler Type",
    Tooltip = "Choose which sprinkler type to place",
    Callback = function(Value)
        SelectedSprinklerType = Value
        print("[cb] Selected sprinkler type:", Value)
    end
})

-- Plant selection dropdown for sprinkler (separate from auto farm)
AutoSprinklerGroupBox:AddDropdown("SprinklerPlantsToTarget", {
    Values = {
        -- Same plant list as auto farm but separate selection
        "Aloe Vera", "Apple", "Avocado", "Bamboo", "Banana", "Beanstalk", "Bee Balm", "Bell Pepper",
        "Bendboo", "Blood Banana", "Blue Lollipop", "Blueberry", "Burning Bud", "Cacao", "Cactus",
        "Candy Blossom", "Candy Sunflower", "Cantaloupe", "Carrot", "Cauliflower", "Celestiberry",
        "Cherry Blossom", "Chocolate Carrot", "Cocovine", "Coconut", "Corn", "Cranberry", "Crimson Vine",
        "Crocus", "Cursed Fruit", "Daffodil", "Dandelion", "Delphinium", "Dragon Fruit", "Dragon Pepper",
        "Durian", "Easter Egg", "Eggplant", "Elephant Ears", "Ember Lily", "Feijoa", "Foxglove",
        "Glowshroom", "Grape", "Green Apple", "Guanabana", "Hive Fruit", "Honeysuckle", "Ice Cream Bean",
        "Kiwi", "Lavender", "Lemon", "Lilac", "Lily of the Valley", "Lime", "Loquat", "Lotus", "Lumira",
        "Mango", "Manuka Flower", "Mega Mushroom", "Mint", "Moon Blossom", "Moon Mango", "Moon Melon",
        "Moonflower", "Moonglow", "Mushroom", "Nectar Thorn", "Nectarine", "Nectarshade", "Nightshade",
        "Noble Flower", "Orange Tulip", "Papaya", "Parasol Flower", "Passionfruit", "Peace Lily", "Peach",
        "Pear", "Pepper", "Pineapple", "Pink Lily", "Pink Tulip", "Pitcher Plant", "Prickly Pear",
        "Pumpkin", "Purple Cabbage", "Purple Dahlia", "Rafflesia", "Raspberry", "Red Lollipop", "Rose",
        "Rosy Delight", "Soul Fruit", "Starfruit", "Strawberry", "Succulent", "Sugar Apple", "Suncoil",
        "Sunflower", "Tomato", "Traveler's Fruit", "Venus Fly Trap", "Violet Corn", "Watermelon",
        "White Mullberry", "Wild Carrot",
    },
    Default = 1,
    Multi = true, -- Allow multiple selections
    Text = "Select Plants for Sprinkler",
    Tooltip = "Choose which plants to target for sprinkler placement. Used with 'Selected Plant' method.",
    Callback = function(Value)
        print("[cb] Selected plants for sprinkler targeting changed:")
        SelectedSprinklerPlants = Value
        for plant, selected in next, Options.SprinklerPlantsToTarget.Value do
            print(plant, selected)
        end
    end,
})

-- Dropdown for placement method
AutoSprinklerGroupBox:AddDropdown("SprinklerPlacementMethod", {
    Values = {"Selected Plant", "Random", "Player Position"},
    Default = 2, -- Default to Random
    Multi = false,
    Text = "Placement Method",
    Tooltip = "Choose how to place sprinklers:\nâ€¢ Selected Plant: Teleport to selected plant and place at feet\nâ€¢ Random: Place on random Can_Plant in farm\nâ€¢ Player Position: Place at current player position",
    Callback = function(Value)
        SelectedSprinklerPlacementMethod = Value
        print("[cb] Selected sprinkler placement method:", Value)
    end
})

-- Function to check if we have the sprinkler in inventory
local function hasSprinklerInInventory()
    if not SelectedSprinklerType then
        return false, nil
    end

    local backpack = LocalPlayer:FindFirstChild("Backpack")
    local foundSprinkler = false
    local sprinklerName = nil

    if backpack then
        -- First try exact match
        local exactMatch = backpack:FindFirstChild(SelectedSprinklerType)
        if exactMatch then
            foundSprinkler = true
            sprinklerName = exactMatch.Name
        else
            -- Try with partial match (for items with quantity like "Basic Sprinkler x2")
            for _, item in pairs(backpack:GetChildren()) do
                if item:IsA("Tool") and string.find(item.Name, SelectedSprinklerType) then
                    foundSprinkler = true
                    sprinklerName = item.Name
                    break
                end
            end
        end
    end

    -- Also check if it's already equipped in character
    if not foundSprinkler and LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and string.find(item.Name, SelectedSprinklerType) then
                foundSprinkler = true
                sprinklerName = item.Name
                break
            end
        end
    end

    return foundSprinkler, sprinklerName
end

-- Function to place sprinkler (modeled after auto farm teleportation)
local function placeSprinkler()
    -- Safety checks
    if not SelectedSprinklerType then
        Library:Notify("âš ï¸ Please select a sprinkler type first!", 3)
        return
    end

    if not LocalPlayer or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        Library:Notify("âŒ Character not loaded. Try again!", 3)
        return
    end

    -- Check if we have the sprinkler in inventory
    local hasSprinkler, sprinklerName = hasSprinklerInInventory()
    if not hasSprinkler then
        Library:Notify("âŒ You don't have " .. SelectedSprinklerType .. " in your inventory!", 3)
        return
    end

    print("ðŸ” Found sprinkler in inventory: " .. (sprinklerName or SelectedSprinklerType))

    -- Equip the sprinkler tool first
    local sprinklerTool = nil
    local backpack = LocalPlayer:FindFirstChild("Backpack")

    -- Find the tool in backpack
    if backpack then
        sprinklerTool = backpack:FindFirstChild(sprinklerName)
        if not sprinklerTool then
            -- Try partial match
            for _, item in pairs(backpack:GetChildren()) do
                if item:IsA("Tool") and string.find(item.Name, SelectedSprinklerType) then
                    sprinklerTool = item
                    break
                end
            end
        end
    end

    -- Check if already equipped
    if not sprinklerTool and LocalPlayer.Character then
        for _, item in pairs(LocalPlayer.Character:GetChildren()) do
            if item:IsA("Tool") and string.find(item.Name, SelectedSprinklerType) then
                sprinklerTool = item
                break
            end
        end
    end

    if sprinklerTool then
        -- Equip the tool if not already equipped
        if sprinklerTool.Parent == backpack then
            print("ðŸ”§ Equipping sprinkler tool:", sprinklerTool.Name)
            LocalPlayer.Character.Humanoid:EquipTool(sprinklerTool)
            task.wait(0.5) -- Wait for tool to be equipped
        else
            print("ðŸ”§ Sprinkler tool already equipped:", sprinklerTool.Name)
        end
    else
        Library:Notify("âŒ Could not find sprinkler tool to equip!", 3)
        return
    end

    -- Enable noclip for teleportation (same as auto farm)
    local function enableNoclip()
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                    if part.Name ~= "HumanoidRootPart" then
                        part.Massless = true
                    end
                end
            end
        end
    end

    local function disableNoclip()
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                    part.CanCollide = true
                    part.Massless = false
                end
            end
        end
    end

    -- Store original position for return (like auto farm does)
    local originalPosition = LocalPlayer.Character.HumanoidRootPart.CFrame
    local placementPosition = nil

    -- Enable noclip for smooth teleportation
    enableNoclip()

    if SelectedSprinklerPlacementMethod == "Player Position" then
        -- Place at current player position
        placementPosition = LocalPlayer.Character.HumanoidRootPart.Position
        print("ðŸš¶ Using player position:", placementPosition)

    elseif SelectedSprinklerPlacementMethod == "Random" then
        -- Place on random Can_Plant in farm (like auto farm does)
        local success, result = pcall(function()
            local myFarm = getMyFarm()
            if myFarm then
                local canPlantParts = {}
                -- Find all Can_Plant parts in the farm
                for _, child in pairs(myFarm:GetDescendants()) do
                    if child.Name == "Can_Plant" and child:IsA("BasePart") then
                        table.insert(canPlantParts, child)
                    end
                end

                if #canPlantParts > 0 then
                    -- Pick random Can_Plant part
                    local randomPart = canPlantParts[math.random(1, #canPlantParts)]
                    local randomPosition = randomPart.Position

                    print("ðŸŽ² Teleporting to random Can_Plant position:", randomPosition)
                    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(randomPosition + Vector3.new(0, 3, 0))
                    task.wait(0.3) -- Wait for teleport

                    placementPosition = LocalPlayer.Character.HumanoidRootPart.Position
                    return true
                end
            end
            return false
        end)

        if not success or not result then
            Library:Notify("âŒ Could not find Can_Plant parts for random placement!", 3)
            disableNoclip()
            return
        end

    elseif SelectedSprinklerPlacementMethod == "Selected Plant" then
        -- Teleport to selected plant (like auto farm does)
        local selectedPlant = nil
        local selectedPlants = Options.SprinklerPlantsToTarget and Options.SprinklerPlantsToTarget.Value

        if selectedPlants and next(selectedPlants) then
            for plantName, isSelected in pairs(selectedPlants) do
                if isSelected then
                    selectedPlant = plantName
                    break
                end
            end
        end

        if not selectedPlant then
            Library:Notify("âš ï¸ No plant selected for sprinkler. Please select a plant first.", 3)
            disableNoclip()
            return
        else
            local plantFound = false
            local success, result = pcall(function()
                local myFarm = getMyFarm()
                if myFarm then
                    local important = myFarm:FindFirstChild("Important")
                    if important then
                        local plantsPhysical = important:FindFirstChild("Plants_Physical")
                        if plantsPhysical then
                            for _, plant in pairs(plantsPhysical:GetChildren()) do
                                if string.find(plant.Name, selectedPlant) then
                                    local plantPosition = plant:GetPivot().Position
                                    print("ðŸš€ Teleporting to plant:", plant.Name, "at position:", plantPosition)
                                    LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(plantPosition + Vector3.new(0, 3, 0))
                                    task.wait(0.3) -- Wait for teleport

                                    -- Place sprinkler at player's feet after teleporting
                                    placementPosition = LocalPlayer.Character.HumanoidRootPart.Position
                                    print("ðŸŒ± Will place sprinkler at player's feet near selected plant:", placementPosition)
                                    plantFound = true
                                    return true
                                end
                            end
                        end
                    end
                end
                return false
            end)

            if not success or not result or not plantFound then
                Library:Notify("âš ï¸ Could not find selected plant '" .. selectedPlant .. "' in farm.", 3)
                disableNoclip()
                return
            else
                print("âœ… Successfully found and teleported to plant:", selectedPlant)
            end
        end
    end

    if not placementPosition then
        Library:Notify("âŒ Could not determine placement position.", 3)
        disableNoclip()
        return
    end

    -- Use the equipped sprinkler tool to place (like real tool usage)
    print("ðŸš¿ Placing sprinkler at position:", placementPosition)

    local success, err = pcall(function()
        -- Method 1: Try tool activation with placement
        if sprinklerTool and sprinklerTool.Parent == LocalPlayer.Character then
            print("ðŸ”§ Attempting sprinkler placement with equipped tool...")

            -- Activate the tool
            sprinklerTool:Activate()
            task.wait(0.2)

            -- Some sprinkler tools need mouse simulation for placement
            local mouse = LocalPlayer:GetMouse()
            if mouse then
                -- Create placement CFrame at ground level
                local placementCFrame = CFrame.new(placementPosition.X, placementPosition.Y - 2, placementPosition.Z)

                -- Try to simulate mouse click at placement position
                pcall(function()
                    -- Try setting mouse properties for placement
                    mouse.Hit = placementCFrame

                    -- Try different tool activation methods
                    if sprinklerTool:FindFirstChild("RemoteEvent") then
                        sprinklerTool.RemoteEvent:FireServer("Place", placementCFrame)
                    end

                    -- Try mouse button events
                    mouse.Button1Down:Fire()
                    task.wait(0.1)
                    mouse.Button1Up:Fire()
                end)
            end
        end

        -- Method 2: Direct remote event as backup
        local sprinklerService = game:GetService("ReplicatedStorage"):WaitForChild("GameEvents"):WaitForChild("SprinklerService")
        local placementCFrame = CFrame.new(placementPosition.X, placementPosition.Y - 2, placementPosition.Z) -- At ground level
        local args = {
            "Create",
            placementCFrame
        }
        sprinklerService:FireServer(unpack(args))
    end)

    -- Give some time for the placement to process
    task.wait(0.5)

    if success then
        Library:Notify("âœ… Successfully placed " .. SelectedSprinklerType .. " using " .. SelectedSprinklerPlacementMethod .. " method", 3)
    else
        Library:Notify("âŒ Failed to place sprinkler: " .. tostring(err), 3)
    end

    -- Return to original position if we teleported (except for player position method)
    if SelectedSprinklerPlacementMethod ~= "Player Position" then
        task.wait(0.3) -- Wait a bit more after placement
        print("ðŸ”„ Returning to original position")
        LocalPlayer.Character.HumanoidRootPart.CFrame = originalPosition
        task.wait(0.2)
    end

    -- Always disable noclip when done
    disableNoclip()
    print("ðŸ”§ Noclip disabled")
end

-- Button to place sprinkler
AutoSprinklerGroupBox:AddButton("Place Sprinkler", function()
    placeSprinkler()
end)

-- Toggle for auto placement
AutoSprinklerGroupBox:AddToggle("AutoPlaceSprinklers", {
    Text = "Auto Place Sprinklers",
    Default = false,
    Tooltip = "Automatically place sprinklers continuously until you run out of the selected sprinkler type in your inventory",
    Callback = function(Value)
        AutoSprinklerEnabled = Value
        if Value then
            if not SelectedSprinklerType then
                Library:Notify("âš ï¸ Please select a sprinkler type first!", 3)
                Toggles.AutoPlaceSprinklers:SetValue(false)
                return
            end

            local interval = Options.SprinklerInterval and Options.SprinklerInterval.Value or 60
            Library:Notify("ðŸš¿ Auto Sprinkler enabled! Will place " .. SelectedSprinklerType .. " every " .. interval .. " seconds until inventory is empty.", 3)

            -- Start continuous placement loop
            task.spawn(function()
                while AutoSprinklerEnabled do
                    -- Check if we still have the sprinkler in inventory
                    local hasSprinkler, sprinklerName = hasSprinklerInInventory()

                    if not hasSprinkler then
                        -- No more sprinklers in inventory, stop auto placement
                        Library:Notify("âœ… Auto Sprinkler finished! No more " .. SelectedSprinklerType .. " in inventory.", 3)
                        AutoSprinklerEnabled = false
                        Toggles.AutoPlaceSprinklers:SetValue(false) -- Turn off the toggle
                        break
                    end

                    -- Place sprinkler
                    print("ðŸš¿ Auto placing sprinkler:", sprinklerName)
                    placeSprinkler()

                    -- Wait interval before next placement (if still enabled)
                    if AutoSprinklerEnabled then
                        -- Get the current interval value from the slider (this allows real-time updates)
                        local currentInterval = Options.SprinklerInterval and Options.SprinklerInterval.Value or 60
                        print("â±ï¸ Waiting", currentInterval, "seconds before next placement...")

                        -- Break the wait into smaller chunks so we can stop quickly if disabled
                        for i = 1, currentInterval do
                            if not AutoSprinklerEnabled then
                                break
                            end
                            task.wait(1)
                        end
                    end
                end
                print("Auto sprinkler placement loop ended")
            end)
        else
            Library:Notify("ðŸš¿ Auto Sprinkler disabled!", 3)
        end
    end
})

-- Interval slider
AutoSprinklerGroupBox:AddSlider("SprinklerInterval", {
    Text = "Place Interval (seconds)",
    Default = 60,
    Min = 30,
    Max = 300,
    Rounding = 0,
    Compact = false,
    Tooltip = "How often to automatically place sprinklers (30-300 seconds)",
    Callback = function(Value)
        print("[cb] Sprinkler interval changed to", Value, "seconds")
    end
})

AutoSprinklerGroupBox:AddDivider()

-- ================================================================
-- AUTO SHOVEL SYSTEM
-- ================================================================
local AutoShovelGroupBox = Tabs.Main:AddRightGroupbox("Auto Shovel")

-- Global variables for Auto Shovel
local AutoShovelEnabled = false
local SelectedTreeToShovel = nil

-- All trees that can be shoveled
local AllTrees = {
    "Aloe Vera", "Apple", "Avocado", "Bamboo", "Banana", "Beanstalk", "Bee Balm", "Bell Pepper",
    "Bendboo", "Blood Banana", "Blue Lollipop", "Blueberry", "Burning Bud", "Cacao", "Cactus",
    "Candy Blossom", "Candy Sunflower", "Cantaloupe", "Carrot", "Cauliflower", "Celestiberry",
    "Cherry Blossom", "Chocolate Carrot", "Cocovine", "Coconut", "Corn", "Cranberry", "Crimson Vine",
    "Crocus", "Cursed Fruit", "Daffodil", "Dandelion", "Delphinium", "Dragon Fruit", "Dragon Pepper",
    "Durian", "Easter Egg", "Eggplant", "Elephant Ears", "Ember Lily", "Feijoa", "Foxglove",
    "Glowshroom", "Grape", "Green Apple", "Guanabana", "Hive Fruit", "Honeysuckle", "Ice Cream Bean",
    "Kiwi", "Lavender", "Lemon", "Lilac", "Lily of the Valley", "Lime", "Loquat", "Lotus", "Lumira",
    "Mango", "Manuka Flower", "Mega Mushroom", "Mint", "Moon Blossom", "Moon Mango", "Moon Melon",
    "Moonflower", "Moonglow", "Mushroom", "Nectar Thorn", "Nectarine", "Nectarshade", "Nightshade",
    "Noble Flower", "Orange Tulip", "Papaya", "Parasol Flower", "Passionfruit", "Peace Lily", "Peach",
    "Pear", "Pepper", "Pineapple", "Pink Lily", "Pink Tulip", "Pitcher Plant", "Prickly Pear",
    "Pumpkin", "Purple Cabbage", "Purple Dahlia", "Rafflesia", "Raspberry", "Red Lollipop", "Rose",
    "Rosy Delight", "Soul Fruit", "Starfruit", "Strawberry", "Succulent", "Sugar Apple", "Suncoil",
    "Sunflower", "Tomato", "Traveler's Fruit", "Venus Fly Trap", "Violet Corn", "Watermelon",
    "White Mulberry", "Wild Carrot"
}
table.sort(AllTrees) -- Sort alphabetically

-- Dropdown for tree selection
AutoShovelGroupBox:AddDropdown("TreeSelection", {
    Values = AllTrees,
    Default = 1,
    Multi = false, -- Only one tree type at a time
    Text = "Select Tree to Shovel",
    Tooltip = "Choose which tree type to auto shovel",
    Callback = function(Value)
        SelectedTreeToShovel = Value
        print("[cb] Selected tree for auto shovel:", Value)
    end
})

-- Copy of the real shovel functions from Shovel_Client.local.lua
local tbl_upvr_2 = {
    "Coconut", "Cactus", "Dragon Fruit", "Mango", "Grape", "Mushroom", "Pepper", "Cacao",
    "Beanstalk", "Ember Lily", "Sugar Apple", "Burning Bud", "Pineapple", "Cauliflower",
    "Green Apple", "Banana", "Avocado", "Kiwi", "Bell Pepper", "Prickly Pear", "Feijoa",
    "Loquat", "Rafflesia", "Pitcher Plant", "Lily of the Valley", "Traveler's Fruit",
    "Aloe Vera", "Guanabana", "Pear", "Cantaloupe", "Parasol Flower", "Rosy Delight",
    "Elephant Ears", "Peach", "Raspberry", "Papaya", "Passionfruit", "Soul Fruit",
    "Cursed Fruit", "Cranberry", "Durian", "Eggplant", "Lotus", "Venus Fly Trap",
    "Candy Blossom", "Easter Egg", "Moonflower", "Starfruit", "Moonglow", "Moon Blossom",
    "Glowshroom", "Nightshade", "Blood Banana", "Moon Melon", "Celestiberry", "Moon Mango",
    "Rose", "Foxglove", "Lilac", "Pink Lily", "Purple Dahlia", "Sunflower", "Hive Fruit",
    "Nectarine", "Dandelion", "Lumira", "Honeysuckle", "Succulent", "Violet Corn",
    "Bendboo", "Cocovine", "Dragon Pepper", "Bee Balm", "Nectar Thorn", "Suncoil",
    "Cherry Blossom", "Lemon", "Purple Cabbage", "Crimson Vine", "White Mulberry"
}
local tbl_upvr = {"Carrot"}

local function CheckIfValuable(plantName)
    for _, v in tbl_upvr_2 do
        if string.find(string.lower(plantName), string.lower(v)) then
            return true
        end
    end
    return false
end

local function CheckIfCantShovel(plantName)
    for _, v_2 in tbl_upvr do
        if string.find(string.lower(plantName), string.lower(v_2)) then
            return true
        end
    end
    return false
end

-- Raycasting function (copied from real Shovel_Client.local.lua)
local function RaycastToPosition(position)
    local CurrentCamera = workspace.CurrentCamera
    local ViewportPointToRay_result = CurrentCamera:ViewportPointToRay(position.X, position.Y)
    local RaycastParams_new_result = RaycastParams.new()
    RaycastParams_new_result.FilterType = Enum.RaycastFilterType.Exclude
    RaycastParams_new_result.FilterDescendantsInstances = {Services.CollectionService:GetTagged("ShovelIgnore")}
    return workspace:Raycast(ViewportPointToRay_result.Origin, ViewportPointToRay_result.Direction * 500, RaycastParams_new_result)
end

-- Function to simulate mouse targeting and shovel a specific tree
local function simulateShovelClick(tree)
    if not tree or not tree.Parent then
        return false
    end

    -- Get a part from the tree to target
    local targetPart = tree.PrimaryPart or tree:FindFirstChildOfClass("Part")
    if not targetPart then
        print("âŒ Could not find a part to target on tree:", tree.Name)
        return false
    end

    -- Get the tree's center position
    local treeCenterPosition = targetPart.Position

    -- Convert world position to screen position for raycasting
    local camera = workspace.CurrentCamera
    local screenPosition, onScreen = camera:WorldToViewportPoint(treeCenterPosition)

    if not onScreen then
        print("âš ï¸ Tree not on screen, using direct position")
        screenPosition = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)
    else
        screenPosition = Vector2.new(screenPosition.X, screenPosition.Y)
    end

    -- Perform raycast from camera to tree (like real shovel does)
    local raycastResult = RaycastToPosition(screenPosition)

    if not raycastResult then
        print("âŒ Raycast missed - trying direct approach for:", tree.Name)
        -- Fallback: try to find any part in the tree
        local treeParts = {}
        for _, child in pairs(tree:GetDescendants()) do
            if child:IsA("BasePart") then
                table.insert(treeParts, child)
            end
        end

        if #treeParts > 0 then
            -- Use the first part we find
            local targetInstance = treeParts[1]
            print("ðŸŽ¯ Using fallback part:", targetInstance.Name, "from tree:", tree.Name)
            return targetInstance
        else
            print("âŒ No parts found in tree:", tree.Name)
            return false
        end
    end

    -- Check if raycast hit something in our target tree
    local hitInstance = raycastResult.Instance
    local hitModel = hitInstance:FindFirstAncestorWhichIsA("Model")

    if hitModel == tree then
        print("ðŸŽ¯ Raycast hit target tree successfully:", tree.Name, "- Instance:", hitInstance.Name)
        return hitInstance -- Return the exact instance that was hit (like real shovel)
    else
        print("âš ï¸ Raycast hit different object - trying tree parts for:", tree.Name)
        -- Fallback: find a suitable part from the tree
        local treeParts = {}
        for _, child in pairs(tree:GetDescendants()) do
            if child:IsA("BasePart") and child.CanCollide then
                table.insert(treeParts, child)
            end
        end

        if #treeParts > 0 then
            local targetInstance = treeParts[1]
            print("ðŸŽ¯ Using fallback collidable part:", targetInstance.Name, "from tree:", tree.Name)
            return targetInstance
        else
            print("âŒ No suitable parts found in tree:", tree.Name)
            return false
        end
    end
end

-- Function to shovel selected tree using real shovel logic with raycasting
local function shovelSelectedTree()
    if not SelectedTreeToShovel then
        print("âŒ No tree selected for shoveling")
        return
    end

    -- First, ensure shovel tool is equipped
    local player = LocalPlayer
    local backpack = player:FindFirstChild("Backpack")
    local shovelTool = nil

    -- Check if shovel is already equipped
    if player.Character and player.Character:FindFirstChild("Shovel [Destroy Plants]") then
        shovelTool = player.Character:FindFirstChild("Shovel [Destroy Plants]")
        print("ðŸ”§ Shovel already equipped")
    elseif backpack then
        shovelTool = backpack:FindFirstChild("Shovel [Destroy Plants]")
        if shovelTool and player.Character and player.Character:FindFirstChild("Humanoid") then
            print("ðŸ”§ Equipping Shovel [Destroy Plants]...")
            player.Character.Humanoid:EquipTool(shovelTool)
            task.wait(0.5) -- Wait for tool to be equipped
            shovelTool = player.Character:FindFirstChild("Shovel [Destroy Plants]")
        else
            print("âŒ No Shovel [Destroy Plants] found in backpack")
            Library:Notify("âŒ You need a Shovel [Destroy Plants] tool!", 3)
            return
        end
    else
        print("âŒ No backpack found")
        return
    end

    if not shovelTool then
        print("âŒ Failed to equip shovel tool")
        Library:Notify("âŒ Failed to equip shovel tool!", 3)
        return
    end

    -- Get player's farm
    local myFarm = getMyFarm()
    if not myFarm then
        print("âŒ No farm found")
        return
    end

    local important = myFarm:FindFirstChild("Important")
    if not important then
        print("âŒ No Important folder found")
        return
    end

    local plantsPhysical = important:FindFirstChild("Plants_Physical")
    if not plantsPhysical then
        print("âŒ No Plants_Physical folder found")
        return
    end

    -- Find trees matching the selected type
    local treesToShovel = {}
    for _, plant in pairs(plantsPhysical:GetChildren()) do
        if string.find(plant.Name, SelectedTreeToShovel) then
            table.insert(treesToShovel, plant)
        end
    end

    if #treesToShovel == 0 then
        print("âŒ No " .. SelectedTreeToShovel .. " trees found in farm")
        return
    end

    print("ðŸŒ³ Found " .. #treesToShovel .. " " .. SelectedTreeToShovel .. " trees to shovel")

    -- Get the Remove_Item remote
    local Remove_Item = Services.ReplicatedStorage:WaitForChild("GameEvents"):WaitForChild("Remove_Item")

    -- Shovel each matching tree using real shovel logic with raycasting
    for _, tree in pairs(treesToShovel) do
        if not AutoShovelEnabled then break end

        -- Apply all the real shovel checks from Shovel_Client.local.lua

        -- Check if plant exists and has Grow folder (required for growable plants)
        if not tree:FindFirstChild("Grow") then
            print("âš ï¸ Skipping - no Grow folder:", tree.Name)
            continue
        end

        -- Check if plant is favorited
        if tree:GetAttribute("Favorited") then
            print("â­ Skipping favorited tree:", tree.Name)
            continue
        end

        -- Check if plant has favorited fruit
        local Fruits = tree:FindFirstChild("Fruits")
        local hasFavoritedFruit = false
        if Fruits then
            for _, fruit in Fruits:GetChildren() do
                if fruit:GetAttribute("Favorited") then
                    print("â­ Skipping tree with favorited fruit:", tree.Name)
                    hasFavoritedFruit = true
                    break
                end
            end
        end
        if hasFavoritedFruit then continue end

        -- Check if plant can't be shoveled
        if CheckIfCantShovel(tree.Name) then
            print("ðŸš« Cannot shovel:", tree.Name)
            continue
        end

        -- Check if plant is valuable (would normally show confirmation prompt)
        if CheckIfValuable(tree.Name) then
            print("ðŸ’Ž Valuable plant detected:", tree.Name, "- auto-confirming shovel")
        end

        -- All checks passed - simulate mouse targeting and shovel the tree
        print("ðŸ”§ Shoveling tree:", tree.Name)

        -- Use raycasting to get the correct instance to pass to the remote (like real shovel)
        local targetInstance = simulateShovelClick(tree)

        if targetInstance then
            local success = pcall(function()
                -- Use the exact same remote call as the real shovel with the raycast hit instance
                Remove_Item:FireServer(targetInstance)
            end)

            if success then
                print("âœ… Successfully shoveled:", tree.Name, "- Instance:", targetInstance.Name)
                Library:Notify("ðŸŒ³ Shoveled " .. tree.Name, 1)
                task.wait(0.2) -- Wait to see if tree gets removed

                -- Check if tree was actually removed
                if tree.Parent == nil then
                    print("âœ… Tree confirmed removed:", tree.Name)
                else
                    print("âš ï¸ Tree still exists after shovel attempt:", tree.Name)
                end
            else
                print("âŒ Failed to shovel:", tree.Name)
                Library:Notify("âŒ Failed to shovel " .. tree.Name, 1)
            end
        else
            print("âŒ Could not target tree:", tree.Name)
            Library:Notify("âŒ Could not target " .. tree.Name, 1)
        end

        task.wait(0.1) -- Small delay between shovels
    end
end

-- Toggle for auto shovel
AutoShovelGroupBox:AddToggle("AutoShovel", {
    Text = "Auto Shovel Selected Tree",
    Default = false,
    Tooltip = "Automatically shovel all trees of the selected type in your farm",
    Callback = function(Value)
        AutoShovelEnabled = Value
        if Value then
            if not SelectedTreeToShovel then
                Library:Notify("âš ï¸ Please select a tree type first!", 3)
                Toggles.AutoShovel:SetValue(false)
                return
            end

            Library:Notify("ðŸŒ³ Auto Shovel enabled for " .. SelectedTreeToShovel .. " trees!", 3)

            -- Start auto shovel loop
            task.spawn(function()
                while AutoShovelEnabled do
                    shovelSelectedTree()
                    task.wait(1) -- Check every second
                end
            end)
        else
            Library:Notify("ðŸŒ³ Auto Shovel disabled!", 3)
        end
    end
})

-- Manual shovel button
AutoShovelGroupBox:AddButton("ðŸŒ³ Shovel Now", function()
    if not SelectedTreeToShovel then
        Library:Notify("âš ï¸ Please select a tree type first!", 3)
        return
    end
    shovelSelectedTree()
end)

-- ================================================================
-- CRAFTER TAB AUTO-INTEGRATION
-- ================================================================

-- Set global flag to indicate main script is loaded
if getgenv then
    getgenv().MainScriptLoaded = true
    -- Make essential variables globally accessible for CRAFTERTAB
    getgenv().Library = Library
    getgenv().Window = Window
    getgenv().Tabs = Tabs
end

-- Auto-load Crafter Tab from GitHub
local function loadCrafterTab()
    local success, result = pcall(function()
        print("ðŸ”¨ Loading Crafter Tab from GitHub...")
        -- Use the correct GitHub raw URL
        local githubUrl = "https://raw.githubusercontent.com/bihyudyfosydf/Resn/refs/heads/main/CRAFTERTAB"
        
        local response = game:HttpGet(githubUrl)
        print("ðŸ“¥ Response length:", #response)
        
        if response and #response > 0 then
            return loadstring(response)()
        else
            error("Empty response from GitHub")
        end
    end)

    if success and result then
        print("âœ… Crafter Tab loaded successfully!")
        Library:Notify("ðŸ”¨ Crafter Tab integrated! Check the new tab.", 3)
    else
        print("âš ï¸ Could not load Crafter Tab:", tostring(result))
        Library:Notify("âš ï¸ Crafter Tab failed to load - check console for details", 3)
        
        -- Additional debug info
        print("ï¿½ Debug: Make sure the CRAFTERTAB file exists at:")
        print("   https://raw.githubusercontent.com/bihyudyfosydf/Resn/refs/heads/main/CRAFTERTAB")
    end
end

-- Load Crafter Tab with a small delay to ensure everything is ready
task.spawn(function()
    task.wait(2) -- Wait 2 seconds for everything to initialize
    loadCrafterTab()
end)

-- ================================================================
-- SCRIPT COMPLETION MESSAGE
-- ================================================================
print("ðŸŒ± REFACTOR Main Script - Fully Loaded with Auto Crafter Integration!")
Library:Notify("ðŸš€ All systems loaded! Crafter Tab will appear in 2 seconds.", 4)
