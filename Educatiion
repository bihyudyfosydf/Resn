-- ================================================================
-- SIMPLE SEED CRAFTER TAB - Basic Recipe Claiming
-- Repository: Resn
-- ================================================================

-- Check if this is being loaded as a module or executed directly
local function initializeCrafterTab()
    -- Ensure we have access to the main script's variables
    if not Tabs or not Window or not Library then
        warn("‚ùå Crafter Tab: Main script not loaded! Please run the main script first.")
        return false
    end

    -- ================================================================
    -- CRAFTER TAB INITIALIZATION
    -- ================================================================
    local CrafterTab = Window:AddTab("Crafter", "hammer")
    
    -- ================================================================
    -- SEED CRAFTER GROUPBOX
    -- ================================================================
    local SeedCrafterGroupBox = CrafterTab:AddLeftGroupbox("Seed Crafter")

    -- ================================================================
    -- GEAR CRAFTER GROUPBOX
    -- ================================================================
    local GearCrafterGroupBox = CrafterTab:AddRightGroupbox("Gear Crafter")

    -- ================================================================
    -- GLOBAL VARIABLES
    -- ================================================================
    local SelectedRecipe = nil
    local AutoClaimEnabled = false
    
    -- Gear Crafter Variables
    local SelectedGearRecipe = nil
    local AutoGearClaimEnabled = false

    -- Services
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = game:GetService("Players").LocalPlayer
    local DataService = require(ReplicatedStorage.Modules.DataService)

    -- Remote Events
    local CraftingGlobalObjectService = ReplicatedStorage.GameEvents.CraftingGlobalObjectService
    local SeedEventCraftingWorkBench = workspace.CraftingTables.SeedEventCraftingWorkBench

    -- Available recipes
    local AvailableRecipes = {
        "Peace Lily",
        "Aloe Vera", 
        "Guanabana",
        "Horsetail",
        "Lingonberry",
        "Amber Spine",
        "Grand Volcania"
    }

    -- Available gear recipes
    local AvailableGearRecipes = {
        "Lightning Rod",
        "Reclaimer",
        "Small Toy",
        "Small Treat",
        "Tropical Mist Sprinkler",
        "Berry Blusher Sprinkler",
        "Spice Spritzer Sprinkler",
        "Sweet Soaker Sprinkler",
        "Flower Froster Sprinkler",
        "Stalk Sprout Sprinkler",
        "Mutation Spray Choc",
        "Mutation Spray Chilled",
        "Mutation Spray Pollinated",
        "Mutation Spray Shocked",
        "Anti Bee Egg",
        "Pack Bee"
    }

    -- Recipe data for inventory checking
    local RecipeData = {
        ["Peace Lily"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Rafflesia"},
                {ItemType = "Seed", ItemName = "Cauliflower"}
            },
            Cost = {CurrencyType = "SummerCoins", Amount = 3}
        },
        ["Aloe Vera"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Peace Lily"},
                {ItemType = "Holdable", ItemName = "Prickly Pear"}
            },
            Cost = {CurrencyType = "SummerCoins", Amount = 18}
        },
        ["Guanabana"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Aloe Vera"},
                {ItemType = "Seed", ItemName = "Prickly Pear"},
                {ItemType = "Holdable", ItemName = "Banana"}
            },
            Cost = {CurrencyType = "SummerCoins", Amount = 30}
        },
        ["Horsetail"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Stonebite"},
                {ItemType = "Holdable", ItemName = "Bamboo"},
                {ItemType = "Holdable", ItemName = "Corn"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 15000}
        },
        ["Lingonberry"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Blueberry"},
                {ItemType = "Seed", ItemName = "Blueberry"},
                {ItemType = "Seed", ItemName = "Blueberry"},
                {ItemType = "Holdable", ItemName = "Horsetail"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 450000}
        },
        ["Amber Spine"] = {
            Inputs = {
                {ItemType = "Seed", ItemName = "Cactus"},
                {ItemType = "Holdable", ItemName = "Pumpkin"},
                {ItemType = "Holdable", ItemName = "Horsetail"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 650000}
        },
        ["Grand Volcania"] = {
            Inputs = {
                {ItemType = "Holdable", ItemName = "Ember Lily"},
                {ItemType = "Holdable", ItemName = "Ember Lily"},
                {ItemType = "PetEgg", ItemName = "Dinosaur Egg"},
                {ItemType = "Seed Pack", ItemName = "Ancient Seed Pack"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 900000}
        }
    }

    -- Gear Recipe data for gear crafting
    local GearRecipeData = {
        ["Lightning Rod"] = {
            LayoutOrder = 5,
            TimeToCraft = 2700,
            Inputs = {
                {ItemType = "Sprinkler", ItemName = "Basic Sprinkler"},
                {ItemType = "Sprinkler", ItemName = "Advanced Sprinkler"},
                {ItemType = "Sprinkler", ItemName = "Godly Sprinkler"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 500000},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3265946758,
            RobuxPrice = 179
        },
        ["Reclaimer"] = {
            LayoutOrder = 8,
            TimeToCraft = 1500,
            Inputs = {
                {ItemType = "PetEgg", ItemName = "Common Egg"},
                {ItemType = "Harvest Tool", ItemName = "Harvest Tool"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 500000},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3309686533,
            RobuxPrice = 199
        },
        ["Small Toy"] = {
            LayoutOrder = 113,
            TimeToCraft = 600,
            Inputs = {
                {ItemType = "PetEgg", ItemName = "Common Egg"},
                {ItemType = "Seed", ItemName = "Coconut"},
                {ItemType = "Holdable", ItemName = "Coconut"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 1000000},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3329526448,
            RobuxPrice = 139
        },
        ["Small Treat"] = {
            LayoutOrder = 115,
            TimeToCraft = 600,
            Inputs = {
                {ItemType = "PetEgg", ItemName = "Common Egg"},
                {ItemType = "Seed", ItemName = "Dragon Fruit"},
                {ItemType = "Holdable", ItemName = "Blueberry"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 1000000},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3329527534,
            RobuxPrice = 89
        },
        ["Tropical Mist Sprinkler"] = {
            LayoutOrder = 10,
            TimeToCraft = 3600,
            Inputs = {
                {ItemType = "Holdable", ItemName = "Coconut"},
                {ItemType = "Holdable", ItemName = "Dragon Fruit"},
                {ItemType = "Holdable", ItemName = "Mango"},
                {ItemType = "Sprinkler", ItemName = "Godly Sprinkler"}
            },
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484251,
            RobuxPrice = 229
        },
        ["Berry Blusher Sprinkler"] = {
            LayoutOrder = 20,
            TimeToCraft = 3600,
            Inputs = {
                {ItemType = "Holdable", ItemName = "Grape"},
                {ItemType = "Holdable", ItemName = "Blueberry"},
                {ItemType = "Holdable", ItemName = "Strawberry"},
                {ItemType = "Sprinkler", ItemName = "Godly Sprinkler"}
            },
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484242,
            RobuxPrice = 229
        },
        ["Spice Spritzer Sprinkler"] = {
            LayoutOrder = 30,
            TimeToCraft = 3600,
            Inputs = {
                {ItemType = "Holdable", ItemName = "Pepper"},
                {ItemType = "Holdable", ItemName = "Ember Lily"},
                {ItemType = "Holdable", ItemName = "Cacao"},
                {ItemType = "Sprinkler", ItemName = "Master Sprinkler"}
            },
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484232,
            RobuxPrice = 229
        },
        ["Sweet Soaker Sprinkler"] = {
            LayoutOrder = 40,
            TimeToCraft = 3600,
            Inputs = {
                {ItemType = "Holdable", ItemName = "Watermelon"},
                {ItemType = "Holdable", ItemName = "Watermelon"},
                {ItemType = "Holdable", ItemName = "Watermelon"},
                {ItemType = "Sprinkler", ItemName = "Master Sprinkler"}
            },
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484252,
            RobuxPrice = 229
        },
        ["Flower Froster Sprinkler"] = {
            LayoutOrder = 50,
            TimeToCraft = 3600,
            Inputs = {
                {ItemType = "Holdable", ItemName = "Orange Tulip"},
                {ItemType = "Holdable", ItemName = "Daffodil"},
                {ItemType = "Sprinkler", ItemName = "Advanced Sprinkler"},
                {ItemType = "Sprinkler", ItemName = "Basic Sprinkler"}
            },
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484243,
            RobuxPrice = 229
        },
        ["Stalk Sprout Sprinkler"] = {
            LayoutOrder = 60,
            TimeToCraft = 3600,
            Inputs = {
                {ItemType = "Holdable", ItemName = "Bamboo"},
                {ItemType = "Holdable", ItemName = "Beanstalk"},
                {ItemType = "Holdable", ItemName = "Mushroom"},
                {ItemType = "Sprinkler", ItemName = "Advanced Sprinkler"}
            },
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484241,
            RobuxPrice = 229
        },
        ["Mutation Spray Choc"] = {
            LayoutOrder = 70,
            TimeToCraft = 720,
            Inputs = {
                {ItemType = "SprayBottle", ItemName = "Cleaning Spray"},
                {ItemType = "Holdable", ItemName = "Cacao"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 200000},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484247,
            RobuxPrice = 179
        },
        ["Mutation Spray Chilled"] = {
            LayoutOrder = 80,
            TimeToCraft = 300,
            Inputs = {
                {ItemType = "SprayBottle", ItemName = "Cleaning Spray"},
                {ItemType = "Sprinkler", ItemName = "Godly Sprinkler"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 500000},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3317772898,
            RobuxPrice = 189
        },
        ["Mutation Spray Pollinated"] = {
            LayoutOrder = 80,
            TimeToCraft = 300,
            Inputs = {
                {ItemType = "SprayBottle", ItemName = "Cleaning Spray"},
                {ItemType = "Holdable", ItemName = "Bee Balm"}
            },
            Cost = {CurrencyType = "Honey", Amount = 25},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484250,
            RobuxPrice = 179
        },
        ["Mutation Spray Shocked"] = {
            LayoutOrder = 90,
            TimeToCraft = 1800,
            Inputs = {
                {ItemType = "SprayBottle", ItemName = "Cleaning Spray"},
                {ItemType = "Lightning Rod", ItemName = "Lightning Rod"}
            },
            Cost = {CurrencyType = "Sheckles", Amount = 1000000},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484253,
            RobuxPrice = 199
        },
        ["Anti Bee Egg"] = {
            LayoutOrder = 110,
            TimeToCraft = 7200,
            Inputs = {
                {ItemType = "PetEgg", ItemName = "Bee Egg"}
            },
            Cost = {CurrencyType = "Honey", Amount = 25},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484244,
            RobuxPrice = 149
        },
        ["Pack Bee"] = {
            LayoutOrder = 120,
            TimeToCraft = 14400,
            Inputs = {
                {ItemType = "PetEgg", ItemName = "Anti Bee Egg"},
                {ItemType = "Holdable", ItemName = "Sunflower"},
                {ItemType = "Holdable", ItemName = "Purple Dahlia"}
            },
            Cost = {CurrencyType = "Honey", Amount = 250},
            MachineTypes = {"GearEventWorkbench"},
            PurchaseID = 3306484257,
            RobuxPrice = 799
        }
    }

    -- ================================================================
    -- HELPER FUNCTIONS
    -- ================================================================

    -- Function to check inventory for specific items
    local function checkInventoryForItems(recipe)
        if not recipe or not recipe.Inputs then return {} end
        
        local inventoryStatus = {}
        
        for _, input in ipairs(recipe.Inputs) do
            local itemName = input.ItemName
            local hasItem = false
            local itemCount = 0
            
            -- Check backpack for items using improved matching
            if LocalPlayer.Backpack then
                for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
                    local toolName = tool.Name:lower()
                    local searchName = itemName:lower()
                    local isMatch = false
                    
                    -- Try multiple matching strategies
                    if toolName == searchName or 
                       toolName:find(searchName, 1, true) or 
                       searchName:find(toolName, 1, true) then
                        isMatch = true
                    else
                        -- Clean names and try again
                        local cleanToolName = toolName:gsub("%s*seed%s*", ""):gsub("%s*%[x%d+%]%s*", "")
                        local cleanSearchName = searchName:gsub("%s*seed%s*", "")
                        if cleanToolName == cleanSearchName or cleanToolName:find(cleanSearchName, 1, true) then
                            isMatch = true
                        end
                    end
                    
                    if isMatch then
                        hasItem = true
                        -- Try to extract quantity from name (e.g., "Carrot Seed [X5]")
                        local quantityMatch = tool.Name:match("%[X(%d+)%]")
                        itemCount = itemCount + (tonumber(quantityMatch) or 1)
                    end
                end
            end
            
            table.insert(inventoryStatus, {
                ItemName = itemName,
                ItemType = input.ItemType,
                HasItem = hasItem,
                Count = itemCount
            })
        end
        
        return inventoryStatus
    end

    -- Function to check Summer Coins
    local function checkSummerCoins(requiredAmount)
        local success, currentCoins = pcall(function()
            return DataService:GetData().SpecialCurrency.SummerCoins or 0
        end)
        
        if not success then
            currentCoins = 0
        end
        
        return {
            Current = currentCoins,
            Required = requiredAmount,
            HasEnough = currentCoins >= requiredAmount
        }
    end

    -- Function to print inventory status to console
    local function printInventoryStatus(recipeName, inventoryStatus)
        print("==== INVENTORY CHECK FOR " .. recipeName .. " ====")
        for _, item in ipairs(inventoryStatus) do
            local status = item.HasItem and "‚úì HAVE" or "‚úó MISSING"
            local countText = item.HasItem and " (Count: " .. item.Count .. ")" or ""
            print(status .. " - " .. item.ItemType .. ": " .. item.ItemName .. countText)
        end
        print("================================")
    end

    -- Function to print currency status
    local function printCurrencyStatus(recipeName, coinStatus)
        print("==== CURRENCY CHECK FOR " .. recipeName .. " ====")
        local status = coinStatus.HasEnough and "‚úì HAVE ENOUGH" or "‚úó NOT ENOUGH"
        print(status .. " - Summer Coins: " .. coinStatus.Current .. "/" .. coinStatus.Required)
        print("================================")
    end

    -- Debug function to explore tool structure
    local function debugToolStructure(tool, depth)
        depth = depth or 0
        local indent = string.rep("  ", depth)
        
        print(indent .. "üìÅ " .. tool.Name .. " (" .. tool.ClassName .. ")")
        
        -- Print attributes
        local attributes = tool:GetAttributes()
        for name, value in pairs(attributes) do
            print(indent .. "  üè∑Ô∏è Attribute: " .. name .. " = " .. tostring(value))
        end
        
        -- Print children (limit depth to avoid spam)
        if depth < 3 then
            for _, child in pairs(tool:GetChildren()) do
                if child:IsA("ValueBase") then
                    print(indent .. "  üìÑ " .. child.Name .. " (" .. child.ClassName .. ") = " .. tostring(child.Value))
                else
                    debugToolStructure(child, depth + 1)
                end
            end
        end
    end

    -- Helper function to extract UUID from tool
    local function getItemUUID(tool)
        if not tool then return nil, nil end
        
        print("üîç Attempting to extract UUID from: " .. tool.Name)
        
        -- Method 1: Check for UUID attribute
        local uuid = tool:GetAttribute("UUID")
        if uuid then
            print("‚úÖ Found UUID via attribute: " .. uuid)
            return uuid, tool
        end
        
        -- Method 1.5: Check for common UUID attribute names (c, id, etc.)
        local attributes = tool:GetAttributes()
        for attrName, attrValue in pairs(attributes) do
            local attrStr = tostring(attrValue)
            -- Check if this looks like a UUID (contains { and } and -)
            if attrStr:find("{") and attrStr:find("}") and attrStr:find("-") then
                print("‚úÖ Found UUID-like attribute '" .. attrName .. "': " .. attrStr)
                return attrStr, tool
            end
        end
        
        -- Method 2: Check for UUID in tool's configuration or data
        local config = tool:FindFirstChild("Configuration") or tool:FindFirstChild("Data")
        if config then
            local uuidValue = config:FindFirstChild("UUID")
            if uuidValue then
                uuid = uuidValue.Value
                print("‚úÖ Found UUID in config: " .. uuid)
                return uuid, tool
            end
        end
        
        -- Method 3: Try equipping the tool to get UUID
        print("üéΩ Equipping tool to check for UUID...")
        local character = LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            -- Equip the tool
            local humanoid = character.Humanoid
            humanoid:EquipTool(tool)
            task.wait(0.2) -- Small delay to let the tool equip
            
            -- Check if tool is now in character and has UUID
            local equippedTool = character:FindFirstChild(tool.Name)
            if equippedTool then
                uuid = equippedTool:GetAttribute("UUID")
                if uuid then
                    print("‚úÖ Found UUID after equipping: " .. uuid)
                    -- Unequip the tool
                    humanoid:UnequipTools()
                    return uuid, tool
                end
                
                -- Check for UUID-like attributes in equipped tool
                local equippedAttributes = equippedTool:GetAttributes()
                for attrName, attrValue in pairs(equippedAttributes) do
                    local attrStr = tostring(attrValue)
                    if attrStr:find("{") and attrStr:find("}") and attrStr:find("-") then
                        print("‚úÖ Found UUID-like attribute '" .. attrName .. "' after equipping: " .. attrStr)
                        humanoid:UnequipTools()
                        return attrStr, tool
                    end
                end
                
                -- Check config again after equipping
                local equippedConfig = equippedTool:FindFirstChild("Configuration") or equippedTool:FindFirstChild("Data")
                if equippedConfig then
                    local uuidValue = equippedConfig:FindFirstChild("UUID")
                    if uuidValue then
                        uuid = uuidValue.Value
                        print("‚úÖ Found UUID in equipped tool config: " .. uuid)
                        humanoid:UnequipTools()
                        return uuid, tool
                    end
                end
                
                -- Unequip if no UUID found
                humanoid:UnequipTools()
            end
        end
        
        -- Method 4: Check all children for any UUID-like values
        print("üîç Searching all children for UUID-like values...")
        local function searchForUUID(obj)
            for _, child in pairs(obj:GetChildren()) do
                if child.Name:lower():find("uuid") or child.Name:lower():find("id") then
                    local value = nil
                    if child:IsA("StringValue") then
                        value = child.Value
                    elseif child:IsA("IntValue") or child:IsA("NumberValue") then
                        value = tostring(child.Value)
                    end
                    
                    if value and (value:find("{") or value:find("-") or #value > 10) then
                        print("‚úÖ Found potential UUID: " .. value .. " in " .. child.Name)
                        return value
                    end
                end
                
                -- Recursive search
                local foundUUID = searchForUUID(child)
                if foundUUID then return foundUUID end
            end
            return nil
        end
        
        uuid = searchForUUID(tool)
        if uuid then
            return uuid, tool
        end
        
        print("‚ùå Could not find UUID for tool: " .. tool.Name)
        return nil, nil
    end

    -- Function to find item UUID in player's backpack
    local function findItemUUID(itemName)
        if not LocalPlayer.Backpack then return nil end
        
        print("üîç Looking for item: " .. itemName)
        print("üì¶ Current backpack contents:")
        
        -- First, list all items in backpack for debugging
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            print("  - " .. tool.Name)
        end
        
        -- Try different matching strategies
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            local toolName = tool.Name:lower()
            local searchName = itemName:lower()
            
            -- Strategy 1: Exact match
            if toolName == searchName then
                print("‚úÖ Found exact match: " .. tool.Name)
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
            
            -- Strategy 2: Contains search term
            if toolName:find(searchName, 1, true) then
                print("‚úÖ Found partial match: " .. tool.Name .. " (searching for: " .. itemName .. ")")
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
            
            -- Strategy 3: Search term contains tool name (for cases like "Carrot" vs "Carrot Seed")
            if searchName:find(toolName, 1, true) then
                print("‚úÖ Found reverse match: " .. tool.Name .. " (searching for: " .. itemName .. ")")
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
            
            -- Strategy 4: Remove common suffixes/prefixes and try again
            local cleanToolName = toolName:gsub("%s*seed%s*", ""):gsub("%s*%[x%d+%]%s*", "")
            local cleanSearchName = searchName:gsub("%s*seed%s*", "")
            
            if cleanToolName == cleanSearchName or cleanToolName:find(cleanSearchName, 1, true) then
                print("‚úÖ Found cleaned match: " .. tool.Name .. " (searching for: " .. itemName .. ")")
                print("üî¨ Analyzing tool structure:")
                debugToolStructure(tool)
                return getItemUUID(tool)
            end
        end
        
        print("‚ùå Could not find " .. itemName .. " in backpack")
        return nil, nil
    end

    -- Function to automatically input items into recipe
    local function autoInputItems(recipeData)
        if not recipeData or not recipeData.Inputs then return false end
        
        print("üîÑ Auto-inputting items for recipe...")
        local allItemsInput = true
        
        for inputSlot, input in ipairs(recipeData.Inputs) do
            local itemName = input.ItemName
            local itemType = input.ItemType
            
            -- Find the item UUID in player's backpack
            local uuid, tool = findItemUUID(itemName)
            
            if uuid and tool then
                print("üì¶ Found " .. itemName .. " with UUID: " .. uuid)
                
                -- Input the item into the recipe slot
                local success, err = pcall(function()
                    CraftingGlobalObjectService:FireServer(
                        "InputItem",
                        SeedEventCraftingWorkBench,
                        "SeedEventWorkbench",
                        inputSlot, -- Slot number (1, 2, 3, etc.)
                        {
                            ItemType = itemType,
                            ItemData = {
                                UUID = uuid
                            }
                        }
                    )
                end)
                
                if success then
                    print("‚úÖ Successfully input " .. itemName .. " into slot " .. inputSlot)
                else
                    print("‚ùå Failed to input " .. itemName .. ": " .. tostring(err))
                    allItemsInput = false
                end
                
                task.wait(0.5) -- Small delay between inputs
            else
                print("‚ùå Could not find " .. itemName .. " in inventory")
                allItemsInput = false
            end
        end
        
        return allItemsInput
    end
    local function claimRecipe(recipeName)
        local success, err = pcall(function()
            print("üî® Setting recipe:", recipeName)
            CraftingGlobalObjectService:FireServer(
                "SetRecipe",
                SeedEventCraftingWorkBench,
                "SeedEventWorkbench",
                recipeName
            )
        end)

        if success then
            print("‚úÖ Successfully set recipe:", recipeName)
            -- Library:Notify("üî® Set recipe: " .. recipeName, 3) -- Disabled notification
            return true
        else
            print("‚ùå Failed to set recipe:", err)
            -- Library:Notify("‚ùå Failed to set recipe: " .. recipeName, 3) -- Disabled notification
            return false
        end
    end

    -- Function to claim gear recipe
    local function claimGearRecipe(recipeName)
        local success, err = pcall(function()
            print("‚öôÔ∏è Setting gear recipe:", recipeName)
            local EventCraftingWorkBench = workspace.CraftingTables.EventCraftingWorkBench
            local SelectCraftingRecipeBindableEvent = ReplicatedStorage.GameEvents.SelectCraftingRecipeBindableEvent
            
            local recipeData = GearRecipeData[recipeName]
            if not recipeData then
                error("Recipe data not found for: " .. recipeName)
            end
            
            -- Fire the bindable event with the recipe data
            SelectCraftingRecipeBindableEvent:Fire(
                EventCraftingWorkBench,
                recipeName,
                recipeData
            )
        end)

        if success then
            print("‚úÖ Successfully set gear recipe:", recipeName)
            return true
        else
            print("‚ùå Failed to set gear recipe:", err)
            return false
        end
    end

    -- Function to automatically input gear items into recipe (enhanced with auto-craft)
    local function autoInputGearItems(recipeData)
        return autoInputItemsAndCraft(recipeData, workspace.CraftingTables.EventCraftingWorkBench, "GearEventWorkbench")
    end

    -- Function to start crafting after items are input
    local function startCrafting(workbench, workbenchType)
        local success, err = pcall(function()
            print("‚öôÔ∏è Starting crafting process...")
            CraftingGlobalObjectService:FireServer(
                "Craft",
                workbench,
                workbenchType
            )
        end)
        
        if success then
            print("‚úÖ Successfully started crafting!")
            return true
        else
            print("‚ùå Failed to start crafting:", err)
            return false
        end
    end

    -- Function to claim finished crafted items
    local function claimCraftedItems(workbench, workbenchType, slotNumber)
        slotNumber = slotNumber or 1 -- Default to slot 1
        local success, err = pcall(function()
            print("üéÅ Claiming crafted items...")
            CraftingGlobalObjectService:FireServer(
                "Claim",
                workbench,
                workbenchType,
                slotNumber
            )
        end)
        
        if success then
            print("‚úÖ Successfully claimed crafted items!")
            return true
        else
            print("‚ùå Failed to claim items:", err)
            return false
        end
    end

    -- Function to check if crafting is complete
    local function isCraftingComplete(workbench, workbenchType)
        local success, result = pcall(function()
            local CraftingGlobalObjectService_module = require(ReplicatedStorage.Modules.CraftingService.CraftingGlobalObjectService)
            local machineData = CraftingGlobalObjectService_module:GetIndividualCraftingMachineData(workbench, workbenchType)
            
            if machineData and machineData.CraftingItems and machineData.CraftingItems[1] then
                return machineData.CraftingItems[1].IsDone
            end
            return false
        end)
        
        if success then
            return result
        else
            print("‚ö†Ô∏è Could not check crafting status:", result)
            return false
        end
    end

    -- Enhanced auto input items function with automatic crafting
    local function autoInputItemsAndCraft(recipeData, workbench, workbenchType)
        if not recipeData or not recipeData.Inputs then return false end
        
        print("üîÑ Auto-inputting items and starting craft for recipe...")
        local allItemsInput = true
        
        for inputSlot, input in ipairs(recipeData.Inputs) do
            local itemName = input.ItemName
            local itemType = input.ItemType
            
            -- Find the item UUID in player's backpack
            local uuid, tool = findItemUUID(itemName)
            
            if uuid and tool then
                print("üì¶ Found " .. itemName .. " with UUID: " .. uuid)
                
                -- Input the item into the recipe slot
                local success, err = pcall(function()
                    CraftingGlobalObjectService:FireServer(
                        "InputItem",
                        workbench,
                        workbenchType,
                        inputSlot, -- Slot number (1, 2, 3, etc.)
                        {
                            ItemType = itemType,
                            ItemData = {
                                UUID = uuid
                            }
                        }
                    )
                end)
                
                if success then
                    print("‚úÖ Successfully input " .. itemName .. " into slot " .. inputSlot)
                else
                    print("‚ùå Failed to input " .. itemName .. ": " .. tostring(err))
                    allItemsInput = false
                end
                
                task.wait(0.5) -- Small delay between inputs
            else
                print("‚ùå Could not find " .. itemName .. " in inventory")
                allItemsInput = false
            end
        end
        
        -- If all items were successfully input, start crafting
        if allItemsInput then
            task.wait(1) -- Wait a moment for items to register
            print("üöÄ All items input successfully! Starting crafting...")
            
            local craftStarted = startCrafting(workbench, workbenchType)
            if craftStarted then
                print("‚è≥ Crafting started! Monitoring for completion...")
                
                -- Monitor crafting progress
                task.spawn(function()
                    local maxWaitTime = 300 -- 5 minutes max wait
                    local waitedTime = 0
                    local checkInterval = 2 -- Check every 2 seconds
                    
                    while waitedTime < maxWaitTime do
                        if isCraftingComplete(workbench, workbenchType) then
                            print("üéâ Crafting completed! Auto-claiming...")
                            task.wait(1) -- Small delay before claiming
                            claimCraftedItems(workbench, workbenchType)
                            break
                        end
                        
                        task.wait(checkInterval)
                        waitedTime = waitedTime + checkInterval
                        
                        if waitedTime % 30 == 0 then -- Progress update every 30 seconds
                            print("‚è≥ Still crafting... (" .. waitedTime .. "s elapsed)")
                        end
                    end
                    
                    if waitedTime >= maxWaitTime then
                        print("‚ö†Ô∏è Crafting timeout reached. You may need to manually claim.")
                    end
                end)
            end
        end
        
        return allItemsInput
    end

    -- Enhanced autoInputItems that uses the full auto-craft functionality
    local function autoInputItemsEnhanced(recipeData)
        return autoInputItemsAndCraft(recipeData, SeedEventCraftingWorkBench, "SeedEventWorkbench")
    end

    -- Enhanced autoInputGearItems that uses the full auto-craft functionality  
    local function autoInputGearItemsEnhanced(recipeData)
        return autoInputItemsAndCraft(recipeData, workspace.CraftingTables.EventCraftingWorkBench, "GearEventWorkbench")
    end

    -- ================================================================
    -- UI ELEMENTS
    -- ================================================================

    -- Recipe selection dropdown
    SeedCrafterGroupBox:AddDropdown("RecipeSelection", {
        Values = AvailableRecipes,
        Default = 1,
        Multi = false, -- Single selection only
        Text = "Select Recipe",
        Tooltip = "Choose which recipe to claim/set",
        Callback = function(Value)
            SelectedRecipe = Value
            print("[cb] Selected recipe:", Value)
        end,
    })

    -- Auto claim toggle
    SeedCrafterGroupBox:AddToggle("AutoClaim", {
        Text = "üî® Auto Craft Recipe (Full Auto)",
        Default = false,
        Tooltip = "Set recipe, input items, start crafting, and auto-claim when done - fully automatic!",
        Callback = function(Value)
            print("[cb] Auto Craft Recipe toggled:", Value)
            
            if Value then
                if not SelectedRecipe then
                    print("‚ö†Ô∏è Please select a recipe first!")
                    -- Use task.wait to avoid immediate callback loop
                    task.wait(0.1)
                    if Toggles and Toggles.AutoClaim then
                        Toggles.AutoClaim:SetValue(false)
                    end
                    return
                end

                print("üî® Auto-crafting recipe:", SelectedRecipe)
                
                -- Step 1: Set the recipe
                claimRecipe(SelectedRecipe)
                task.wait(1) -- Wait for recipe to be set
                
                -- Step 2: Auto-input available items and start crafting
                local recipeData = RecipeData[SelectedRecipe]
                if recipeData then
                    autoInputItemsEnhanced(recipeData)
                end
                
                -- Turn toggle back off after processing
                task.wait(0.1)
                if Toggles and Toggles.AutoClaim then
                    Toggles.AutoClaim:SetValue(false)
                end
            end
        end
    })

    SeedCrafterGroupBox:AddDivider()

    -- ================================================================
    -- GEAR CRAFTER UI ELEMENTS  
    -- ================================================================

    -- Gear Recipe selection dropdown
    GearCrafterGroupBox:AddDropdown("GearRecipeSelection", {
        Values = AvailableGearRecipes,
        Default = 1,
        Multi = false, -- Single selection only
        Text = "Select Gear Recipe",
        Tooltip = "Choose which gear recipe to claim/set",
        Callback = function(Value)
            SelectedGearRecipe = Value
            print("[cb] Selected gear recipe:", Value)
        end,
    })

    -- Auto gear claim toggle
    GearCrafterGroupBox:AddToggle("AutoGearClaim", {
        Text = "‚öôÔ∏è Auto Craft Gear (Full Auto)",
        Default = false,
        Tooltip = "Set gear recipe, input items, start crafting, and auto-claim when done - fully automatic!",
        Callback = function(Value)
            print("[cb] Auto Craft Gear toggled:", Value)
            
            if Value then
                if not SelectedGearRecipe then
                    print("‚ö†Ô∏è Please select a gear recipe first!")
                    -- Use task.wait to avoid immediate callback loop
                    task.wait(0.1)
                    if Toggles and Toggles.AutoGearClaim then
                        Toggles.AutoGearClaim:SetValue(false)
                    end
                    return
                end

                print("‚öôÔ∏è Auto-crafting gear recipe:", SelectedGearRecipe)
                
                -- Step 1: Set the gear recipe
                claimGearRecipe(SelectedGearRecipe)
                task.wait(1) -- Wait for recipe to be set
                
                -- Step 2: Auto-input available gear items and start crafting
                local recipeData = GearRecipeData[SelectedGearRecipe]
                if recipeData then
                    autoInputGearItemsEnhanced(recipeData)
                end
                
                -- Turn toggle back off after processing
                task.wait(0.1)
                if Toggles and Toggles.AutoGearClaim then
                    Toggles.AutoGearClaim:SetValue(false)
                end
            end
        end
    })

    GearCrafterGroupBox:AddDivider()

    -- ================================================================
    -- AUTO CLAIM GROUPBOX (Persistent Monitoring)
    -- ================================================================
    local AutoClaimGroupBox = CrafterTab:AddLeftGroupbox("Auto Claim Monitor üéÅ")

    -- Variables for persistent auto claim
    local PersistentAutoClaimEnabled = false
    local autoClaimConnection = nil
    local lastClaimTime = 0

    -- Function to check and claim from both workbenches
    local function checkAndClaimFinishedItems()
        if not PersistentAutoClaimEnabled then 
            return 
        end
        
        -- Add delay between claim attempts
        local currentTime = tick()
        if currentTime - lastClaimTime < 3 then
            return -- Wait at least 3 seconds between claims
        end
        
        local claimedSomething = false
        
        -- Check Seed Workbench
        pcall(function()
            if isCraftingComplete(SeedEventCraftingWorkBench, "SeedEventWorkbench") then
                print("üéÅ Seed crafting complete! Auto-claiming...")
                if claimCraftedItems(SeedEventCraftingWorkBench, "SeedEventWorkbench", 1) then
                    Library:Notify("üéÅ Auto-claimed seed crafting result!", 3)
                    claimedSomething = true
                    lastClaimTime = currentTime
                end
            end
        end)
        
        -- Check Gear Workbench
        pcall(function()
            local GearEventWorkBench = workspace.CraftingTables:FindFirstChild("EventCraftingWorkBench")
            if GearEventWorkBench and isCraftingComplete(GearEventWorkBench, "GearEventWorkbench") then
                print("üéÅ Gear crafting complete! Auto-claiming...")
                if claimCraftedItems(GearEventWorkBench, "GearEventWorkbench", 1) then
                    Library:Notify("üéÅ Auto-claimed gear crafting result!", 3)
                    claimedSomething = true
                    lastClaimTime = currentTime
                end
            end
        end)
        
        -- Also try checking all other crafting objects just in case
        pcall(function()
            local CollectionService = game:GetService("CollectionService")
            for _, craftingObject in pairs(CollectionService:GetTagged("CraftingObject")) do
                if craftingObject:IsDescendantOf(workspace) then
                    local machineType = craftingObject:GetAttribute("CraftingObjectType")
                    if machineType and isCraftingComplete(craftingObject, machineType) then
                        print("üéÅ Found completed crafting on:", craftingObject.Name, "- Auto-claiming...")
                        if claimCraftedItems(craftingObject, machineType, 1) then
                            Library:Notify("üéÅ Auto-claimed from " .. craftingObject.Name .. "!", 3)
                            claimedSomething = true
                            lastClaimTime = currentTime
                            break -- Only claim one at a time to avoid spam
                        end
                    end
                end
            end
        end)
        
        if claimedSomething then
            print("‚úÖ Auto-claim successful - next check in 3+ seconds")
        end
    end

    -- Persistent Auto Claim toggle
    AutoClaimGroupBox:AddToggle("PersistentAutoClaim", {
        Text = "üéÅ Auto Claim Finished Items",
        Default = false,
        Tooltip = "Continuously monitor and auto-claim any finished crafting items from all workbenches - works even after rejoining!",
        Callback = function(Value)
            PersistentAutoClaimEnabled = Value
            print("[cb] Persistent Auto Claim toggled:", Value)
            
            if Value then
                Library:Notify("üéÅ Auto Claim Monitor enabled! Will check all workbenches continuously.", 4)
                
                -- Clear timing
                lastClaimTime = 0
                
                -- Start monitoring loop
                autoClaimConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    -- Run check every few heartbeats to avoid performance issues
                    if tick() % 2 < 0.1 then -- Check roughly every 2 seconds
                        checkAndClaimFinishedItems()
                    end
                end)
                
                -- Also do an immediate check
                task.spawn(checkAndClaimFinishedItems)
            else
                Library:Notify("üéÅ Auto Claim Monitor disabled!", 3)
                
                -- Stop monitoring loop
                if autoClaimConnection then
                    autoClaimConnection:Disconnect()
                    autoClaimConnection = nil
                end
                
                lastClaimTime = 0
            end
        end,
    })

    AutoClaimGroupBox:AddLabel("üí° This monitor works independently")
    AutoClaimGroupBox:AddLabel("of the auto-craft toggles above.")
    AutoClaimGroupBox:AddLabel("Perfect for when you rejoin and")
    AutoClaimGroupBox:AddLabel("crafting finished while away!")

    -- ================================================================
    -- SUCCESS MESSAGE
    -- ================================================================
    -- Library:Notify("üî® Simple Seed Crafter loaded!", 3) -- Disabled notification
    print("üî® Simple Seed Crafter initialized with " .. #AvailableRecipes .. " recipes")
    print("‚öôÔ∏è Gear Crafter initialized with " .. #AvailableGearRecipes .. " gear recipes (includes new recipes: Small Toy, Small Treat, Mutation Spray Pollinated)")

    return true
end

-- ================================================================
-- AUTO-EXECUTION AND MODULE COMPATIBILITY
-- ================================================================

-- Check if this is being executed directly or loaded as a module
if getgenv and getgenv().MainScriptLoaded then
    -- Main script is already loaded, initialize immediately
    local success = initializeCrafterTab()
    if success then
        print("‚úÖ Simple Seed Crafter successfully integrated!")
    end
else
    -- Wait for main script to load, then initialize
    print("‚è≥ Waiting for main script to load...")
    
    local function waitForMainScript()
        local maxWait = 30 -- seconds
        local waited = 0
        
        while waited < maxWait do
            if getgenv and getgenv().MainScriptLoaded and Tabs and Window and Library then
                local success = initializeCrafterTab()
                if success then
                    print("‚úÖ Simple Seed Crafter successfully integrated after waiting!")
                    return true
                end
            end
            
            task.wait(0.5)
            waited = waited + 0.5
        end
        
        warn("‚ö†Ô∏è Simple Seed Crafter: Timed out waiting for main script")
        return false
    end
    
    -- Run the wait function
    task.spawn(waitForMainScript)
end

-- ================================================================
-- LOADSTRING COMPATIBILITY (for raw GitHub execution)
-- ================================================================

return {
    initialize = initializeCrafterTab,
    name = "Simple Seed & Gear Crafter",
    version = "1.2.0",
    repository = "Resn"
}
